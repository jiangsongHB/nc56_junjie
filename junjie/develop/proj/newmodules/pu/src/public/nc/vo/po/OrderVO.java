package nc.vo.po;
/**
 * 功能说明:
 * OrderHeaderVO和OrderItemVO的聚合类
 *
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Vector;

import nc.bs.framework.common.NCLocator;
import nc.itf.po.base.IOrderstatus;
import nc.itf.scm.cenpur.service.CentrPurchaseUtil;
import nc.itf.scm.cenpur.service.ChgDataUtil;
import nc.itf.scm.pub.ICoopwithForVO;
import nc.itf.uap.busibean.SysinitAccessor;
import nc.ui.pub.ClientEnvironment;
import nc.ui.scm.pub.cache.CacheTool;
import nc.vo.ml.NCLangRes4VoTransl;
import nc.vo.po.pub.OrderVORefreshTool;
import nc.vo.po.pub.PoSaveCheckParaVO;
import nc.vo.po.rp.OrderReceivePlanVO;
import nc.vo.pu.ic.IBillAction;
import nc.vo.pub.AggregatedValueObject;
import nc.vo.pub.BusinessException;
import nc.vo.pub.CircularlyAccessibleValueObject;
import nc.vo.pub.VOStatus;
import nc.vo.pub.ValidationException;
import nc.vo.pub.billcodemanage.BillCodeObjValueVO;
import nc.vo.pub.lang.UFBoolean;
import nc.vo.pub.lang.UFDate;
import nc.vo.pub.lang.UFDouble;
import nc.vo.pub.pf.IGetBusiDataForFlow;
import nc.vo.pub.pf.IPfRetCheckInfo;
import nc.vo.scm.constant.ScmConst;
import nc.vo.scm.field.pu.FieldDBValidate;
import nc.vo.scm.pu.BillStatus;
import nc.vo.scm.pu.PuPubVO;
import nc.vo.scm.pu.RelationsCalVO;
import nc.vo.scm.pu.VariableConst;
import nc.vo.scm.pub.BillRowNoVO;
import nc.vo.scm.pub.IBillCode;
import nc.vo.scm.pub.IVendorInfo;
import nc.vo.scm.pub.IscmDefCheckVO;
import nc.vo.scm.pub.SCMEnv;
import nc.vo.scm.pub.smart.ObjectUtils;
import nc.vo.scm.relacal.SCMRelationsCal;
import nc.vo.sm.log.OperatelogVO;

public class OrderVO extends AggregatedValueObject  
	implements IBillCode,
	IVendorInfo,
	IBillAction,
	IPfRetCheckInfo,
	IGetBusiDataForFlow,
  IscmDefCheckVO,ICoopwithForVO{
	/**
	*  以下手工完成代码
	*/	
	//是否存在关闭的行
	private UFBoolean m_ufbExistClosed = UFBoolean.FALSE;
	//折扣属性哈希表
	private static Hashtable hashDiscountFlag = null;
	//劳务属性哈希表
	private static Hashtable hashLaborFlag = null;
	//处理转单时，是否曾进行过除转单外的其他加载处理
	//如果有多张单据转入，本处理用于节省时间，只对第一张进行表体的处理，其他单据点中时再处理
	private	boolean	m_bBodyChanged = false ;
	
	//是否第一次传入，用于处理保存时的“提示”
	private	boolean	m_bFirstTime=true ;
	//是否第一次传入，用于处理订单行超现存量的“提示”
	private	boolean	m_bFirstTimeSP = true ;	
	//是否第一次传入，用于处理订单行超最高库存的“提示”
	private	boolean	m_bFirstTimeStock = true ;
	//是否第一次传入，用于处理订单行超最高限价的“提示”
	private	boolean	m_bFirstTimePrice = true ;
	
	private String m_busitype = null;
	////支持集中订单审批流处理，增加属性集中订单公司（制单人公司）
	private String m_grourPkCorp = null;
	//操作类型：1增加  2修改  3作废	参考类VOStatus
	private int     m_iStatus = VOStatus.UNCHANGED;
	private OrderReceivePlanVO[] m_voaOldRP = null;
	//到货计划VO数组：用于到货计划的保存。
	private OrderReceivePlanVO[] m_voaRP = null;
	//此单据的旧VO：用于保存时作检查用，请正确设置此值，否则检查会不正确
	private OrderVO m_voOld = null;
	/**
	*  以下CodeSeed3.1生成代码
	*/
	private OrderHeaderVO m_voParent=null;//主表
	private OrderItemVO[] m_voaChildren=null;//子表
	// 时间戳标示，现在暂未使用：
	long currentTimestamp; // 当前时间戳
	long initialTimestamp; // 从数据库读入时获得的时间戳

    //单据动作(V5:ATP调整,要求传入)
    private String m_strBillAction = IBillAction.ACTION_NULL;

    //v50,支持外部系统重复导入设计，是否需要调用单据号生成,默认是要调用生成(兼容旧版本), by Chao , on 2006-10-20
    private boolean m_bNeedCreatNewBillCode = true;
    
    //v501,是否超最高库存函数需要
    private boolean m_bUsedByFunc = false;
    
    private OperatelogVO m_OperatelogVO;//佛山碧桂园:记录业务日志
    
    private boolean bIsCoop = false;
    
    public boolean getIsCoop(){
    	return bIsCoop;
    }
    public void setIsCoop(boolean value){
    	bIsCoop = value;
    }
    /**
     * 是否函数调用
     * @return
     */
    public boolean isUsedByFunc(){
    	return m_bUsedByFunc;
    }
    /**
     * 设置是否函数调用
     * @para bNewVal 
     */
    public void setUsedByFunc(boolean bNewVal){
    	m_bUsedByFunc = bNewVal; 
    }
    /**
     * 获取：是否需要调用单据号生成
     * @param bNewVal
     * @author czp
     */
    public boolean isNeedCreateNewBillCode(){
    	return m_bNeedCreatNewBillCode;
    }   
    /**
     * 设置：是否需要调用单据号生成
     * @param bNewVal
     * @author czp
     */
    public void setNeedCreateNewBillCode(boolean bNewVal){
    	m_bNeedCreatNewBillCode = bNewVal;
    }
    /**
     * 设置存在关闭的行
     * @param ufdNewVal
     * @since v50
     * @author czp
     */
    public boolean isExistClosed(){
    	return m_ufbExistClosed == null ? false : m_ufbExistClosed.booleanValue();
    }
    /**
     * 设置存在关闭的行
     * @param ufdNewVal
     * @since v50
     * @author czp
     */
    public void setExistClosed(UFBoolean ufbNewVal){
    	m_ufbExistClosed = ufbNewVal;
    }
    /**
     * 是否第一次保存--最高库存
     * @return
     */
    public boolean isFirstTimeStock(){
    	return m_bFirstTimeStock;
    }
    /**
     * 设置是否第一次保存--最高库存
     * @param newVal
     */
    public void setFirstTimeStock(boolean newVal){
    	m_bFirstTimeStock = newVal;
    }
    /**
     * 是否第一次保存--最高限价
     * @return
     */
    public boolean isFirstTimePrice(){
    	return m_bFirstTimePrice;
    }
    /**
     * 设置是否第一次保存--最高限价
     * @param newVal
     */
    public void setFirstTimePrice(boolean newVal){
    	m_bFirstTimePrice = newVal;
    }
    /**
     * 整单关闭算法
     */
    public boolean isAllRowsClosed(){
    	//如果表体无数据，认为整单关闭
    	if(m_voaChildren == null || m_voaChildren.length == 0){
    		return true;
    	}
    	//存在未关闭的行，返回false
    	int iLen = m_voaChildren.length;
    	for(int i=0;i<iLen;i++){
    		if(m_voaChildren[i] == null){
    			continue;
    		}
    		if(m_voaChildren[i].isActive()){
    			return false;
    		}
    	}
    	//所有行关闭，返回true
    	return true;
    }
    /**
     * 返回当前单据动作
     **/
    public String getBillAction(){
    	return m_strBillAction;
    }
    /**
     * 设置当前单据动作
     **/
    public void setBillAction(String newVal){
    	m_strBillAction = newVal;
    }
/**
 * @author czp
 * @功能：返回本单据所有收货库存组织(去重复)数组及与之对应的收货公司数组
 * @return ArrayList{0:收货库存组织ID,1:收货公司ID,2:存货基本档案ID}
 * @since V50
 * @date 2006-03-08
 */
public ArrayList<String[]> getArrCorpArrStoOrgIds() {
	if (getBodyVO() == null || getBodyVO().length == 0) {
		return null;
	}
	ArrayList<String> listCorp = new ArrayList<String>();
	ArrayList<String> listStoOrg = new ArrayList<String>();
	ArrayList<String> listBaseId = new ArrayList<String>();
	String strCorp = null;
	String strStoOrg = null;
	String strBaseId = null;
	String strComKey = null;	
	int iLen = getBodyVO().length;
	HashMap<String, String> mapComKey = new HashMap<String, String>();
	for (int i = 0; i < iLen; i++) {
		if (getBodyVO()[i] == null) {
			continue;
		}
		strCorp = PuPubVO.getString_TrimZeroLenAsNull(getBodyVO()[i].getPk_arrvcorp());
		strStoOrg = PuPubVO.getString_TrimZeroLenAsNull(getBodyVO()[i].getPk_arrvstoorg());
		strBaseId = PuPubVO.getString_TrimZeroLenAsNull(getBodyVO()[i].getCbaseid());
		if(strStoOrg == null){
			continue;
		}
		strComKey = strCorp + strStoOrg + strBaseId;
		if(mapComKey.containsKey(strComKey)){
			continue;
		}
		listStoOrg.add(strStoOrg);
		listCorp.add(strCorp);
		listBaseId.add(strBaseId);
		//
		mapComKey.put(strComKey, "");
	}
	if (listStoOrg.size() == 0) {
		return null;
	}
	// 返回
	ArrayList<String[]> listRet = new ArrayList<String[]>();
	listRet.add((String[]) listStoOrg.toArray(new String[listStoOrg.size()]));
	listRet.add((String[]) listCorp.toArray(new String[listStoOrg.size()]));
	listRet.add((String[]) listBaseId.toArray(new String[listStoOrg.size()]));
	//
	return listRet;
}
/**
 * @author czp
 * @功能：返回本单据所有收货库存组织(去重复)数组
 * @since V50
 * @date 2006-03-08
 */	
public String[] getArrStoOrgIds(){
	if(getBodyVO() == null || getBodyVO().length == 0){
		return null;
	}
	ArrayList listArrStoOrg = new ArrayList();
	int iLen = getBodyVO().length;
	for(int i=0;i<iLen;i++){
		if(getBodyVO()[i] == null 
				|| PuPubVO.getString_TrimZeroLenAsNull(getBodyVO()[i].getPk_arrvstoorg()) == null
				|| listArrStoOrg.contains(PuPubVO.getString_TrimZeroLenAsNull(getBodyVO()[i].getPk_arrvstoorg()))){
			continue;
		}
		listArrStoOrg.add(PuPubVO.getString_TrimZeroLenAsNull(getBodyVO()[i].getPk_arrvstoorg()));
	}
	if(listArrStoOrg.size() == 0){
		return null;
	}
	//返回
	return (String[]) listArrStoOrg.toArray(new String[listArrStoOrg.size()]);
}
/**
 * 获得子表的VO数组。
 *
 *
 * return nc.vo.pub.CircularlyAccessibleValueObject[]
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public CircularlyAccessibleValueObject[] getChildrenVO() {
	return m_voaChildren;
}
/**
 * 获得主表的VO.
 *
 *
 * return nc.vo.pub.CircularlyAccessibleValueObject
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public CircularlyAccessibleValueObject getParentVO() {
	return m_voParent;
}
/**
 * 设置子表的VO数组。
 *
 * 参数说明:
 * nc.vo.pub.CircularlyAccessibleValueObject[] voaChildren:子表的VO数组
 *
 * 无返回值
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public void setChildrenVO(CircularlyAccessibleValueObject[] voaChildren){

	if(voaChildren instanceof OrderItemVO[]){
		m_voaChildren =(OrderItemVO[]) voaChildren;
	}else{
		if(voaChildren != null && voaChildren.length > 0){
			m_voaChildren = new OrderItemVO[voaChildren.length];
			for(int i=0; i<voaChildren.length; i++){
				m_voaChildren[i] = (OrderItemVO) voaChildren[i];
			}
		}else{
			m_voaChildren = null;
		}
	}
}
/**
 * 设置主表的VO.
 *
 * 参数说明:
 * nc.vo.pub.CircularlyAccessibleValueObject voParent:主表VO
 *
 * 无返回值
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public void setParentVO(CircularlyAccessibleValueObject voParent){
	m_voParent =(OrderHeaderVO) voParent;
}
/**
 * 为表头VO设置主键，用来唯一定位对象。
 *
 * 参数说明:
 * String sPK:主键
 *
 * 无返回值
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public void setPrimaryKey(String sPK) {
	try{
		if(m_voParent != null)
			m_voParent.setPrimaryKey(sPK);
	}catch(Exception e){
		 SCMEnv.out(e);
	}
}
/**
 * clone,使用了毕佥谦写的新方法.
 *
 *
 * return Cloned Object
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public OrderVO clone(){
	Object oCloned= null;
	try{
		oCloned= ObjectUtils.serializableClone(this);
	}catch(Exception e){
		 SCMEnv.out(e);
	}
	return (OrderVO) oCloned;
}
/**
 * 获取生成单据号所需的数据
 *
 *
 * return BillCodeObjValueVO
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public BillCodeObjValueVO getBillCodeObjVO(){
	BillCodeObjValueVO voBCOV = new BillCodeObjValueVO();
	//add your code here
	return voBCOV;
}
/**
 * 获取单据类型编码
 *
 *
 * return String
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public String getBillTypeCode() {
	if(m_voParent!=null)
		return m_voParent.getCtypecode();
	else
		return null;
}
/**
 * 获取公司PK
 *
 *
 * return String
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public String getPk_corp() {
	if(m_voParent!=null)
		return m_voParent.getPk_corp();
	else
		return null;
}
/**
 * 获取单据号
 *
 *
 * return String
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public String getVBillCode() {
	if(m_voParent!=null)
		return m_voParent.getVcode();
	else
		return null;
}
/**
 * 设置单据号
 *
 * 参数说明:
 * String vCode:单据号
 *
 * 无返回值
 *
 * Generated By CodeSeed 3.1
 * 修改记录：
 * 修改人,	日期,		说明
 *
 *
*/
public void setVBillCode(String vCode) {
	if(m_voParent!=null)
		m_voParent.setVcode(vCode);
}
/**
 * 功能描述：得到该单据的操作状态
 * 输入参数：无
 * 返回值：　int		单据状态
 * 异常处理：无
 * 作者：王印芬
 * 日期：2003-06-30
 */
public int getStatus() {

	return m_iStatus;
}
/*
 * 作者：王印芬
 * 功能：设置该单据的操作状态，此状态非常重要，不可随意更改
 * 参数：int status			新状态
 * 返回：无
 * 例外：无
 * 日期：(2004-04-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public void setStatus(int status) {

	m_iStatus = status;
	if(status == VOStatus.DELETED){
	for(int i = 0 ; i < getBodyVO().length ; i ++){
		getBodyVO()[i].setStatus(status);
	}
	}
}
/**
 * 作者：WYF
 * 功能：构造方法
 * 参数：无
 * 返回：无
 * 例外：无
 * 日期：(2004-04-21 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderVO() {
	this(0);
}

/**
* 作者：WYF
* 功能：构造方法
* 参数：无
* 返回：无
* 例外：无
* 日期：(2004-04-21 11:39:21)
* 修改日期，修改人，修改原因，注释标志：
*/
public OrderVO(int num) {

	m_voParent = new OrderHeaderVO();

	m_voaChildren = new OrderItemVO[num];
	for (int i = 0; i < num; i++) {
		m_voaChildren[i] = new OrderItemVO();
	}
}

/**
 * 作者：WYF
 * 功能：构造方法
 * 参数：无
 * 返回：无
 * 例外：无
 * 日期：(2004-04-21 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderVO(OrderHeaderVO	voHead,OrderItemVO[]	voaItem) {

	setParentVO(voHead) ;
	setChildrenVO(voaItem) ;
}

/**
 * 作者：王印芬
 * 功能：得到用于关闭或打开的订单VO，通过关闭的体VO数组
 * 参数：
 * 返回：OrderVO		界面上的VO
 * 例外：无
 * 日期：(2004-03-11 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public static	OrderVO	getAtpVOByCloseVOs(OrderCloseItemVO[]	voaClose){

	if (voaClose==null) {
		return	null ;
	}

	OrderVO	voOrder = new	OrderVO() ;

	voOrder.getHeadVO().setCorderid(voaClose[0].getCorderid()) ;
	voOrder.getHeadVO().setPk_corp(voaClose[0].getPk_corp()) ;
	//V5 Del:
//	voOrder.getHeadVO().setCstoreorganization(voaClose[0].getPk_arrvstoorg()) ;
	voOrder.getHeadVO().setDorderdate(voaClose[0].getDorderdate()) ;
	voOrder.getHeadVO().setVordercode(voaClose[0].getVordercode()) ;
	voOrder.getHeadVO().setCbiztype(voaClose[0].getCbiztype()) ;

	voOrder.setChildrenVO(voaClose) ;

	return	voOrder ;
}

/**
 * 作者：WYF
 * 功能：得到按到货计划组成的ATP订单VO
 * 参数：OrderVO	voOrder				订单VO
 *		 OrderReceivePlanVO[]	voaPlan		到货计划VO数组
 * 返回：OrderVO	组织好的ATP订单VO
 * 例外：无
 * 日期：(2004-04-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public static	OrderVO	getAtpVOByRPVOs(OrderReceivePlanVO[]	voaRP){

	return	getAtpVOByRPVOs(null,voaRP) ;
}

/**
 * 作者：WYF
 * 功能：得到按到货计划组成的ATP订单VO
 * 参数：OrderVO	voOrder				订单VO
 *		 OrderReceivePlanVO[]	voaPlan		到货计划VO数组
 * 返回：OrderVO	组织好的ATP订单VO
 * 例外：无
 * 日期：(2004-04-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public static	OrderVO	getAtpVOByRPVOs(OrderVO	voOrder,OrderReceivePlanVO[]	voaRP){

	if (voaRP==null) {
		return	null ;
	}

	//按到货计划组织新表体VO
	int		iAtpLen = voaRP.length ;
//	OrderItemVO		voFindItem = null ;
	OrderItemVO[]	voaItem = new	OrderItemVO[iAtpLen] ;
	for (int i = 0; i < iAtpLen; i++){
		voaItem[i] = OrderItemVO.getAtpBodyVOByRPVO(voaRP[i]) ;
	}

	//设置新订单VO
	OrderVO			voAtpOrder = new	OrderVO() ;
	if (voOrder!=null) {
		voAtpOrder.setParentVO( voOrder.getHeadVO() ) ;
	}else{
		voAtpOrder.getHeadVO().setCorderid(voaRP[0].getCorderid()) ;
		voAtpOrder.getHeadVO().setPk_corp(voaRP[0].getPk_corp()) ;
		//V5 Del:
//		voAtpOrder.getHeadVO().setCstoreorganization(voaRP[0].getCstoreorganization()) ;
		voAtpOrder.getHeadVO().setDorderdate(voaRP[0].getDplanarrvdate()) ;
		voAtpOrder.getHeadVO().setCbiztype(voaRP[0].getCbiztype());
	}
	voAtpOrder.setChildrenVO( voaItem ) ;

	return	voAtpOrder ;
}

	public OrderItemVO[] getBodyVO(){
		return m_voaChildren;
	}

/**
 * 作者：WYF
 * 功能：根据订单行ID得到OrderItemVO
 * 参数：无
 * 返回：OrderItemVO[]相应的订单体
 * 例外：无
 * 日期：(2004-02-17 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderItemVO getBodyVOByBId(String sBId) {

	sBId = PuPubVO.getString_TrimZeroLenAsNull(sBId);
	if (sBId == null || getBodyVO() == null) {
		return null;
	}
	return	getBodyVOsByBIds(new	String[]{sBId})[0] ;
}

/**
 * 作者：WYF
 * 功能：根据订单行I	D数组	得到		OrderItemVO[]
 * 参数：String[] saBId		行ID数组
 * 返回：OrderItemVO[]相应的订单体数组
 * 例外：无
 * 日期：(2004-02-17 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderItemVO[] getBodyVOsByBIds(String[] saBId) {

	if (saBId == null || getBodyVO() == null) {
		return null;
	}

	HashMap	hmapIdAndVO = new	HashMap() ;
	int			iLen = getBodyVO().length ;
	for (int i = 0; i < iLen; i++){
		hmapIdAndVO.put(getBodyVO()[i].getCorder_bid(),getBodyVO()[i]) ;
	}

	iLen = saBId.length ;
	OrderItemVO[]	voaItem = new	OrderItemVO[iLen] ;
	for (int i = 0; i < iLen; i++){
		voaItem[i] = (OrderItemVO)hmapIdAndVO.get(saBId[i]) ;
	}

	return	voaItem ;
}

/**
 * 作者：WYF
 * 功能：根据订单行号数组	得到		OrderItemVO[]
 * 参数：String[] saRowNo		行号数组
 * 返回：OrderItemVO[]相应的订单体数组
 * 例外：无
 * 日期：(2004-02-17 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderItemVO[] getBodyVOsByRowNos(String[] saRowNo) {

	if (saRowNo == null || getBodyVO() == null) {
		return null;
	}

	HashMap	hmapRowNoAndVO = new	HashMap() ;
	int			iLen = getBodyVO().length ;
	for (int i = 0; i < iLen; i++){
		hmapRowNoAndVO.put(getBodyVO()[i].getCrowno(),getBodyVO()[i]) ;
	}

	iLen = saRowNo.length ;
	OrderItemVO[]	voaItem = new	OrderItemVO[iLen] ;
	for (int i = 0; i < iLen; i++){
		voaItem[i] = (OrderItemVO)hmapRowNoAndVO.get(saRowNo[i]) ;
	}

	return	voaItem ;
}

/**
 * 作者：王印芬
 * 功能：返回界面上的VO，主要用于如各项检查(如空、最高限价等)，滤掉了DELETE的行及历史行
 * 参数：
 * 返回：OrderVO		界面上的VO
 * 例外：无
 * 日期：(2003-06-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderVO	getCheckVO(){

	//界面VO，真正作检查(如空、最高限价等)的行
	OrderItemVO[]	voaCheckItem = null ;
	//所有VO，包括删除的及历史行
	OrderItemVO[]	voaAllItem = getBodyVO() ;
	if (voaAllItem!=null) {
		Vector	vecCheckBody = new	Vector() ;
		int		iTotalLen = voaAllItem.length ;
		for (int i = 0; i < iTotalLen; i++){
			//已删除的行及历史行不作检查
			if ( voaAllItem[i].getStatus()!=VOStatus.DELETED &&
				 !voaAllItem[i].isRevised() ) {
				vecCheckBody.addElement(voaAllItem[i]) ;
			}
		}

		int		iCheckLen = vecCheckBody.size() ;
		if (iCheckLen!=0) {
			voaCheckItem = new	OrderItemVO[iCheckLen] ;
			vecCheckBody.copyInto(voaCheckItem) ;
		}
	}

	OrderVO	voCheck = (OrderVO)clone() ;
	voCheck.setChildrenVO(voaCheckItem) ;

	return	voCheck ;
}

/**
 * 作者：WYF
 * 功能：得到关闭的表体行
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 * 参数：无
 * 返回：int		关闭的表体行数
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public int	getClosedBodyNum(){

	 int	iOpenLen = 0 ;//未关闭的行
	 int	iBodyLen = getBodyVO().length ;
	 for (int i = 0; i < iBodyLen; i++){
	 	if ( getBodyVO()[i].isActive() ) {
	 		iOpenLen++ ;
	 	}
	 }

	 //总行数－未关闭的行
	 return	iBodyLen-iOpenLen ;
}

/**
 * 作者：WYF
 * 功能：得到确认的表体行
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 * 参数：无
 * 返回：int		确认的表体行数
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public int	getConfirmedBodyNum(){

	 int	iConfirmedLen = 0 ;//确认的行
	 int	iBodyLen = getBodyVO().length ;
	 for (int i = 0; i < iBodyLen; i++){
	 	if ( getBodyVO()[i].getForderrowstatus().compareTo(OrderItemVO.FORDERROWSTATUS_CONFIRM)==0 ) {
	 		iConfirmedLen++ ;
	 	}
	 }

	 //确认的行
	 return	iConfirmedLen ;
}


	public OrderHeaderVO getHeadVO(){
		return m_voParent;
	}

/**
 * 作者：WYF
 * 功能：获取历史VO，用于修订中对历史记录的保存
 * 参数：String	sCorrectUserId			修正人ID，即当前登录的用户ID
 * 返回：OrderVO		用于作为历史的VO
 * 例外：无
 * 日期：(2003-9-9 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderVO getHistoryVO(String	sCorrectUserId) {

	//历史VO
	OrderVO		voHistory = (OrderVO)this.clone() ;

	//总体
	voHistory.setStatus(VOStatus.NEW) ;
	//头
	OrderHeaderVO	voHead = voHistory.getHeadVO() ;
	voHead.setStatus(VOStatus.NEW) ;

	voHead.setCorderid(null) ;
	voHead.setBislatest(OrderHeaderVO.BISLATEST_NO) ;
	String strTemp = null;
	voHead.setTs(strTemp) ;
	//体
	OrderItemVO[]	voaItem = voHistory.getBodyVO() ;
	int		iBodyLen = voaItem.length ;
	for (int i = 0; i < iBodyLen; i++){
		voaItem[i].setStatus(VOStatus.NEW) ;

		voaItem[i].setCorder_bid(null) ;
		voaItem[i].setCorderid(null) ;

		voaItem[i].setDcorrectdate(this.getHeadVO().getDrevisiondate());
		voaItem[i].setCcorrectrowid(this.getBodyVO()[i].getCorder_bid());
		voaItem[i].setCoperator(sCorrectUserId);

		voaItem[i].setIisactive(OrderItemVO.IISACTIVE_REVISION);

		voaItem[i].setTs(null) ;
	}

	return	voHistory;
}

/**
 * 作者：WYF
 * 功能：接口nc.vo.scm.pub.IVendorInfo的函数
 * 参数：无
 * 返回：供应商KEY
 * 例外：无
 * 日期：(2004-07-26 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public	String getKey(){
	return	"cvendormangid" ;
}

/**
 * 作者：王印芬
 * 功能：返回最高库存检查的VO，主要适用于最高库存检查时，只对正数量的行进行检查
 * 参数：
 * 返回：OrderVO		最高库存检查VO
 *						如果没有，返回NULL
 * 例外：无
 * 日期：(2003-11-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderVO	getMaxStockCheckVO(){

	OrderVO			voCheck = getCheckVO() ;
	if (voCheck==null) {
		return	null ;
	}

	Vector			vecAtp = new	Vector() ;
	OrderItemVO[]	voaItem = voCheck.getBodyVO() ;
	int				iLen = voaItem.length ;
	for (int i = 0; i < iLen; i++){
		if ( PuPubVO.getUFDouble_NullAsZero(voaItem[i].getNordernum()).compareTo(VariableConst.ZERO)>0 ) {
			vecAtp.add( voaItem[i] ) ;
		}
	}
	int				iAtpLen = vecAtp.size() ;
	if (iAtpLen==0) {
		return	null ;
	}

	OrderVO		voAtp = (OrderVO)voCheck.clone() ;
	voAtp.setChildrenVO( (OrderItemVO[])(vecAtp.toArray(new	OrderItemVO[iAtpLen])) ) ;
	return		voAtp ;

}

/**
 * 作者：王印芬
 * 功能：设置到货计划VO数组
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderReceivePlanVO[]	getOldRPVOs(){

	return	m_voaOldRP ;
}

/**
 * 作者：王印芬
 * 功能：得到此次操作前（如保存前）的旧VO
 * 参数：
 * 返回：OrderVO		界面上的VO
 * 例外：无
 * 日期：(2004-03-11 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderVO	getOldVO(){

	return	m_voOld ;
}

/**
 * 返回登陆公司与单据公司业务类型对应的业务类型
 * 参数：
 * 返回：
 * 例外：
 * 日期：(2002-12-3 16:24:12)
 * 作者：李金巧
 * 修改日期，修改人，修改原因，注释标志：
 * @return java.lang.String
 */
public String getPkBusinessType() {
	return m_busitype;
}

/**
 * 作者：WYF
 * 功能：接口nc.vo.scm.pub.IVendorInfo的函数
 * 参数：无
 * 返回：供应商KEY
 * 例外：无
 * 日期：(2004-07-26 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public	Integer getPos(){
	return	VariableConst.ZERO_INTEGER ;
}

/**
 * 作者：王印芬
 * 功能：设置到货计划VO数组
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public OrderReceivePlanVO[]	getRPVOs(){

	return	m_voaRP ;
}

/**
 * 作者：王印芬
 * 功能：该单据是否所有表体均为激活状态
 * 参数：无
 * 返回：boolean		是true,否false
 * 例外：无
 * 日期：(2003-09-18 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean isActive(){
	if (getBodyVO()==null) {
		return	false ;
	}

	int		iBodyLen = getBodyVO().length ;
	for (int i = 0; i < iBodyLen; i++){
		if ( !getBodyVO()[i].isActive() ) {
			return	false ;
		}
	}

	return	true ;
}

/**
 * 功能描述：是否表体已经过转单处理
 * 输入参数：无
 * 返回值：　boolean		已处理true；否则返回false
 * 异常处理：无
 * 作者：王印芬
 * 日期：2003-11-27
*/
public boolean isBodyChanged() {
	return m_bBodyChanged;
}

/**
 * 作者：WYF
 * 功能：判断该单据是否可被作废
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 * 参数：无
 * 返回：boolean	true为可修改，false不可修改
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	isCanBeAnnuled(){

    Integer iBillStatus = getHeadVO().getForderstatus() ;
    //自由,审批未通过
    if ( BillStatus.FREE.compareTo(iBillStatus)==0  ||
       BillStatus.AUDITFAIL.compareTo(iBillStatus)==0 ) {
      return  true ;
    }
    return  false ;
}

/**
 * 作者：WYF
 * 功能：判断该单据是否可被审批
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 * 参数：无
 * 返回：boolean	true为可修改，false不可修改
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	isCanBeAudited(){

	Integer iBillStatus = getHeadVO().getForderstatus() ;
	//自由,审批未通过，正在审批
	if ( BillStatus.FREE.compareTo(iBillStatus)==0 ||
		 //BillStatus.AUDITFAIL.compareTo(iBillStatus)==0 ||
		 BillStatus.AUDITING.compareTo(iBillStatus)==0 ) {
		return	true ;
	}
	return	false ;

}
/**
 * 作者：WYF
 * 功能：判断该单据是否可被解冻
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 * 参数：无
 * 返回：boolean	true为可修改，false不可修改
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	 isCanBeUnFreezed(){

	Integer iBillStatus = getHeadVO().getForderstatus() ;
	//自由,审批未通过，正在审批
	if ( BillStatus.FREEZE.compareTo(iBillStatus)==0 ) {
		return	true ;
	}
	return	false ;

}

/**
 * 作者：WYF
 * 功能：判断该单据是否可被关闭
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 * 参数：无
 * 返回：boolean	true为可修改，false不可修改
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	isCanBeClosed(){

	Integer iBillStatus = getHeadVO().getForderstatus() ;
	if ( BillStatus.FREE.compareTo(iBillStatus)==0 ||
		 BillStatus.AUDITFAIL.compareTo(iBillStatus)==0 ||
		 BillStatus.AUDITING.compareTo(iBillStatus)==0 ||
		 BillStatus.FREEZE.compareTo(iBillStatus)==0){
		return	false ;
	}else{
		//所有的行均已关闭
		if (getClosedBodyNum()==getBodyVO().length) {
			return	false ;
		}
		return	true ;
	}
}

/**
 * 作者：WYF
 * 功能：判断该单据是否可被修改
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 * 参数：无
 * 返回：boolean	true为可修改，false不可修改
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	isCanBeModified(){

	Integer iBillStatus = getHeadVO().getForderstatus() ;
	//自由,审批未通过
	if ( BillStatus.FREE.compareTo(iBillStatus)==0	||
		 BillStatus.AUDITFAIL.compareTo(iBillStatus)==0 ||
		 (BillStatus.AUDITING.compareTo(iBillStatus)==0 
		         && PuPubVO.getString_TrimZeroLenAsNull(getHeadVO().getCauditpsn()) == null)) {
		return	true ;
	}
	return	false ;
}

/**
 * 作者：WYF
 * 功能：判断该单据是否可被打开
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 * 参数：无
 * 返回：boolean	true为可修改，false不可修改
 * 例外：无
 * 日期：(2004-04-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	isCanBeOpened(){

	Integer iBillStatus = getHeadVO().getForderstatus() ;
	if ( BillStatus.FREE.compareTo(iBillStatus)==0 ||
		 BillStatus.AUDITFAIL.compareTo(iBillStatus)==0 ||
		 BillStatus.AUDITING.compareTo(iBillStatus)==0 ||
		 BillStatus.FREEZE.compareTo(iBillStatus)==0){
		return	false ;
	}else{
		//所有的行均已打开
		if (getClosedBodyNum()==0) {
			return	false ;
		}
		return	true ;
	}
}

/**
 * 作者：WYF
 * 功能：判断该单据是否可被弃审
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 * 参数：无
 * 返回：boolean	true为可修改，false不可修改
 * 例外：无
 * 日期：(2003-12-24 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	isCanBeUnAudited(){

	Integer iBillStatus = getHeadVO().getForderstatus() ;
	//自由、审批未通过、输出、冻结
	if ( nc.vo.scm.pu.BillStatus.FREE.compareTo(iBillStatus)==0 ||
		 nc.vo.scm.pu.BillStatus.AUDITFAIL.compareTo(iBillStatus)==0 ||
		 nc.vo.scm.pu.BillStatus.FREEZE.compareTo(iBillStatus)==0 ||
		 nc.vo.scm.pu.BillStatus.OUTPUT.compareTo(iBillStatus)==0 ){
		return	false ;
	}//存在关闭、确认、到货、入库、发票的行
	else	if ( getClosedBodyNum()>0 || getConfirmedBodyNum()>0 ){
		return	false ;
	}
	//v50,补充处理(针对用户未钩选“关闭”，即界面数据不完整的情况)
	else if(isExistClosed()){
		return false;
	}
//	//已修订的单据不可弃审
//	else	if( OrderHeaderVO.NVERSION_FIRST.compareTo(
//		PuPubVO.getInteger_NullAs(getHeadVO().getNversion(),OrderHeaderVO.NVERSION_FIRST))!=0) {
//			return	false ;
//	}
	//审批进行中，但没有记录审批人时，不可以弃审
  else if(BillStatus.AUDITING.compareTo(iBillStatus)==0 
      && getHeadVO() != null && PuPubVO.getString_TrimZeroLenAsNull(getHeadVO().getCauditpsn()) == null){
    return false;
  }
  //
	return	true ;
}

/**
 * 作者：CZP
 * 功能：判断该单据是否能生成发运日计划(包含两种状态订单：审批、确认)
 *			首先该订单保证是一张正确的订单，即不应出现DR!=0的情况
 *			限于对UI端的按钮控制的判断
 *			另外，此条件只是订单可生成日计划的必要而非充分条件
 * 参数：无
 * 返回：boolean	true 可以生成日计划(必要条件)，false 不可以生成日计划
 * 例外：无
 * 日期：(2004-12-09 09:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	 isCanDayPl(){

	Integer iBillStatus = getHeadVO() == null ? null : getHeadVO().getForderstatus() ;
	//审批通过、确认
	if (iBillStatus != null &&
	        (BillStatus.AUDITED.compareTo(iBillStatus)==0 ||
		 BillStatus.OUTPUT.compareTo(iBillStatus)==0) ) {
		return	true ;
	}
	return	false ;

}

/**
 * 作者：晁志平
 * 功能：是否发运
 * 参数：无
 * 返回：boolean
 * 例外：无
 * 日期：(2004-11-10 15:30:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean isDeliver() {
	if (getHeadVO() == null) {
		return false;
	}
	return getHeadVO().isDeliver();
}

/**
 * 功能描述：是否第一次
 *		用于与合同参数“是否对订单进行严格控制”配合。
 *		用户从UI不是第一次传递该VO时，该值为false，表明合同可以继续保存
 * 输入参数：无
 * 返回值：　boolean		第一次返回true；否则返回false
 * 异常处理：无
 * 作者：王印芬
 * 日期：2003-06-16
 */
public boolean isFirstTime() {
	return m_bFirstTime;
}

/**
 * 功能描述：是否第一次
 *		用于订单行超现存量检查
 *		用户从UI不是第一次传递该VO时，该值为false，表明可以继续保存
 * 输入参数：无
 * 返回值：　boolean		第一次返回true；否则返回false
 * 异常处理：无
 * 作者：王印芬
 * 日期：2003-06-16
 */
public boolean isFirstTimeSP() {
	return m_bFirstTimeSP;
}

/**
 * 作者：WYF
 * 功能：判断该单据是否所有表体行均来自同一个合同单据
 *			主要用于：订单弃审时清空预付款；与预付款相关内容
 * 参数：无
 * 返回：boolean	true来自同一张合同，false不是
 * 例外：无
 * 日期：(2003-09-05 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean	isFrmOneContract(){

	//只对界面上的VO进行检查
	OrderVO		voShow = getCheckVO() ;

	String		sOldCntId = PuPubVO.getString_TrimZeroLenAsNull(
		voShow.getBodyVO()[0].getCcontractid() ) ;
	if (sOldCntId==null) {
		return	false ;
	}
	String		sCurCntId = null ;

	int		iBodyLen = voShow.getBodyVO().length ;
	for (int i = 1; i < iBodyLen; i++){
		sCurCntId = PuPubVO.getString_TrimZeroLenAsNull(
					voShow.getBodyVO()[i].getCcontractid() );
		if ( sCurCntId==null || !sCurCntId.equals(sOldCntId)) {
			return	false ;
		}
		sOldCntId = sCurCntId ;
	}
	return	true ;
}

/**
 * 功能：判断当前行是否劳务折扣属性
 * 参数：订单行VO
 * 返回：存货为劳务折扣则返回 true 否则 false [注意:基础数据值为空时返回处理为 false]
 * 创建：2004-11-04
 * 异常：ValidationException
 * 作者：晁志平
 */
private boolean isLaborDiscount(OrderItemVO item) throws ValidationException {
  boolean bIsUI = nc.vo.bd.access.Env.isUICall();
	if (hashLaborFlag == null) {
		hashLaborFlag = new Hashtable();
		hashDiscountFlag = new Hashtable();
		OrderItemVO[] allCheckingItems = getCheckVO().getBodyVO();
		if (allCheckingItems != null && allCheckingItems.length > 0) {
			int iLen = allCheckingItems.length;
			ArrayList aryDisBaseId = new ArrayList();
			String strTemp = null;
			for (int i = 0; i < iLen; i++) {
				strTemp = allCheckingItems[i].getCbaseid();
				if (strTemp == null || strTemp.trim().equals("") || aryDisBaseId.contains(strTemp)) {
					continue;
				}
				aryDisBaseId.add(strTemp);
			}
			if (aryDisBaseId.size() > 0) {
				iLen = aryDisBaseId.size();
				String[] saBaseId = (String[]) aryDisBaseId.toArray(new String[iLen]);
		    // 是否在前台调用，如果用类变量，必须是静态的，多个代码（前后台都有）同时初始化这个类时会有问题
		    Object[][] objs = null;
		    if(bIsUI){
		      objs = CacheTool.getMultiColValue("bd_invbasdoc",
		          "pk_invbasdoc", 
		          new String[] { "laborflag", "discountflag" },
		          saBaseId);
		    }else{
  				try{
  					objs =
  						ChgDataUtil.getMultiColValue2(
  							"bd_invbasdoc",
  							"pk_invbasdoc",
  							null,
  							null,
  							new String[] { "laborflag", "discountflag" },
  							saBaseId,
  							null,
  							null);
  					if (objs != null && objs.length == iLen) {
  						for (int i = 0; i < iLen; i++) {
  							hashLaborFlag.put(saBaseId[i], objs[i][0]);
  							hashDiscountFlag.put(saBaseId[i], objs[i][1]);
  						}
  					}
  				}catch(BusinessException be){
  					throw new ValidationException(be.getMessage());
  				}
		    }
			}
		}
	}
	String strBaseId = item.getCbaseid();
	if (strBaseId == null || strBaseId.trim().equals("")) {
		SCMEnv.out("程序BUG，未获取采购订单表体存货的基本档案ID");
		return false;
	}
	if (!hashLaborFlag.containsKey(strBaseId)) {
	  Object[][] objs = null;
	  if(bIsUI){
	    objs = CacheTool.getMultiColValue("bd_invbasdoc",
	        "pk_invbasdoc", 
	        new String[] { "laborflag", "discountflag" },
	        new String[] { strBaseId });
	  }else{
	    try{
	      objs = ChgDataUtil.getMultiColValue2(
					"bd_invbasdoc",
					"pk_invbasdoc",
					null,
					null,
					new String[] { "laborflag", "discountflag" },
					new String[] { strBaseId },
					null,
					null);
	    }catch (BusinessException e) {
	      throw new ValidationException(e.getMessage());
      }
	  }
	  if (objs != null && objs.length == 1) {
	    hashLaborFlag.put(strBaseId, objs[0][0]);
	    hashDiscountFlag.put(strBaseId, objs[0][1]);
	  }
	}
	if (!hashLaborFlag.containsKey(strBaseId)) {
		SCMEnv.out("程序BUG或基础数据错误，未获取采购订单表体存货的劳务折属性值");
		return false;
	}
	boolean bLab = PuPubVO.getUFBoolean_NullAs(hashLaborFlag.get(strBaseId), new UFBoolean(false)).booleanValue();
	boolean bDis = PuPubVO.getUFBoolean_NullAs(hashDiscountFlag.get(strBaseId), new UFBoolean(false)).booleanValue();
	//
	return bLab || bDis;
}

/**
 * 作者：王印芬
 * 功能：是否一张新的单据，指其STATUS标志
 * 参数：无
 * 返回：boolean		新单据返回true,否则返回false
 * 例外：无
 * 日期：(2003-06-02 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean isNew(){
	return	getStatus()==VOStatus.NEW ? true : false ;
}

/**
 * 作者：晁志平
 * 功能：是否退货
 * 参数：无
 * 返回：boolean
 * 例外：无
 * 日期：(2004-11-10 15:30:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean isReturn() {
	if (getHeadVO() == null) {
		return false;
	}
	return getHeadVO().isReturn();
}
/**
 * 是否补货订单
 */
public boolean isReplenish() {
	if (getHeadVO() == null || getHeadVO().getBisreplenish() == null) {
		return false;
	}
	return getHeadVO().getBisreplenish().booleanValue();
}
/**
 * 功能描述：设置是否表体已经过转单处理
 * 输入参数：boolean		已处理true；否则返回false
 * 返回值：　无
 * 异常处理：无
 * 作者：王印芬
 * 日期：2003-11-27
*/
public void setBodyChanged(boolean	bValue) {
	m_bBodyChanged = bValue;
}

/**
 * 功能描述：设置是否第一次
 * 输入参数：boolean	bFirstTime	是否第一次
 * 返回值：　无
 * 异常处理：无
 * 作者：王印芬
 * 日期：2003-06-16
 */
public void setFirstTime(boolean	bFirstTime) {
	m_bFirstTime = bFirstTime;
}

/**
 * 功能描述：设置是否第一次
 * 输入参数：boolean	bFirstTime片片	是否第一次
 * 返回值：　无
 * 异常处理：无
 * 作者：王印芬
 * 日期：2003-06-16
 */
public void setFirstTimeSP(boolean	bFirstTime) {
	m_bFirstTimeSP = bFirstTime;
}

/**
 * 返回制单人公司
 * 参数：
 * 返回：
 * 例外：
 * 日期：(2002-12-3 16:24:12)
 * 作者：李金巧
 * 修改日期，修改人，修改原因，注释标志：
 * @return java.lang.String
 */
public void setGroupPkCorp(String pk_corp) {
	m_grourPkCorp = pk_corp;
}

/**
 * 作者：王印芬
 * 功能：设置到货计划VO数组
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public void	setOldRPVOs(OrderReceivePlanVO[]	voaOldRP){

	m_voaOldRP = voaOldRP;
}

/**
 * 作者：王印芬
 * 功能：设置此次操作前（如保存前）的旧VO
 * 参数：
 * 返回：OrderVO		界面上的VO
 * 例外：无
 * 日期：(2004-03-11 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public void	setOldVO(OrderVO	voOld){

	m_voOld = voOld;
}

/**
 * 返回制单人公司
 * 参数：
 * 返回：
 * 例外：
 * 日期：(2002-12-3 16:24:12)
 * 作者：李金巧
 * 修改日期，修改人，修改原因，注释标志：
 * @return java.lang.String
 */
public void setPkBusinessType(String busitype) {
	m_busitype = busitype;
}

/**
 * 作者：王印芬
 * 功能：设置到货计划VO数组
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-13 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public void	setRPVOs(OrderReceivePlanVO[]	voaRP){

	m_voaRP = voaRP;
}

/**
 * 作者：WYF
 * 功能：对一组订单VO数组，按到货计划拆单后返回
 *			调用此函数前，订单ITEM中必须有到货计划数组
 * 参数：
 *		int		iAfterBillStatus	OrderstatusVO中的静态变量，该参数决定是查询什么数量
 * 									STATUS_ARRIVE、STATUS_STORE、STATUS_BACK_RC、STATUS_BACK_IC
 *									分别对应：可(到货、入库、退货、退库)数量
 *		OrderVO[]	voaOrder			订单VO数组
 * 返回：无
 * 例外：无
 * 日期：(2004-03-03 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public static	void splitOrderVOByRPVOs(
	int			iAfterBillStatus,
	OrderVO[]	voaOrder) {

	if (voaOrder == null) {
		return ;
	}

	int		iLen = voaOrder.length ;
	for (int i = 0; i < iLen; i++){

		//表体所有到货计划
		Vector	vecItem = new	Vector() ;

		OrderItemVO[]		voaItem = voaOrder[i].getBodyVO() ;
		//V5 Del:
//		String	sStoOrgId = voaOrder[i].getHeadVO().getCstoreorganization() ;
		String	sStoOrgId = null;
		if (voaItem!=null) {
			int		iBodyLen = voaItem.length ;
			boolean bRight = true;
			for (int j = 0; j < iBodyLen; j++){
				bRight = (voaItem[j].getRPVOs() == null?false:true);
				//按到货计划分解订单行
				OrderItemVO[]		voaPlanItem =
					voaItem[j].getBodyVOsByRPVOs(iAfterBillStatus,voaItem[j].getRPVOs()) ;
				sStoOrgId = voaItem[j].getPk_arrvstoorg();
				//加入到所有ITEM中
				int		iPlanBodyLen = voaPlanItem.length ;
				for (int	iPlan=0;iPlan<iPlanBodyLen;iPlan++) {
					if ( PuPubVO.getString_TrimZeroLenAsNull(voaPlanItem[iPlan].getPk_arrvstoorg())==null ) {
						voaPlanItem[iPlan].setPk_arrvstoorg( sStoOrgId ) ;
					}
					vecItem.add(voaPlanItem[iPlan]) ;
					if(bRight)
					calInitRelations(voaPlanItem[iPlan]);
				}
			}
		}
		voaOrder[i].setChildrenVO( (OrderItemVO[])vecItem.toArray(new	OrderItemVO[vecItem.size()]) ) ;
	}

	return ;
}

/**
 *请不要调用此方法，请使用方法validate(PoSaveCheckParaVO)
 *
 * 创建日期：(2001-5-18)
 * @exception nc.vo.pub.ValidationException 如果验证失败，抛出
 *     ValidationException，对错误进行解释。
 */
public void validate() throws ValidationException {
}

/**
 * 验证对象各属性之间的数据逻辑正确性。
 *
 * 创建日期：(2001-5-18)
 * @exception nc.vo.pub.ValidationException 如果验证失败，抛出
 *     ValidationException，对错误进行解释。
 */
public void validate(PoSaveCheckParaVO	voPara) throws ValidationException {

	//只对界面上的VO进行检查
	OrderVO		voShow = getCheckVO() ;

	OrderHeaderVO	voShowHead = voShow.getHeadVO() ;
	OrderItemVO[]	voaShowItem = voShow.getBodyVO() ;

	//有无表体
	if (voaShowItem==null || voaShowItem.length==0) {
		throw	new	ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000174")/*@res "请输入订单明细"*/) ;
	}
	//本次修订日期不能小于上次修订日期检查
	validateLastReviseDate();
	//表头检查
	voShowHead.validate();

	//行号检查
	BillRowNoVO.validateRowNo(voaShowItem,"crowno") ;

	//表体例行检查
	int		iUIBodyLen = voaShowItem.length ;
//	for (int i = 0; i < iUIBodyLen; i++){
//
//		if (voaShowItem[i] == null){
//			continue;
//		}
//
//		//例行检查
//		voaShowItem[i].validate();
//
//		//订单数量正负检查：劳务折扣除外
//		if (!isLaborDiscount(voaShowItem[i])){
//			//补货订单不能输入负数
//			if (voShow.getHeadVO().getBisreplenish() != null && voShow.getHeadVO().getBisreplenish().booleanValue()) {
//				if ( PuPubVO.getUFDouble_NullAsZero( voaShowItem[i].getNordernum() ).compareTo(VariableConst.ZERO)<0 ) {
//					throw	new	ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000175",null,new String[]{voaShowItem[i].getCrowno()})/*@res "表体：行号{0}：补货订单数量不能为负"*/) ;
//				}
//			}
//			//退货订单正负数
//			if (voShow.getHeadVO().getBreturn() != null && voShow.getHeadVO().getBreturn().booleanValue()) {
//				if ( PuPubVO.getUFDouble_NullAsZero( voaShowItem[i].getNordernum() ).compareTo(VariableConst.ZERO)>0 ) {
//					throw	new	ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000176",null,new String[]{voaShowItem[i].getCrowno()})/*@res "表体：行号{0}：退货订单的存货（非劳务、折扣）数量应该输入负数"*/);
//				}
//			}else{
//				if ( PuPubVO.getUFDouble_NullAsZero( voaShowItem[i].getNordernum() ).compareTo(VariableConst.ZERO)<0 ) {
//					throw	new	ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000177",null,new String[]{voaShowItem[i].getCrowno()})/*@res "表体：行号{0}：：采购订单的存货(非劳务、折扣)数量应该输入正数"*/) ;
//				}
//			}
//		}
//	}


	// add by ouyangzhb 2012-02-11 俊杰业务，有可能在供应商发了货，货已经到了，才下订单，所以不需要有这个限制
//	//计划到货日期的检查
//	for (int i = 0; i < iUIBodyLen; i++){
//		UFDate	dPlanDate = voaShowItem[i].getDplanarrvdate() ;
//		if ( dPlanDate != null && !dPlanDate.toString().trim().equals("") ) {
//			//订单日期
//			if (dPlanDate.before(voShowHead.getDorderdate())) {
//				String sCurLine = nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000178",null,new String[]{voaShowItem[i].getCrowno(),dPlanDate.toString(),voShowHead.getDorderdate().toString()})/*@res "表体(行号 {0} )：计划到货日期{1}不能早于订单日期{2}"*/;
//				throw	new	ValidationException(sCurLine);
//			}
//		}
//	}
// add end 2012-02-11 
	

	//进行到货计划的检查
	validateRP() ;

	//表头本币预付款限额的检查
	validatePrePayLimit(voPara.iDigit_Curr_FinanceLocal) ;

	//修订检查：合同
	validateFrmOneCntWhenRevise() ;

	//进行最大最小值的判断
	FieldDBValidate.validate(this) ;
}
/**
 * 作者：晁志平
 * 功能：检查本次修订日期不能小于上次修订日期
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2005-08-24 14:56:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public void validateLastReviseDate() throws ValidationException {

	if(getOldVO() == null 
			|| getOldVO().getHeadVO() == null 
			|| getOldVO().getHeadVO().getDrevisiondate() == null
			|| getHeadVO() == null 
			|| getHeadVO().getDrevisiondate() == null){
		return;
	}
	UFDate ufdLastDate = getOldVO().getHeadVO().getDrevisiondate();
	UFDate ufdThisDate = this.getHeadVO().getDrevisiondate();
	if(ufdThisDate.compareTo(ufdLastDate) < 0){	
		throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004pub","UPP4004pub-000200")/*@res "“修订日期”不能早于上一次“修订日期”"*/);
	}
}
/**
 * 作者：王印芬
 * 功能：作废单据时调用此方法进行需作废的单据的检查
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-15 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public void validateDiscard() throws ValidationException {

	validateRP() ;
}

/**
 * 作者：王印芬
 * 功能：作废单据时调用此方法进行需作废的单据的检查
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-15 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public static	void validateDiscardVOs(OrderVO[]	voaOrder) throws ValidationException {

	if (voaOrder==null) {
		return ;
	}

	int	iLen = voaOrder.length ;
	for (int i = 0; i < iLen; i++){
		voaOrder[i].validateRP() ;
	}

}

/**
 * 作者：王印芬
 * 功能：修订时对来自合同的预付款的检查：
		修订前单据来自同一个合同，则不能将订单改为来自多个合同的订单
 * 参数：无
 * 返回：无
 * 例外：无
 * 日期：(2004-06-08 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
private void validateFrmOneCntWhenRevise() throws ValidationException {

	//不是修订时不进行检查
	if (OrderHeaderVO.NVERSION_FIRST.equals(getHeadVO().getNversion())) {
		return;
	}

	//新旧合同是否来自同一个订单
	String sOldCntId = null;
	if ((getOldVO().isFrmOneContract()
		&& PuPubVO.getUFDouble_ZeroAsNull(getOldVO().getHeadVO().getNprepaymny()) != null)) {

		sOldCntId = getOldVO().getBodyVO()[0].getCcontractid();

		//新订单不来自同一个合同或来自其他合同
		boolean		bException = false ;
		if (!isFrmOneContract()) {
	        bException = true ;
		}else{
			String	sNewCntId = getCheckVO().getBodyVO()[0].getCcontractid() ;
			if ( !PuPubVO.isEqual( sNewCntId,sOldCntId) ){
				bException = true ;
			}
		}

		//提示
		if (bException) {
			throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000179",null,new String[]{getHeadVO().getVordercode()})/*@res "订单{0}：原订单来自同一张合同且已由合同分配预付款，不能修订为无合同或非一张合同的订单"*/);
		}
	}
}

/**
 * 作者：王印芬
 * 功能：进行预付款限额的检查
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-29 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
public void validatePrePayLimit(int		iFinanceLoaclDigit) throws ValidationException {

	OrderVO	voCheck = getCheckVO() ;
	if (voCheck==null) {
		return;
	}

	//未输入时不进行检查
	if (voCheck.getHeadVO().getNprepaymaxmny() == null) {
		return;
	}

	int iBodyLen = voCheck.getBodyVO().length;
	UFDouble dSum = VariableConst.ZERO;
	for (int i = 0; i < iBodyLen; i++) {
		//存在进行如下检查
		dSum = dSum.add(PuPubVO.getUFDouble_NullAsZero(voCheck.getBodyVO()[i].getNtaxpricemny()));
	}
	//与财务精度保持一致
	dSum = dSum.setScale(iFinanceLoaclDigit,UFDouble.ROUND_HALF_UP) ;

	if (voCheck.getHeadVO().getNprepaymaxmny().compareTo(dSum) > 0) {
		throw new ValidationException(
			nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000180",null,new String[]{voCheck.getHeadVO().getNprepaymaxmny() +"",dSum+""})/*@res "表头：本币预付款限额{0}超出订单本币价格合计总额{1}，请修改"*/ );
	}
}

/**
 * 作者：王印芬
 * 功能：进行到货计划的检查
 * 参数：
 * 返回：无
 * 例外：无
 * 日期：(2004-04-15 11:39:21)
 * 修改日期，修改人，修改原因，注释标志：
 */
private void validateRP() throws ValidationException {

	if (getBodyVO() == null) {
		return;
	}

	if (getHeadVO().getCorderid() == null) {
		return;
	}

	String sOrderCode = getHeadVO().getVordercode();
	//某BID的旧ITEMVO
	OrderItemVO voOldItem = null;
	int iBodyLen = getBodyVO().length;
	for (int i = 0; i < iBodyLen; i++) {
		//存在到货计划时进行如下检查
		if (getBodyVO()[i].getStatus() == VOStatus.NEW || !getBodyVO()[i].isHaveRP()) {
			continue;
		}

		String sRowNo = getBodyVO()[i].getCrowno();
		//单据被删除
		if (getStatus() == VOStatus.DELETED ){
			throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000181",null,new String[]{sOrderCode})/*@res "订单{0}：存在到货计划，不能删除，请检查"*/);
		}
		//行被删除
		if ( getBodyVO()[i].getStatus() == VOStatus.DELETED) {
			throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000182",null,new String[]{sOrderCode,sRowNo})/*@res "订单{0}行号{1}：存在到货计划，不能删除，请检查"*/);
		}
		//存货被修改
		//辅计量被修改
		if (getOldVO() != null) {
			voOldItem = getOldVO().getBodyVOByBId(getBodyVO()[i].getCorder_bid());
			if (voOldItem != null && !voOldItem.getCmangid().equals(getBodyVO()[i].getCmangid())) {
				throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000183",null,new String[]{sOrderCode,sRowNo})/*@res "订单{0}行号{1}：存在到货计划，不能修改存货，请检查"*/);
			}
			if (voOldItem != null && !PuPubVO.isEqual(voOldItem.getCassistunit(),getBodyVO()[i].getCassistunit())) {
				throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000184",null,new String[]{sOrderCode,sRowNo})/*@res "订单{0}行号{1}：存在到货计划，不能修改辅计量，请检查"*/);
			}
		}
		//负数量
		if (PuPubVO.getUFDouble_NullAsZero(getBodyVO()[i].getNordernum()).compareTo(VariableConst.ZERO) < 0) {

			throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000185",null,new String[]{sOrderCode,sRowNo})/*@res "订单{0}行号{1}：数量为负，但存在到货计划，请检查"*/);
		}
		//到货计划数量＞订单数量
		if (PuPubVO.getUFDouble_NullAsZero(getBodyVO()[i].getNaccumrpnum()).compareTo(
	        	PuPubVO.getUFDouble_NullAsZero(getBodyVO()[i].getNordernum())) > 0) {
			throw new ValidationException(nc.vo.ml.NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPP4004020201-000186",null,new String[]{sOrderCode,sRowNo,getBodyVO()[i].getNordernum()+"",getBodyVO()[i].getNaccumrpnum()+""})/*@res "订单{0}行号{1}：订单数量{2}小于到货计划数量{3}，请检查"*/);
		}
	}
}
/**
 * 作者：晁志平
 * 功能：刷新订单VO,本方法处理：新增、修改两种情况
 * 参数：OrderVO voLight 存放最新数据的轻量VO
 * 返回：boolean 如果刷新成功返回true，否则返回false
 * 例外：无
 * 日期：2005-06-16 10:43:16
 * 修改日期，修改人，修改原因，注释标志：
 */
public boolean setLastestVo(OrderVO voLight, int iCurOperType){
    
    if(voLight == null || voLight.getHeadVO() == null && voLight.getBodyVO() == null){
        SCMEnv.out("刷新回来的VO或其表头或其表体存在空，刷新失败!");
        return false;
    }
    
    OrderItemVO[] itemsDst = getBodyVO();
    OrderItemVO[] itemsLight = voLight.getBodyVO();
    int iLenDst = itemsDst.length;
    int iLenLight = itemsLight.length;
    
    //新增处理
    if(iCurOperType == 0){
        //新增时刷新回来的表体行数与界面显示的表体行数应该一致
        if(iLenDst != iLenLight){
            SCMEnv.out("新增刷新失败：刷新回来的表体行数与界面显示的表体行数不一致!");
            return false;
        }
        //表头
        getHeadVO().refreshByHeaderVo(voLight.getHeadVO());
        //表体:数据匹配由voLight保证
        for (int i = 0; i < iLenDst; i++) {
            if (itemsDst[i] == null || itemsLight[i] == null) {
                continue;
            }
            itemsDst[i].refreshByItemVo(itemsLight[i]);
        }
    }
    //修改处理
    else if(iCurOperType == 1){
        //获取需要刷新的VO
        OrderVO voCheckDst = getCheckVO();
        if(voCheckDst == null || voCheckDst.getHeadVO() == null){
            SCMEnv.out("修改刷新失败：真正要刷新的单据为空!");
            return false;
        }
        //刷新表头(注意此处用this的表头，而不是voCheckDst的)
        getHeadVO().refreshByHeaderVo(voLight.getHeadVO());
        //轻量VO表体哈希表{单据体行号=单据体VO},since v56修正，用行号能解决修订时增行匹配 不上需要刷新的表体行的问题 
        HashMap mapRowNoVo = new HashMap();
        for (int i = 0; i < iLenLight; i++) {
            if (itemsLight[i] == null || itemsLight[i].getCrowno() == null) {
                continue;
            }
            mapRowNoVo.put(itemsLight[i].getCrowno(),itemsLight[i]);
        }
        //刷新表体
        itemsDst = voCheckDst.getBodyVO();
        iLenDst = itemsDst.length;
        for (int i = 0; i < iLenDst; i++) {
            if (itemsDst[i] == null || itemsDst[i].getCrowno() == null) {
                continue;
            }
            if(!mapRowNoVo.containsKey(itemsDst[i].getCrowno())){
                SCMEnv.out("修改刷新失败：存在表体找不到匹配的刷新表体(按行号关联)!");/*-=notranslate=-*/
                return false;
            }
            itemsDst[i].refreshByItemVo((OrderItemVO)mapRowNoVo.get(itemsDst[i].getCrowno()));
        }
        //重新设置VO：
        setChildrenVO(itemsDst);
    }
    //不支持的操作类型
    else {
        SCMEnv.out("不支持的操作类型:"+iCurOperType+"!");
        return false;
    }
    return true;
}
/**
 *  表体VO长度，空为0
 *  @since V50
 *  @author czp 
 **/
public int getBodyLen(){
	if(this.getBodyVO() == null){
		return 0;
	}
	return this.getBodyVO().length;
}
	/**
	 *<p>支持集中采购所做的保存前检查。
	 *
	 *<p>1.增加：采购支持业务模式的公司关系检查，按订单行，
	 *<p>	  i.distinct(订单公司、需求公司、收货公司、收票公司).length = 2
	 *<p>	 ii.公司业务类型必须满足：订单公司、需求公司、收货公司、收票公司均相同
	 *<p>	iii.集团业务类型，
	 *<p>2.	增加：当“收货公司＝登录公司”时，收票公司只能为登录公司
	 *<p>3.	业务类型不走到货计划，收货公司,收货库存组织非空。
	 *@date 2006-03-09
	 *@author czp
	 *@since V50
	 */
	public void validateCentrPur() throws ValidationException {

		if(this.getHeadVO() == null 
				|| PuPubVO.getString_TrimZeroLenAsNull(this.getHeadVO().getCbiztype()) == null
				|| PuPubVO.getString_TrimZeroLenAsNull(this.getHeadVO().getPk_corp()) == null){
			return;
		}
		if(this.getBodyVO() == null || this.getBodyVO().length == 0){
			return;
		}		
		//以下列表存放相应错误的行号
		ArrayList listErrRowNo1i = new ArrayList();
		ArrayList listErrRowNo1ii = new ArrayList();
		ArrayList listErrRowNo2 = new ArrayList();
		ArrayList listErrRowNo3 = new ArrayList();
		String strLoginCorp = this.getHeadVO().getPk_corp();
		String strReqCorp = null;
		String strArrCorp = null;
		String strInvoiceCorp = null;
		int iLen = this.getBodyLen();
		OrderItemVO[] items = this.getBodyVO();
		HashMap mapCorpId = null;	
		//是否是集团业务类型
		boolean bCentrPur = false;
		OrderstatusVO[] statVos = null;
		try {
			bCentrPur = CentrPurchaseUtil.isGroupBusiType(this.getHeadVO().getCbiztype());
			IOrderstatus bo = (IOrderstatus) NCLocator.getInstance().lookup(IOrderstatus.class.getName());
			statVos = bo.queryStatusVOsByPkCorpAndIDs(strLoginCorp,new String[]{this.getHeadVO().getCbiztype()});	
		} catch (BusinessException e) {
			throw new ValidationException(e.getMessage());
		}
		//业务类型是否走到货计划
		boolean bArrPlan = (statVos != null 
								&& statVos.length > 0
								&& statVos[0] != null 
								&& statVos[0].getBisneedrp() != null 
								&& statVos[0].getBisneedrp().intValue() == 1);
		//V5支持的模式
		for(int i=0;i<iLen;i++){
			if(items[i] == null){
				continue;
			}
			strReqCorp = PuPubVO.getString_TrimZeroLenAsNull(items[i].getPk_reqcorp());
			strArrCorp = PuPubVO.getString_TrimZeroLenAsNull(items[i].getPk_arrvcorp());
			strInvoiceCorp = PuPubVO.getString_TrimZeroLenAsNull(items[i].getPk_invoicecorp());
			//1.i.distinct(订单公司、需求公司、收货公司、收票公司).length = 2	
			mapCorpId = new HashMap();
			mapCorpId.put(strLoginCorp,"");		
			if(strReqCorp != null){
				mapCorpId.put(strReqCorp,"");			
			}
			if(strArrCorp != null){
				mapCorpId.put(strArrCorp,"");
			}
			if(strInvoiceCorp != null){
				mapCorpId.put(strInvoiceCorp,"");
			}
			if(mapCorpId.size() > 2){
				listErrRowNo1i.add((i+1)+"");
			}
			//1.ii.公司业务类型必须满足：订单公司、需求公司、收货公司、收票公司均相同
			if(!bCentrPur){
				if(mapCorpId.size() > 1){
					listErrRowNo1ii.add((i+1)+"");
				}
			}
			//2.当“收货公司＝登录公司”时，收票公司只能为登录公司
			if(strLoginCorp.equals(strArrCorp) && !strLoginCorp.equals(strInvoiceCorp)){
				listErrRowNo2.add((i+1)+"");
			}
			//3.业务类型不走到货计划，收货公司非空
			if(!bArrPlan && strArrCorp == null){
				listErrRowNo3.add((i+1)+"");
			}
		}

		//异常数据组织
		StringBuffer message = new StringBuffer("");
		String strNo1i = null;
		String strNo1ii = null;
		String strNo2 = null;
		String strNo3 = null;
		boolean bThrowException = false;
		//UPT4004020201-000122=行号：{0} ,是暂未支持的第三方收货集中采购模式
		if (listErrRowNo1i.size() > 0) {
			bThrowException = true;
			strNo1i = (String)listErrRowNo1i.get(0);
			for ( int i= 1; i < listErrRowNo1i.size(); i++ ) {
				strNo1i += NCLangRes4VoTransl.getNCLangRes().getStrByID("SCMCOMMON","UPPSCMCommon-000000")/*@res "、"*/;
				strNo1i += " " + listErrRowNo1i.get(i) + " ";
			}
			message.append(NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPT4004020201-000122",null,new String[]{strNo1i})/*@res "行号：{0} ,是暂未支持的第三方收货集中采购模式"*/);
		}
		//UPT4004020201-000123=行号：{0} ,当前单据属公司业务类型，但上述行不满足：订单公司、需求公司、收货公司、收票公司均相同
		if (listErrRowNo1ii.size() > 0) {
			if(bThrowException){
				message.append("\n");
			}
			bThrowException = true;
			strNo1ii = (String)listErrRowNo1ii.get(0);
			for ( int i= 1; i < listErrRowNo1ii.size(); i++ ) {
				strNo1ii += NCLangRes4VoTransl.getNCLangRes().getStrByID("SCMCOMMON","UPPSCMCommon-000000")/*@res "、"*/;
				strNo1ii += " " + listErrRowNo1ii.get(i) + " ";
			}
			message.append(NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPT4004020201-000123",null,new String[]{strNo1ii})/*@res "行号：{0} ,当前单据属公司业务类型，但上述行不满足：订单公司、需求公司、收货公司、收票公司均相同"*/);
		}
		//UPT4004020201-000125=行号：{0} ,不满足：当“收货公司＝登录公司”时，收票公司只能为登录公司
		if (listErrRowNo2.size() > 0) {
			if(bThrowException){
				message.append("\n");
			}
			bThrowException = true;
			strNo2 = (String)listErrRowNo2.get(0);
			for ( int i= 1; i < listErrRowNo2.size(); i++ ) {
				strNo2 += NCLangRes4VoTransl.getNCLangRes().getStrByID("SCMCOMMON","UPPSCMCommon-000000")/*@res "、"*/;
				strNo2 += " " + listErrRowNo2.get(i) + " ";
			}
			message.append(NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPT4004020201-000125",null,new String[]{strNo2})/*@res "行号：{0} ,不满足：当“收货公司＝登录公司”时，收票公司只能为登录公司"*/);
		}
		//UPT4004020201-000126=行号：{0} ,不满足：业务类型不走到货计划，收货公司非空
		if (listErrRowNo3.size() > 0) {
			if(bThrowException){
				message.append("\n");
			}
			bThrowException = true;
			strNo3 = (String)listErrRowNo3.get(0);
			for ( int i= 1; i < listErrRowNo3.size(); i++ ) {
				strNo3 += NCLangRes4VoTransl.getNCLangRes().getStrByID("SCMCOMMON","UPPSCMCommon-000000")/*@res "、"*/;
				strNo3 += " " + listErrRowNo3.get(i) + " ";
			}
			message.append(NCLangRes4VoTransl.getNCLangRes().getStrByID("4004020201","UPT4004020201-000126",null,new String[]{strNo3})/*@res "行号：{0} ,不满足：业务类型不走到货计划，收货公司非空"*/);
		}
		if(bThrowException){
			throw new ValidationException(message.toString());
		}
	}
	/***
	 *
	 * 审批流接口，设置审批流信息，为空实现(与ICheckState同)
	 */
	public void setCheckNote(String strCheckNote) {
		
	}
	/***
	 *
	 * 审批流接口，映射审批流状态到单据状态(与ICheckState同)
	 */
	public void setCheckState(int icheckState) {
		if(getHeadVO() != null){
			switch (icheckState) {
			case IPfRetCheckInfo.COMMIT:
				getHeadVO().setForderstatus(new Integer(0));
				break;
			case IPfRetCheckInfo.GOINGON:
				getHeadVO().setForderstatus(new Integer(2));
				break;
			case IPfRetCheckInfo.PASSING:
				getHeadVO().setForderstatus(new Integer(3));
				break;
			case IPfRetCheckInfo.NOPASS:
				getHeadVO().setForderstatus(new Integer(4));
				break;
			default:
				break;
			}
		}
	}
	/**
	 * 当前单据状态是否自由或送审
	 * @return
	 */
	public boolean isCheckSave(){
		return getHeadVO()!= null 
			&& getHeadVO().getForderstatus() != null 
			&& getHeadVO().getForderstatus().intValue() == 0;
	}
	/**
	 * 当前单据状态是否正在审批
	 * @return
	 */
	public boolean isCheckGoing(){
		return getHeadVO()!= null 
			&& getHeadVO().getForderstatus() != null 
			&& getHeadVO().getForderstatus().intValue() == 2;
	}
	/**
	 * 当前单据状态是否审批通过
	 * @return
	 */
	public boolean isCheckPass(){
		return getHeadVO()!= null 
			&& getHeadVO().getForderstatus() != null 
			&& getHeadVO().getForderstatus().intValue() == 3;
	}
	/**
	 * 当前单据状态是否审批未通过
	 * @return
	 */
	public boolean isCheckNoPass(){
		return getHeadVO()!= null 
			&& getHeadVO().getForderstatus() != null 
			&& getHeadVO().getForderstatus().intValue() == 4;
	}
	/**
	 * 返回辅币金额
	 */
	public UFDouble getPfAssMoney() {
		return null;
	}
	/**
	 * 原币币种
	 */
	public String getPfCurrency() {
		if(getHeadVO() == null || PuPubVO.getString_TrimZeroLenAsNull(getHeadVO().getCcurrencytypeid()) == null){
		 return null;
		}else{
		 return	 getHeadVO().getCcurrencytypeid();
		}
	}
	/**
	 * 返回本币金额
	 */
	public UFDouble getPfLocalMoney() {
		if(getBodyLen() == 0){
			return null;
		}
		UFDouble ufdSumNmny = new UFDouble(0.0);
		for(int i=0; i<getBodyLen(); i++){
			if(getBodyVO()[i] == null){
				continue;
			}
			ufdSumNmny = ufdSumNmny.add(PuPubVO.getUFDouble_NullAsZero(getBodyVO()[i].getNtaxpricemny()));
		}
		return ufdSumNmny;
	}
	/**
	 * 返回原币金额
	 */
	public UFDouble getPfMoney() {
		if(getBodyLen() == 0){
			return null; 
		}
		UFDouble ufdSumNmny = new UFDouble(0.0);
		for(int i=0; i<getBodyLen(); i++){
			if(getBodyVO()[i] == null){
				continue;
			}
			ufdSumNmny = ufdSumNmny.add(PuPubVO.getUFDouble_NullAsZero(getBodyVO()[i].getNoriginaltaxpricemny()));
		}
		return ufdSumNmny;
	}

  /**
   * 父类方法重写
   * 
   * @see nc.vo.scm.pub.IscmDefCheckVO#getBodyDefValues(int)
   */
  public Object[] getBodyDefValues(int iserial) {
    if(getBodyVO() == null){
      return null;
    }
    Object[] oaRet = new Object[getBodyVO().length];
    for(int i=0; i<oaRet.length; i++){
      oaRet[i] = getBodyVO()[i].getAttributeValue("vdef"+iserial); 
    }
    return oaRet;
  }

  /**
   * 父类方法重写
   * 
   * @see nc.vo.scm.pub.IscmDefCheckVO#getCbilltypecode()
   */
  public String getCbilltypedef() {
    return ScmConst.PO_Order;
  }

  /**
   * 父类方法重写
   * 
   * @see nc.vo.scm.pub.IscmDefCheckVO#getHeadDefValue(int)
   */
  public Object getHeadDefValue(int iserial) {
    if(getHeadVO() == null){
      return null;
    }
    return getHeadVO().getAttributeValue("vdef"+iserial);
  }
public OperatelogVO getOperatelogVO() {
	if (m_OperatelogVO == null)
		  m_OperatelogVO = new OperatelogVO();
	  return m_OperatelogVO;
}
public void setOperatelogVO(OperatelogVO operatelogVO) {
	m_OperatelogVO = operatelogVO;
}
public String getBIDItemkey() {
	// TODO 自动生成方法存根
	return "corder_bid";
}

public String getSourBIDItemkey() {
	// TODO 自动生成方法存根
	return "cupsourcebillrowid";
}
public String getBilltypecode() {
	// TODO 自动生成方法存根
	return "21";
}
public String getBusitypePK() {
	// TODO 自动生成方法存根
	return getHeadVO().getCbiztype();
}
public int getCoopwithType() {
	// TODO 自动生成方法存根
	return 1;
}
public String getCustomerID() {
	// TODO 自动生成方法存根
	return getHeadVO().getPk_corp();
}
public String getOrgid() {
	// TODO 自动生成方法存根
	return getHeadVO().getCpurorganization();
}
public void setBusitypePK(String value) {
	// TODO 自动生成方法存根
	getHeadVO().setCbiztype(value);
}
public void setOrgid(String value) {
	// TODO 自动生成方法存根
	getHeadVO().setCpurorganization(value);
}
private static void calInitRelations(OrderItemVO voaBody){
	if (voaBody == null) {
		return;
	}
	String strCorp = voaBody.getPk_corp();
	
	//使用供应链公共算法来取缔原代码中自己计算各个数值的过程 since 5.3 modify by donggq 2008-05-28
	String strDisType = null;
int strDisTaxName = voaBody.getIdiscounttaxtype();
if (strDisTaxName == 0) {
  strDisType = VariableConst.IDISCOUNTTAXTYPE_NAME_INNER_NO_TRANS;// 应税内含
}
else if (strDisTaxName == 1) {
  strDisType = VariableConst.IDISCOUNTTAXTYPE_NAME_OUTTER_NO_TRANS;// 应税外加
}
else if (strDisTaxName == 2) {
  strDisType = VariableConst.IDISCOUNTTAXTYPE_NAME_NOCOUNT_NO_TRANS;//不计税
}
int[] descriptions =
  new int[] {
		SCMRelationsCal.DISCOUNT_TAX_TYPE_NAME,
		SCMRelationsCal.DISCOUNT_TAX_TYPE_KEY,
		 SCMRelationsCal.NUM,
		 SCMRelationsCal.NET_PRICE_ORIGINAL,
		 SCMRelationsCal.NET_TAXPRICE_ORIGINAL,
		 SCMRelationsCal.TAXRATE,
		 SCMRelationsCal.MONEY_ORIGINAL,
		 SCMRelationsCal.TAX_ORIGINAL,
		 SCMRelationsCal.SUMMNY_ORIGINAL};
String[] keys =
  new String[] {
    strDisType,
    "idiscounttaxtype",
    "nordernum",
    "noriginalcurprice",
    "norgnettaxprice",
    "ntaxrate",
    "noriginalcurmny",
    "noriginaltaxmny",
    "noriginaltaxpricemny" };
String sPara = null;
try{
	sPara = SysinitAccessor.getInstance().getParaString(strCorp,"PO28");
}catch(Exception e){
	SCMEnv.out(e);
}
if (sPara == null) {
	sPara = "含税价格优先";
}
Integer iPara = (sPara.equals("含税价格优先") ? new Integer(
		RelationsCalVO.TAXPRICE_PRIOR_TO_PRICE) : new Integer(
		RelationsCalVO.PRICE_PRIOR_TO_TAXPRICE));
SCMRelationsCal.calculate(voaBody, new int[]{iPara.intValue()} , "nordernum", descriptions, keys);
}
public boolean isSameCorp(){
	return getHeadVO().getPk_corp().equals(ClientEnvironment.getInstance().getCorporation().getPk_corp());
}

/**
 * 根据表体正负符号分单(此分单在订单按档案等分单方式进行分单后应用)
 * <strong>注意：</strong>
 * <p>1、按某张订单的表体数量分单，所以分单后的结果 > voaSrc.length
 * <p>2、负数一单，处理成退货订单；正数一单处理成正常的订单
 * <p>@date 2009-07-07
 * <p>@sinve v55
 * 
 */
public static OrderVO[] splitVos(OrderVO[] voaSrc){
	if(voaSrc == null || voaSrc.length == 0){
		return voaSrc;
	}
	OrderVO voOrder = null;
	ArrayList<OrderVO> listOrderVoNew = new ArrayList<OrderVO>();
	ArrayList<OrderItemVO> listItemVoPlus = new ArrayList<OrderItemVO>();
	ArrayList<OrderItemVO> listItemVoNeg = new ArrayList<OrderItemVO>();
	OrderItemVO[] items = null;
	for(int i=0; i<voaSrc.length; i++){
		items = voaSrc[i].getBodyVO();
		if(items == null || items.length == 0){
			continue;
		}
		listItemVoPlus = new ArrayList<OrderItemVO>();
		listItemVoNeg = new ArrayList<OrderItemVO>();
		for(int j=0; j<items.length; j++){
			if(items[j] == null) continue;
			if(PuPubVO.getUFDouble_NullAsZero(items[j].getNordernum()).doubleValue() < 0.0){
				listItemVoNeg.add(items[j]);
			} 
			else {
				listItemVoPlus.add(items[j]);
			}
		}
		//本单据表体符号相同,就用此待分单单据
		if(listItemVoPlus.size() == 0 || listItemVoNeg.size() == 0){
			listOrderVoNew.add(voaSrc[i]);
			voaSrc[i].getHeadVO().setBreturn(new UFBoolean(listItemVoNeg.size() > 0));
			continue;
		}
		//待分单单据处理成正号的内容
		voaSrc[i].setChildrenVO(listItemVoPlus.toArray(new OrderItemVO[listItemVoPlus.size()]));
		voaSrc[i].getHeadVO().setBreturn(UFBoolean.FALSE);
		listOrderVoNew.add(voaSrc[i]);
		//负号表体内容，用CLONE出一张新单据
		voOrder = voaSrc[i].clone();
		voOrder.setStatus(VOStatus.NEW);
		voOrder.setParentVO((OrderHeaderVO)voaSrc[i].getHeadVO().clone());
		voOrder.setChildrenVO(listItemVoNeg.toArray(new OrderItemVO[listItemVoNeg.size()]));
		voOrder.getHeadVO().setBreturn(UFBoolean.TRUE);
		listOrderVoNew.add(voOrder);
	}
	return listOrderVoNew.toArray(new OrderVO[listOrderVoNew.size()]) ;
}

public boolean setTransClosedVo(OrderVO voLight){
    
    if(voLight == null || voLight.getHeadVO() == null && voLight.getBodyVO() == null){
        SCMEnv.out("刷新回来的VO或其表头或其表体存在空，刷新失败!");
        return false;
    }
    
    OrderItemVO[] itemsDst = getBodyVO();
    OrderItemVO[] itemsLight = voLight.getBodyVO();
    int iLenDst = itemsDst.length;
    int iLenLight = itemsLight.length;
    
    //时刷新回来的表体行数与界面显示的表体行数应该一致
    if(iLenDst != iLenLight){
        SCMEnv.out("刷新失败：刷新回来的表体行数与界面显示的表体行数不一致!");
        return false;
    }
    HashMap<String,OrderItemVO> hmLightItem = new HashMap<String, OrderItemVO>();
    for (OrderItemVO orderItemVO : itemsLight) {
        hmLightItem.put(orderItemVO.getPrimaryKey(), orderItemVO);
    }
    //表头
    getHeadVO().setTs(voLight.getHeadVO().getTs());
    //表体:数据匹配由voLight保证
    for (int i = 0; i < iLenDst; i++) {
        if (itemsDst[i] == null || !hmLightItem.containsKey(itemsDst[i].getPrimaryKey())) {
            continue;
        }
        itemsDst[i].refreshItemVoByKey(hmLightItem.get(itemsDst[i].getPrimaryKey()),OrderVORefreshTool.TRANSCLOSE_ITEM_FIELDS);
    }
    return true;
}
}