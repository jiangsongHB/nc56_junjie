/*******************************************************************************
 * *************************************************************\ The skeleton
 * of this class is generated by an automatic * code generator for NC product. * \
 ******************************************************************************/

package nc.bs.pi;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import javax.naming.NamingException;

import org.apache.commons.lang.ArrayUtils;

import nc.bs.bd.b21.BusinessCurrencyRateUtil;
import nc.bs.dao.BaseDAO;
import nc.bs.dao.DAOException;
import nc.bs.framework.common.NCLocator;
import nc.bs.ml.NCLangResOnserver;
import nc.bs.po.OrderDMO;
import nc.bs.po.OrderImpl;
import nc.bs.ps.settle.SettleImpl;
import nc.bs.ps.vmi.VMIImpl;
import nc.bs.pu.pub.BsPuTool;
import nc.bs.pu.pub.PubDMO;
import nc.bs.pub.SystemException;
import nc.bs.pub.para.SysInitDMO;
import nc.bs.scm.pub.pf.SCMPfPubUtil;
import nc.itf.arap.pub.IArapForGYLPublic;
import nc.itf.ic.service.IICToPU_Ic2puDMO;
import nc.itf.ic.service.IICToPU_VmiSumDMO;
import nc.itf.pi.IInvoice;
import nc.itf.pp.ask.IAsk;
import nc.itf.pu.inter.IPuToIc_InvoiceImpl;
import nc.itf.pu.pub.fw.LockTool;
import nc.itf.scm.cenpur.service.TempTableUtil;
import nc.itf.scm.pub.bill.IScm;
import nc.itf.uap.IUAPQueryBS;
import nc.itf.uap.busibean.ISysInitQry;
import nc.itf.uap.pf.IPFBusiAction;
import nc.itf.uap.pf.IPFMetaModel;
import nc.itf.uap.sf.ICreateCorpQueryService;
import nc.jdbc.framework.processor.ColumnProcessor;
import nc.jdbc.framework.processor.MapProcessor;
import nc.ui.bd.b21.CurrParamQuery;
import nc.vo.ic.pub.bill.GeneralBillHeaderVO;
import nc.vo.ic.pub.bill.GeneralBillItemVO;
import nc.vo.ic.pub.bill.GeneralBillVO;
import nc.vo.pf.pub.BusitypeVO;
import nc.vo.pi.ConstantVO;
import nc.vo.pi.InvoiceHeaderVO;
import nc.vo.pi.InvoiceItemVO;
import nc.vo.pi.InvoicePubVO;
import nc.vo.pi.InvoiceVO;
import nc.vo.pi.NormalCondVO;
import nc.vo.pi.RelatedTableVO;
import nc.vo.po.OrderItemVO;
import nc.vo.po.OrderVO;
import nc.vo.po.pub.RetPoVrmAndParaPriceVO;
import nc.vo.po.rewrite.ParaPiToPoRewriteVO;
import nc.vo.ps.estimate.GeneralBb3VO;
import nc.vo.ps.settle.IAdjuestVO;
import nc.vo.ps.settle.SettlebillItemVO;
import nc.vo.ps.settle.SettlebillVO;
import nc.vo.pu.util.AppConstant;
import nc.vo.pu.util.PuUtils;
import nc.vo.pub.BusinessException;
import nc.vo.pub.VOStatus;
import nc.vo.pub.lang.UFBoolean;
import nc.vo.pub.lang.UFDate;
import nc.vo.pub.lang.UFDateTime;
import nc.vo.pub.lang.UFDouble;
import nc.vo.pub.para.SysInitVO;
import nc.vo.pub.pfflow04.MessagedriveVO;
import nc.vo.pub.query.ConditionVO;
import nc.vo.pub.util.StringUtil;
import nc.vo.scm.constant.ScmConst;
import nc.vo.scm.pu.BillStatus;
import nc.vo.scm.pu.BillTypeConst;
import nc.vo.scm.pu.PuPubVO;
import nc.vo.scm.pu.RelationsCalVO;
import nc.vo.scm.pub.SCMEnv;
import nc.vo.scm.pub.vosplit.SplitBillVOs;

/**
 * Invoice的BO类 创建日期：(2001-6-18)
 * 
 * @author：王印芬
 */
public class InvoiceImpl implements IInvoice, IPuToIc_InvoiceImpl {

  /**
   * InvoiceBO 构造子注解。
   */
  public InvoiceImpl() {
    super();
  }

  /**
   * 通过主键获得VO对象。 创建日期：(2001-8-4)
   * 
   * @return nc.vo.pi.InvoiceVO
   * @param key
   *          String
   * @exception java.rmi.RemoteException
   *              异常说明。
   */
  public InvoiceVO findByPrimaryKey(String key) throws BusinessException {

    InvoiceVO invoice = null;
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      invoice = dmo.findByPrimaryKey(key);
    }
    catch (Exception e) {

    }
    return invoice;
  }

  /**
   * 订单表体行对应的已开票的发票的表体行
   */
  public HashMap queryInvoiceBodys(String strOrderBid[]) throws BusinessException {
    HashMap hResult = new HashMap();
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      hResult = dmo.findInvoiceNum(strOrderBid);
    }
    catch (Exception e) {
      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.queryInvoiceBodys", e);
    }
    return hResult;
  }

  /**
   * 入库单表体行对应的已开票的发票的表体行
   */
  public HashMap queryInvoiceBodysStore(String strStoreBid[]) throws BusinessException {
    HashMap hResult = new HashMap();
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      hResult = dmo.findInvoiceNumForStore(strStoreBid);
    }
    catch (Exception e) {
      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.queryInvoiceBodys", e);
    }
    return hResult;
  }

  /**
   * 通过主键获得VO对象。 创建日期：(2001-8-4)
   * 
   * @return nc.vo.pi.InvoiceVO
   * @param key
   *          String
   * @exception java.rmi.RemoteException
   *              异常说明。
   */
  public Hashtable<String, InvoiceVO> findByPrimaryKeyBantch(Vector hidKeyVEC) throws BusinessException {

    InvoiceVO invoice = null;
    Hashtable<String, InvoiceVO> resultH = new Hashtable<String, InvoiceVO>();
    try {

      InvoiceDMO dmo = new InvoiceDMO();
      for (int i = 0; i < hidKeyVEC.size(); i++) {
        invoice = dmo.findByPrimaryKey(hidKeyVEC.get(i).toString());
        if (invoice != null && invoice.getHeadVO() != null && invoice.getHeadVO().getPrimaryKey() != null) {
          resultH.put(invoice.getHeadVO().getPrimaryKey(), invoice);
        }
      }
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.findByPrimaryKeyBantch( Vector hidKeyVEC)", e);
    }
    return resultH;
  }

  /**
   * 向数据库中插入一个VO对象。 创建日期：(2001-8-4)
   * 
   * @param invoice
   *          nc.vo.pi.InvoiceVO
   * @return java.lang.String 所插入VO对象的主键字符串。
   * @exception BusinessException
   *              异常说明。
   */
  public String insert(InvoiceVO invoice) throws BusinessException {
    String key = null;
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      key = dmo.insert(invoice);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.insert(InvoiceVO)", e);
    }
    return key;
  }

  /**
   * 根据主键在数据库中删除一个VO对象。 创建日期：(2001-8-4)
   * 
   * @param key
   *          String
   * @exception BusinessException
   *              异常说明。
   */
  public void delete(InvoiceVO vo) throws BusinessException {

    try {
      InvoiceDMO dmo = new InvoiceDMO();
      dmo.delete(vo);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.delete(InvoiceVO)", e);
    }
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2001-8-4)
   * 
   * @param invoice
   *          nc.vo.pi.InvoiceVO
   * @exception BusinessException
   *              异常说明。
   */
  public void update(InvoiceVO invoice) throws BusinessException {

    try {
      InvoiceDMO dmo = new InvoiceDMO();
      dmo.update(invoice);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.update(InvoiceVO)", e);
    }
  }

  /**
   * 提供给库存的VNI消耗汇总接口 创建日期：(2001-8-4)
   * 
   * @param invoice
   *          nc.vo.pi.InvoiceVO
   * @exception BusinessException
   *              异常说明。
   */
  public void queryIfExecVMI(String[] saHid) throws BusinessException {
    if (saHid.length == 0) {
      return;
    }
    boolean isAlreadyGen = false;

    try {
      Vector vTemp = new Vector();
      for (int i = 0; i < saHid.length; i++) {
        if (!vTemp.contains(saHid[i]))
          vTemp.addElement(saHid[i]);
      }
      String sTemp[] = new String[vTemp.size()];
      vTemp.copyInto(sTemp);
      // 临时表
      nc.bs.scm.pub.TempTableDMO dmoTempTbl = new nc.bs.scm.pub.TempTableDMO();
      String strSetId = dmoTempTbl.insertTempTable(sTemp, nc.vo.scm.pub.TempTableVO.TEMPTABLE_PU92,
          nc.vo.scm.pub.TempTableVO.TEMPPKFIELD_PU);
      if (strSetId == null || strSetId.trim().equals("()")) {
        strSetId = " ('ErrorPk') ";
      }

      InvoiceDMO dmo = new InvoiceDMO();
      isAlreadyGen = dmo.queryIfExecVMI(strSetId);
      if (isAlreadyGen) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000235")/*
                                   * @res "已经生成采购发票,不能取消ＶＭＩ消耗汇总！"
                                   */);
      }
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.queryIfExecVMI(String[])", e);
    }
  }

  /**
   * 作者:熊海情 功能:入库单签字时,推式生成采购发票
   * 
   * @param 入库单VO
   * @return
   * @throws BusinessException
   *           日期:2005-04-11
   */
  // public void generateInvoicesByPush(GeneralBillVO VOs[])
  // throws BusinessException {
  // // 参数正确性检查
  // if (VOs == null || VOs.length == 0) {
  // SCMEnv
  // .out("nc.bs.pi.InvoiceImpl.generateInvoicesByPush(VOs[])传入参数为空，不正确！");
  // return;
  // }
  //
  // if (PuPubVO
  // .getString_TrimZeroLenAsNull(VOs[0].getHeaderVO().getCregister()) == null
  // || PuPubVO.getString_TrimZeroLenAsNull(VOs[0].getHeaderVO()
  // .getDaccountdate()) == null) {
  // throw new BusinessException("入库单没有签字");
  // }
  //
  // try {
  // // 入库单转换成发票
  // InvoiceVO invVOs[] = (InvoiceVO[]) PfUtilTools.runChangeDataAry(VOs[0]
  // .getHeaderVO().getCbilltypecode(), "25", VOs);
  // if (invVOs == null || invVOs.length == 0)
  // return;
  //
  // // 本位币
  // ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator
  // .getInstance().lookup(ISysInitQry.class.getName());
  // SysInitVO initVO = initDMO.queryByParaCode(VOs[0].getHeaderVO()
  // .getPk_corp(), "BD301");
  // String cCurrencyTypeID = null;
  // if (initVO != null)
  // cCurrencyTypeID = initVO.getPkvalue();
  //
  // // zhy根据供应商查询默认交易币种
  // PubDMO dmo = new PubDMO();
  // String cvendormangid = null;
  // String curTypeID = null;// 供应商默认币种
  // UFDouble[] nrate = null;
  // UFDouble nexchangeotobrate = null;
  // String pk_corp = VOs[0].getHeaderVO().getPk_corp();
  //
  // if (PuPubVO.getString_TrimZeroLenAsNull(VOs[0].getHeaderVO()
  // .getCregister()) == null
  // || PuPubVO.getString_TrimZeroLenAsNull(VOs[0].getHeaderVO()
  // .getDaccountdate()) == null) {
  // throw new BusinessException("入库单没有签字");
  // }
  //
  // // 转换后处理
  // for (int i = 0; i < invVOs.length; i++) {
  //
  // // 来源
  // invVOs[i].setSource(InvoiceVO.FROM_STO);
  // // 删除标记
  // invVOs[i].getHeadVO().setDr(new Integer(0));
  // // 发票日期,收票日期,发票类型 期初标志,制单人
  // invVOs[i].getHeadVO().setDinvoicedate(
  // VOs[0].getHeaderVO().getDaccountdate());
  // invVOs[i].getHeadVO().setDarrivedate(
  // VOs[0].getHeaderVO().getDaccountdate());
  // invVOs[i].getHeadVO().setIbillstatus(new Integer(0));
  // invVOs[i].getHeadVO().setFinitflag(new Integer(0));
  // invVOs[i].getHeadVO().setIinvoicetype(new Integer(0));
  // invVOs[i].getHeadVO().setIdiscounttaxtype(new Integer(1));
  // // 操作人
  // invVOs[i].getHeadVO().setCoperator(VOs[0].getHeaderVO().getCregister());
  // // 表体税率、汇率
  // invVOs[i].getHeadVO().setNtaxrate(null);
  //
  // cvendormangid = invVOs[i].getHeadVO().getCvendormangid();
  // if (cvendormangid != null && cvendormangid.trim().length() > 0) {
  // Hashtable ht = dmo.queryHtResultFromAnyTable("bd_cumandoc",
  // "pk_cumandoc", new String[] {
  // "pk_currtype1"
  // }, new String[] {
  // cvendormangid
  // });
  // if (ht != null && ht.size() > 0) {
  // Vector v = (Vector) ht.get(cvendormangid);
  // Object[] o = (Object[]) v.get(0);
  // curTypeID = (String) o[0];
  // nrate = getRateBoth(pk_corp, curTypeID, null);
  // if (nrate != null && nrate.length == 2) {
  // nexchangeotobrate = nrate[1];
  // invVOs[i].getHeadVO().setNexchangeotobrate(nexchangeotobrate);
  // }
  // }
  // }
  //
  // InvoiceItemVO[] voaInvItem = invVOs[i].getBodyVO();
  // GeneralBillItemVO itemVO[] = VOs[i].getItemVOs();
  // for (int j = 0; j < voaInvItem.length; j++) {
  // // 扣税类别
  // voaInvItem[j].setIdiscounttaxtype(new Integer(1));
  // // 删除标记
  // voaInvItem[j].setDr(new Integer(0));
  // // 折本及折辅江率
  // if (curTypeID == null) {
  // voaInvItem[j].setCcurrencytypeid(cCurrencyTypeID);
  // // 折本及折辅江率
  // voaInvItem[j].setNexchangeotobrate(new UFDouble(1));
  // }
  // else {
  // voaInvItem[j].setCcurrencytypeid(curTypeID);
  // // 折本及折辅江率
  // voaInvItem[j].setNexchangeotobrate(nexchangeotobrate);
  // }
  //
  // voaInvItem[j].setNinvoicenum(itemVO[j].getNinnum());
  // voaInvItem[j].setNoriginalcurprice(itemVO[j].getNprice());
  // voaInvItem[j].setNorgnettaxprice(itemVO[j].getNprice());
  // // voaInvItem[j].setNtaxrate(new UFDouble(0.0));
  //
  // if (voaInvItem[j].getNinvoicenum() != null
  // && voaInvItem[j].getNoriginalcurprice() != null) {
  // voaInvItem[j].setNmoney(voaInvItem[j].getNinvoicenum().multiply(
  // voaInvItem[j].getNoriginalcurprice()));
  // voaInvItem[j].setNoriginalcurmny(voaInvItem[j].getNmoney());
  // }
  // voaInvItem[j].setNsummny(voaInvItem[j].getNmoney());
  // voaInvItem[j].setNoriginalsummny(voaInvItem[j].getNmoney());
  //
  // voaInvItem[j].setNaccumsettmny(new UFDouble(0));
  // voaInvItem[j].setNaccumsettnum(new UFDouble(0));
  //
  // // voaInvItem[j].setCcurrencytypeid(cCurrencyTypeID);
  // }
  // }
  // BillRowNoDMO.setVOsRowNoByRule(invVOs, "25", "crowno");
  //
  // // 推式保存
  // ArrayList paraList = new ArrayList();
  // paraList.add(null);
  // paraList.add(null);
  // if (paraList.size() != 3) {
  // // 结算LIST
  // ArrayList forSettleList = new ArrayList();
  // forSettleList.add(VOs[0].getHeaderVO().getDaccountdate());
  // forSettleList.add(new UFBoolean(false));
  // forSettleList.add(new UFBoolean(false));
  //
  // paraList.add(forSettleList);
  // }
  // // 支持供应商核准检查
  // paraList.add(new Integer(0));
  // paraList.add("cvendormangid");
  // paraList.add(new Integer(0));
  //
  // for (int i = 0; i < invVOs.length; i++) {
  // saveInvoice(invVOs[i], paraList);
  // }
  // }
  // catch (Exception e) {
  //
  // PubDMO.throwBusinessException(
  // "nc.bs.piInvocieImpl.generateInvoicesByPush(GeneralBillVO)", e);
  // }
  // }
  /**
   * 作者：王印芬 功能：根据常用条件VO及自定义条件VO拼装查询条件 参数： NormalCondVO[] normalVOs 常用查询条件VO数组
   * ConditionVO[] definedVOs 自定义查询条件VO数组 返回：InvoiceVO[] 符合查询条件的发票VO数组 例外：
   * 日期：(2001-5-18 9:23:11) 修改日期，修改人，修改原因，注释标志： 2002-05-24 王印芬 冻结的供应商及封存的存货可以查询出
   * 2012-19-24 王印芬 添加对审批节点的支持，审批未通过的单据不查出
   */
  private String getInvQueFromWhere(NormalCondVO[] normalVOs, ConditionVO[] definedVOs)
      throws BusinessException {

    // 相关表VO
    RelatedTableVO tableVO = new RelatedTableVO("发票");
    String condStr = "po_invoice.dr=0 AND po_invoice_b.dr=0";
    // 审批
    String sAuditStatusWhere = "";

    // 定义公司变量
    String pk_corp = null;

    // ////////////////对常用条件进行处理
    for (int i = 0; i < normalVOs.length; i++) {
      // 公司
      if (normalVOs[i].getKey().equals("公司")) {
        pk_corp = (String) normalVOs[i].getValue();
        condStr += " AND " + normalVOs[i].getWhereStr("po_invoice.pk_corp", "=", NormalCondVO.STRING);

      }
      else if (normalVOs[i].getKey().equals("业务类型")) {
         condStr += " AND "
         + normalVOs[i].getWhereStr("po_invoice.cbiztype", "=",
         NormalCondVO.STRING);
      }
      else if (normalVOs[i].getKey().equals("单据ID")) {
        condStr += " AND (po_invoice.cinvoiceid = '" + normalVOs[i].getValue() + "')";
      }
      // 是否期初，是否审批，是否费用
      else if (normalVOs[i].getKey().equals("期初")) {
        if (normalVOs[i].getValue().equals("是"))
          condStr += " AND po_invoice.finitflag=1";
        else if (normalVOs[i].getValue().equals("否"))
          condStr += " AND po_invoice.finitflag=0";
      }
      else if (normalVOs[i].getKey().equals("审批")) {
        // 0自由 1作废 2正在审批 3审批通过 4审批未通过
        if (normalVOs[i].getValue().equals("是"))
          condStr += " AND (po_invoice.ibillstatus=3)";
        else if (normalVOs[i].getValue().equals("否"))
          condStr += " AND (po_invoice.ibillstatus IN (0,2,4))";
      }
      // wyf 2002-12-19 add begin
      else if (normalVOs[i].getKey().equals("未审批")) {
        sAuditStatusWhere += sAuditStatusWhere.length() == 0 ? nc.vo.scm.pu.BillStatus.FREE.toString() : ","
            + nc.vo.scm.pu.BillStatus.FREE.toString();
      }
      else if (normalVOs[i].getKey().equals("正在审批")) {
        sAuditStatusWhere += sAuditStatusWhere.length() == 0 ? nc.vo.scm.pu.BillStatus.AUDITING.toString() : ","
            + nc.vo.scm.pu.BillStatus.AUDITING.toString();
      }
      else if (normalVOs[i].getKey().equals("审批未通过") && normalVOs[i].getValue().equals("是")) {
        sAuditStatusWhere += sAuditStatusWhere.length() == 0 ? nc.vo.scm.pu.BillStatus.AUDITFAIL.toString() : ","
            + nc.vo.scm.pu.BillStatus.AUDITFAIL.toString();
        // wyf 2002-12-19 add end
      }
      else if (normalVOs[i].getKey().equals("费用")) {
        if (normalVOs[i].getValue().equals("是")) {
          tableVO.addElement("存货基本档案");
          condStr += " AND bd_invbasdoc.laborflag='Y'";
        }
        else if (normalVOs[i].getValue().equals("否")) {
          tableVO.addElement("存货基本档案");
          condStr += " AND bd_invbasdoc.laborflag<>'Y'";
        }
      }
      else if (normalVOs[i].getKey().equals("含虚拟发票")) {
        // 是否含虚拟发票
        if (normalVOs[i].getValue().equals("否"))
          condStr += " AND po_invoice.iinvoicetype<>3";
      }
      else if (normalVOs[i].getKey().equals("单据ID")) {
        // 单据ID
        condStr += " AND po_invoice.cinvoiceid='" + normalVOs[i].getValue() + "'";
      }
      else if (normalVOs[i].getKey().equals("来源单据")) {
        // 加入来源单据子查询语句
        condStr += " AND " + normalVOs[i].getValue();
      }
    }

    if (sAuditStatusWhere.trim().length() > 1) {
      condStr += " AND (po_invoice.ibillstatus IN (" + sAuditStatusWhere + "))";
    }

    // 处理发票类型的查询条件
    definedVOs = dealInvoiceType(definedVOs);
    // 处理供应商地区的查询条件
    definedVOs = dealAreaForVendor(definedVOs, pk_corp);
    // 处理包含关系
    definedVOs = dealContainRelation(definedVOs);

    // 对自定义条件进行处理
    String sSQL = "";
    if (definedVOs != null && definedVOs.length != 0) {
      // 常用条件与自定义条件为AND关系
      for (int i = 0; i < definedVOs.length; i++) {
        String fieldCode = definedVOs[i].getFieldCode();
        // 数据权限特殊处理
        if (definedVOs[i].getOperaCode().equalsIgnoreCase("in")) {
          // 转换名称、编码到相关档案主键
          if (InvoicePubVO._Hash_InvoiceUI.get(fieldCode) != null) {
            definedVOs[i].setFieldCode((String) InvoicePubVO._Hash_InvoiceUI.get(fieldCode));
          }
          fieldCode = definedVOs[i].getFieldCode();
          // 非必输项权限处理：如果某个基本档案启用权限但单据表中未录入该基本数据，则用户能够查询
          if (fieldCode.equals("po_invoice_b.cwarehouseid")
              || fieldCode.equals("po_invoice.cpayunit")// 付款单位:供应商档案
              || fieldCode.equals("po_invoice_b.cusedeptid") || fieldCode.equals("po_invoice_b.cprojectid")
              || fieldCode.equals("po_invoice_b.cwarehouseid")// 基于上述“转换名称、编码到相关档案主键”
              || fieldCode.equals("po_invoice.cstoreorganization")// 基于上述“转换名称、编码到相关档案主键”
          ) {
            definedVOs[i].setOperaCode(" is null or " + fieldCode + " = '' or " + fieldCode + " in ");
            definedVOs[i].setDataType(1);
          }
          sSQL = definedVOs[i].getSQLStr();
          if (sSQL != null && !sSQL.trim().equals("")) {
            sSQL = StringUtil.replaceAllString(sSQL, "custcode", "m.pk_cumandoc");
            sSQL = StringUtil.replaceAllString(sSQL, "psncode", "bd_psndoc.pk_psndoc");
            sSQL = StringUtil.replaceAllString(sSQL, "deptcode", "bd_deptdoc.pk_deptdoc");
            sSQL = StringUtil.replaceAllString(sSQL, "bodycode", "bd_calbody.pk_calbody");
            sSQL = StringUtil.replaceAllString(sSQL, "storcode", "pk_stordoc");
            sSQL = StringUtil.replaceAllString(sSQL, " or (bd_areacl.pk_areacl in ( (select areaclcode",
                " or (bd_areacl.pk_areacl in ( (select pk_areacl");
            condStr += sSQL;
          }
          // /得到表名
          int index = fieldCode.indexOf(".", 1);
          String table = null;
          if (index > 0) {
            table = fieldCode.substring(0, index);
            if ((!table.equals("po_invoice") && !table.equals("po_invoice_b")) || !fieldCode.equals("iprintcount")) {
              String describtion = RelatedTableVO.getJoinTableDescription(table);
              if (describtion != null)
                tableVO.addElement(describtion);
            }
          }
          continue;
        }
        // /得到表名
        int index = fieldCode.indexOf(".", 1);
        String table = null;
        if (index > 0) {
          table = fieldCode.substring(0, index);
          if ((!table.equals("po_invoice") && !table.equals("po_invoice_b")) || !fieldCode.equals("iprintcount")) {
            String describtion = RelatedTableVO.getJoinTableDescription(table);
            if (describtion != null)
              tableVO.addElement(describtion);
          }
        }
        if (index < 0 && fieldCode.equals("iprintcount")) {
          condStr += " AND po_invoice.iprintcount  " + definedVOs[i].getOperaCode() + definedVOs[i].getValue();
        }
        else {
          condStr += definedVOs[i].getSQLStr();
        }

      }
      // strDefined = " AND (" + definedVOs[0].getSQLStr(definedVOs) +
      // ")";
    }

    // 加入基础表连接
    // String strJoinTable = tableVO.getBaseTableJoin();
    // tableVO.setBaseTableJoin(strJoinTable);
    // 获得From和Where子句
    condStr = "FROM " + StringUtil.replaceAllString(tableVO.getFromTable(), "INNER", "LEFT") + " WHERE " + condStr;

    return condStr;
  }

  /**
   * 此处插入方法说明。 功能描述:处理查询条件的包含关系 输入参数: 返回值: 异常处理: 日期:
   * 
   * @return nc.vo.pub.query.ConditionVO[]
   */
  private ConditionVO[] dealAreaForVendor(ConditionVO[] cons, String pk_corp) throws BusinessException {
    /** ********************************************************** */
    // 构造形如:( (bd_areacl.areaclcode = '01') or (bd_areacl.areaclcode =
    // '0301') or
    // (bd_areacl.areaclcode = '030101') or (bd_areacl.areaclcode =
    // '030101') )
    // 的条件
    /** *********************************************************** */

    ConditionVO[] vos = null;
    try {
      Vector v = new Vector();
      for (int i = 0; cons != null && i < cons.length; i++) {

        // 处理供应商所在地区查询条件
        if (cons[i].getOperaCode().equalsIgnoreCase("in") || !cons[i].getFieldCode().equals("bd_areacl.areaclcode")) {
          v.add(cons[i]);
        }
        else {
          nc.bs.pu.pub.PubDMO dmo = new nc.bs.pu.pub.PubDMO();
          String[] areaCodes = dmo.getSubAreaCodes(pk_corp, cons[i].getValue(), cons[i].getOperaCode());
          for (int j = 0; j < areaCodes.length; j++) {

            ConditionVO con = (ConditionVO) cons[i].clone();
            if (j == 0) {
              con.setNoLeft(false);
            }
            else {
              con.setNoLeft(true);
            }
            con.setOperaCode("=");
            con.setValue(areaCodes[j]);

            // if(cons.length==1) {
            // if(j==areaCodes.length -1) {
            // con.setNoRight(false);
            // }else {
            // con.setNoRight(true);
            // }
            // }

            if (j > 0) {
              con.setLogic(false);
            }
            v.add(con);
          }
        }

      }
      if (v.size() > 0) {
        vos = new ConditionVO[v.size()];
        v.copyInto(vos);
      }
    }
    catch (Exception e) {

      PubDMO.throwBusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
          "UPP40040401-000070")/*
                                 * @res "查询供应商地区出现错误!"
                                 */, e);
    }
    return vos;
  }

  /**
   * 此处插入方法说明。 功能描述:处理查询条件的包含关系 输入参数: 返回值: 异常处理: 日期:
   * 
   * @return nc.vo.pub.query.ConditionVO[]
   */
  private ConditionVO[] dealContainRelation(ConditionVO[] cons) {
    for (int i = 0; cons != null && i < cons.length; i++) {
      // 处理包含关系
      if (cons[i].getOperaCode().equalsIgnoreCase("like")) {
        if (!cons[i].getValue().startsWith("%"))
          cons[i].setValue("%" + cons[i].getValue());
        // 后面的"%"模板加
      }
    }
    return cons;
  }

  /**
   * 此处插入方法说明。 功能描述:处理查询条件的包含关系 输入参数: 返回值: 异常处理: 日期:
   * 
   * @return nc.vo.pub.query.ConditionVO[]
   */
  private ConditionVO[] dealInvoiceType(ConditionVO[] cons) {
    for (int i = 0; cons != null && i < cons.length; i++) {
      // 处理发票类型ComboBox返回值.
      if (cons[i].getFieldCode().equals("po_invoice.iinvoicetype")) {
        cons[i].setDataType(1);
        if(cons[i].getValue().equals(
            NCLangResOnserver.getInstance().getStrByID(nc.vo.scm.pu.InvoiceType.m_sModuleNamePath,nc.vo.scm.pu.InvoiceType.INVOICE_TYPE_SPECIALID ))) {
          cons[i].setValue("0");
        }
        if(cons[i].getValue().equals(
            NCLangResOnserver.getInstance().getStrByID(nc.vo.scm.pu.InvoiceType.m_sModuleNamePath,nc.vo.scm.pu.InvoiceType.INVOICE_TYPE_GENERALID ))) {
          cons[i].setValue("1");
        }
        if(cons[i].getValue().equals(
            NCLangResOnserver.getInstance().getStrByID(nc.vo.scm.pu.InvoiceType.m_sModuleNamePath,nc.vo.scm.pu.InvoiceType.INVOICE_TYPE_DEFINEID ))) {
          cons[i].setValue("2");
        }
        if(cons[i].getValue().equals(
            NCLangResOnserver.getInstance().getStrByID(nc.vo.scm.pu.InvoiceType.m_sModuleNamePath,nc.vo.scm.pu.InvoiceType.INVOICE_TYPE_VIRTUALID ))) {
          cons[i].setValue("3");
        }
        if (cons[i].getValue().equals(
            NCLangResOnserver.getInstance().getStrByID(nc.vo.scm.pu.InvoiceType.m_sModuleNamePath,nc.vo.scm.pu.InvoiceType.INVOICE_TYPE_OTHERID ))) {
          cons[i].setValue("4"); //其它
        }     
      }
      
    }
    return cons;
  }

  /**
   * 作者：王印芬 功能：根据发票VO及参数作废批发票，同时进行回写操作 备注：该方法为平台注册方法，请不要随意删除与修改；修改后请通知脚本，作相应修改。
   * 参数：InvoiceVO[] voaInvoice 需作废的发票VO数组 Object[] oaParaList
   * 参数，真实数据结构为ArrayList. paraList[i][0] 数量容差值，结构为Object[][3] Object[][0]
   * 订单ID(String) Object[][1] 对应订单ID的数量容差下限(UFDouble) Object[][2]
   * 对应订单ID的数量容差上限(UFDouble) 返回：无 例外：Exception 删除过程中的系统及业务异常 日期：(2002-4-28
   * 11:39:21) 修改日期，修改人，修改原因，注释标志：
   */
  public void discardInvoiceArray(InvoiceVO[] voaInvoice, Object[] oaParaList) throws BusinessException {
    // 作废发票:同时进行回写采购订单、委外订单、库存采购入库单
    int iLen = voaInvoice.length;
    String[] sCinvoiceId = new String[iLen];
    for (int i = 0; i < iLen; i++) {
      sCinvoiceId[i] = voaInvoice[i].getHeadVO().getCinvoiceid();
    }

    InvoiceVO writeBackVo = new InvoiceVO();

    try {
      IICToPU_VmiSumDMO oInstance = (IICToPU_VmiSumDMO) NCLocator.getInstance().lookup(
          IICToPU_VmiSumDMO.class.getName());
      InvoiceDMO dmoInvoice = new InvoiceDMO();

      // 作废表头
      dmoInvoice.deleteHIdArray(sCinvoiceId);
      // 得到所有表体
      HashMap hRet = dmoInvoice.findItemsByPrimaryKeys(sCinvoiceId);
      // beanOrder = getBean_Order();
      for (int i = 0; i < iLen; i++) {

        InvoiceVO invVO = voaInvoice[i];
        // if (sBillType != null &&
        // !sBillType.equals(nc.vo.pu.pub.BillTypeConst.STORE_PO))
        // 作数量容差检验
        // if (!isInDiscardPresRange(invVO, (Object[][])
        // realParaList.get(0)))
        // return;
        // 作废发票
        InvoiceHeaderVO headVO = invVO.getHeadVO();
        // 删除标志
        headVO.setDr(new Integer(1));
        // 得到所有表体
        InvoiceItemVO[] items = (InvoiceItemVO[]) hRet.get(headVO.getCinvoiceid());
        for (int j = 0; j < items.length; j++) {
          items[j].setStatus(VOStatus.DELETED);
        }
        // 回写VMI累计开票数量
        String sourcebilltype = items[0].getCsourcebilltype();
        if (sourcebilltype != null && sourcebilltype.equalsIgnoreCase("50")) {
          Object[][] rowinfo = null;
          rowinfo = new Object[items.length][2];
          for (int k = 0, loopk = items.length; k < loopk; k++) {
            rowinfo[k][0] = items[k].getCsourcebillid();
            rowinfo[k][1] = items[k].getNinvoicenum().multiply(-1);
          }

          oInstance.writeBackTotalInvoiceNum(rowinfo);
        }
        // 回写操作
        writeBackVo.setChildrenVO(items);
        writeBackVo.setParentVO(headVO);
        writeBackVo.setUserConfirmFlag(voaInvoice[i].getUserConfirmFlag());
        //设置表体费用存货标志 For V56
        setFeeFlag(writeBackVo);
        //For V56 by zhaoyha
        //根据不同的来源类型进行分单
        InvoiceVO[] splittedWriteBackVOs=(InvoiceVO[])SplitBillVOs.getSplitVOs(InvoiceVO.class.getName(),
            InvoiceHeaderVO.class.getName(), InvoiceItemVO.class.getName(), new InvoiceVO[]{writeBackVo},
            null,    new String[] {"cupsourcebilltype","bfeeflag"});
        for(InvoiceVO splittedVO:splittedWriteBackVOs)
          writeBackBill(splittedVO);
        
      }
      // 作废表体
      dmoInvoice.deleteBIdArrayForHIdArray(sCinvoiceId);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.discardInvoiceArray(InvoiceVO[] , Object[] )", e);
    }
  }

  /**
   * 作者：王印芬 功能：作废结算单时作废相应受托代销存货的发票 该功能为结算单提供，请不要随意删除及修改 参数： String[] saInvoiceId
   * 发票ID数组 返回：无 例外： 日期：(2002-6-10 9:23:11) 修改日期，修改人，修改原因，注释标志：
   */
  public void discardInvoiceForSettle(String[] saInvoiceId) throws BusinessException {
    // 参数正确性检查
    if (saInvoiceId == null || saInvoiceId.length == 0) {
      SCMEnv.out("nc.bs.pi.InvoiceBO.discardInvoiceForSettle(String [])传入参数为空，不正确！");
      return;
    }
    int iLen = saInvoiceId.length;
    for (int i = 0; i < iLen; i++) {
      if (saInvoiceId[i] == null || saInvoiceId[i].trim().length() == 0) {
        SCMEnv.out("nc.bs.pi.InvoiceBO.discardInvoiceForSettle(String [])传入参数数组中有为空的元素！");
        return;
      }
    }
    // 进行操作
    try {
      // 判断是否可作废
      for (int i = 0; i < iLen; i++) {
        isASettledInvoiceCouldBeDiscarded(saInvoiceId[i]);
      }
      InvoiceDMO dmoInvoice = new InvoiceDMO();
      // 作废表头及表体
      dmoInvoice.deleteHIdArray(saInvoiceId);
      dmoInvoice.deleteBIdArrayForHIdArray(saInvoiceId);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.piInvocieImpl.discardInvoiceForSettle(String[])", e);
    }
  }

  /**
   * 作者：王印芬 功能：作废结算单时作废相应虚拟发票发票 该功能是为结算单提供的接口，请不要随意删除及修改 参数： String[]
   * saInvoiceId 虚拟发票ID数组 本处不作参数是否是虚拟发票的检查，则结算负责参数的正确性 返回：无 例外： 日期：(2002-6-10
   * 9:23:11) 修改日期，修改人，修改原因，注释标志：
   */
  public void discardVirtualInvoiceForSettle(String[] saInvoiceId) throws BusinessException {
    discardInvoiceForSettle(saInvoiceId);
  }

  /**
   * 作者：王印芬 功能：对一张发票进行结算 参数： InvoiceVO invVO 需审批的发票VO int nSource
   * 该发票来自订单还是入库单的标志,两个值:InvoiceVO.FROM_STO,InvoiceVO.FROM_ORDER ArrayList
   * paraList 结算需要的参数,结构如下: String sSettleRule 业务类型核算规则 0当前日期,1是否集团 返回：返回待解锁的IDs
   * ArrayList 例外：BusinessException 其中包裹BusinessException及SystemException异常
   * 日期：(2001-6-9 12:42:34) 修改日期，修改人，修改原因，注释标志： 2002-05-27 王印芬 修正因辅计量不存在导致的空指针错误
   * 2002-05-29 王印芬 找不到代码时报给用户代码错误 2004-02-19 WYF 修改bean.remove()的处理
   */
  private ArrayList doSettle(InvoiceVO vo, int nSource, ArrayList paraList, String sSettleRule,String strOprType)
      throws BusinessException {

    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("采购发票自动结算 doSettle 操作开始");

    String sMethodName = "nc.bs.pi.InvoiceBO.doSettle(InvoiceVO, int, ArrayList)";

    InvoiceItemVO[] items = vo.getBodyVO();
    ArrayList arrRet = null;
    InvoiceVO settleVO = new InvoiceVO();
    settleVO.setParentVO(vo.getParentVO());

    // 是否从订单转入
    boolean isFromOrder = false;
    for (int i = 0; i < items.length; i++) {
      if (items[i].getCupsourcebilltype() != null
          && (items[i].getCupsourcebilltype().equals(nc.vo.scm.constant.ScmConst.PO_Order) || items[i]
              .getCupsourcebilltype().equals(nc.vo.scm.constant.ScmConst.SC_Order))) {
        isFromOrder = true;
        break;
      }
    }
    
    //过滤掉发票行和相应的入库单行上的非成本计算仓
    List<InvoiceItemVO> filtedItems= null;
    if(isFromOrder)
      filtedItems=filteUncalculateInvCost(items,InvoiceVO.FROM_ORDER);
    else
      filtedItems=filteUncalculateInvCost(items,nSource);
    if(filtedItems.size()>0){
      settleVO.setChildrenVO(filtedItems.toArray(new InvoiceItemVO[0]));
    }
    else{
      arrRet = new ArrayList();
      arrRet.add(null);
      arrRet.add(UFBoolean.TRUE);
      return arrRet;
    }

    try {

      // 公用DMO
      nc.bs.pu.pub.PubDMO dmoPuPub = new nc.bs.pu.pub.PubDMO();

      // 如果存在非成本计算的仓库发票不自动结算
      // 仓库Id
//      int rowSize = items.length;
//      String[] sStoreId = new String[rowSize];
//      ArrayList arrVO = new ArrayList();
//      InvoiceItemVO[] tempItems = null;
//      for (int i = 0; i < rowSize; i++) {
//        sStoreId[i] = items[i].getCwarehouseid();
//        if (sStoreId[i] == null)
//          sStoreId[i] = " ";
//      }
//      Object[][] oIsCostCal = dmoPuPub.queryArrayValue("bd_stordoc", "pk_stordoc", new String[] {
//        "iscalculatedinvcost"
//      }, sStoreId, null);
//      if (oIsCostCal != null && oIsCostCal.length > 0) {
//        for (int i = 0; i < rowSize; i++) {
//          if (oIsCostCal[i] != null && oIsCostCal[i][0] != null && oIsCostCal[i][0].toString().equals("N"))
//            continue;
//          else
//            arrVO.add(items[i]);
//        }
//        if (arrVO.size() == 0) {
//          ArrayList list = new ArrayList();
//          list.add(null);
//          list.add(new UFBoolean(false));
//          return list;
//        }
//        else {
//          tempItems = new InvoiceItemVO[arrVO.size()];
//          arrVO.toArray(tempItems);
//          // items = tempItems;
//          // vo.setChildrenVO(tempItems);
//          settleVO.setChildrenVO(tempItems);
//        }
//      }
//      else {
//        settleVO.setChildrenVO(items);
//      }
      // 核算规则为供应商管理库存类，不进行结算
      // 核算规则
      // Object[][] oRule =
      // dmoPuPub.queryResultsFromAnyTable(
      // "bd_busitype",
      // new String[] { "verifyrule" },
      // "pk_busitype='" + vo.getHeadVO().getCbiztype() + "'");
      // if (oRule == null || oRule[0][0] == null) {
      // throw new BusinessException("未找到该单据业务类型对应核算规则!");
      // }
      // if (sSettleRule.trim().equals("V")) {
      // return null;
      // }

      timer.addExecutePhase("获取核算规则");

      // 直运业务类型的订单结算单作废后再保存时还需结算,入库单则只有生成发票时才需结算,其他情况不用
      // if (!isFromOrder && nSource != InvoiceVO.FROM_STO)
      // return null;

      // 从订单转入的直运类核算规则的业务结算
      if (isFromOrder) {
        arrRet = settleForOrder(settleVO, sSettleRule, paraList, strOprType);
        timer.addExecutePhase("settleForOrder method");
        // 直接从入库单转入发票的自动结算
      }
      else if (nSource == InvoiceVO.FROM_STO) {
        arrRet = settleForSto(settleVO, paraList, strOprType);
        timer.addExecutePhase("settleForSto method");
      }
      else if (nSource == InvoiceVO.FROM_VMI) {
        arrRet = settleForVMI(settleVO, paraList, strOprType);
        timer.addExecutePhase("settleForSto method");
      }

      // 得到累计结算数量及金额
      String[] sCinvoice_bId = new String[vo.getBodyVO().length];
      for (int i = 0; i < vo.getBodyVO().length; i++) {
        sCinvoice_bId[i] = vo.getBodyVO()[i].getCinvoice_bid();
      }
      Object[][] ob = (Object[][]) dmoPuPub.queryArrayValue("po_invoice_b", "cinvoice_bid", new String[] {
          "naccumsettnum", "naccumsettmny"
      }, sCinvoice_bId, "po_invoice_b.dr=0");
      for (int i = 0; i < vo.getBodyVO().length; i++) {
        if (ob == null || ob[i] == null) {
          SCMEnv.out("未找到某发票行ID=" + vo.getBodyVO()[i].getCinvoice_bid() + "累计结算数量或金额时未找到!");
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000071")/*
                                     * @res "未找到某发票行的累计结算数量或金额！"
                                     */);
        }
        vo.getBodyVO()[i].setNaccumsettnum(ob[i][0] == null ? null : new UFDouble(ob[i][0].toString()));
        vo.getBodyVO()[i].setNaccumsettmny(ob[i][1] == null ? null : new UFDouble(ob[i][1].toString()));
      }

      timer.showAllExecutePhase("采购发票自动结算 doSettle 操作结束");

    }
    catch (Exception e) {

      PubDMO.throwBusinessException(sMethodName, e);
    }
    return arrRet;
  }

  /**
   * 作者：汪维敏 功能：审批时进行结算（批处理） 参数： 返回:返回待解锁的IDs ArrayList 例外： 日期：(2004-5-9
   * 13:57:53) 修改日期，修改人，修改原因，注释标志：
   */
  public ArrayList doSettleArray(InvoiceVO[] vos, String sDate) throws BusinessException {
    if (vos == null || vos.length == 0 || sDate == null)
      return null;
    //For V56 by zhaoyha
    //根据不同的来源类型进行分单
     vos=(InvoiceVO[])SplitBillVOs.getSplitVOs(InvoiceVO.class.getName(),
        InvoiceHeaderVO.class.getName(), InvoiceItemVO.class.getName(), vos,
        new String[]{"cinvoiceid"},    new String[] {"cupsourcebilltype"});
     
    // 需要加锁的入库单ID
    ArrayList arrRet = new ArrayList();
    InvoiceHeaderVO hVO = vos[0].getHeadVO();
    // 参数：入库单转发票时的自动结算配置
    String sSettleParaForGeneral = null;
    // 参数：订单转发票时的自动结算配置
    String sSettleParaForOrder = null;
    // 参数：VMI转发票时的自动结算配置
    String sSettleParaForVMI = null;
    // 参数：直运销售转发票时的自动结算配置
    String sSettleParaForSO = null;
    //
    String pk_corp = null;
    ArrayList arrPara = new ArrayList();
    String temp = null;
    if (sDate.length() > 10)
      temp = sDate.substring(0, 10);
    arrPara.add(new UFDate(temp));
    arrPara.add(new UFBoolean(false));
    arrPara.add(new UFBoolean(true));
    try {
      // 系统DMO
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      pk_corp = hVO.getPk_corp();
      // 获取参数
      sSettleParaForGeneral = initDMO.getParaString(pk_corp, "PO30");
      sSettleParaForOrder = initDMO.getParaString(pk_corp, "PO46");
      sSettleParaForVMI = initDMO.getParaString(pk_corp, "PO77");
      sSettleParaForSO = initDMO.getParaString(pk_corp, "PO79");

      if (sSettleParaForGeneral == null || sSettleParaForGeneral.length() == 0)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000068")/*
                                   * @res "无法获取参数，不知道入库单转发票时是否要立即结算！"
                                   */);
      if (sSettleParaForOrder == null || sSettleParaForOrder.length() == 0)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000069")/*
                                   * @res "无法获取参数，不知道采购订单转发票时是否要立即结算！"
                                   */);
      if (sSettleParaForVMI == null || sSettleParaForVMI.length() == 0)
        throw new BusinessException("无法获取参数，不知道消耗汇总转发票时是否要立即结算！");
      if (sSettleParaForSO == null || sSettleParaForSO.length() == 0)
        throw new BusinessException("无法获取参数，不知道直运销售转发票时是否要立即结算！");

      // 核算规则
      String cinvoiceid[] = new String[vos.length];
      for (int i = 0; i < vos.length; i++) {
        cinvoiceid[i] = vos[i].getHeadVO().getCinvoiceid();
      }
      InvoiceDMO dmo = new InvoiceDMO();
      Hashtable h = dmo.queryVerifyRuleAndBillStatus(cinvoiceid);
      if (h == null || h.size() == 0) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000072")/*
                                   * @res "未找到该单据业务类型对应核算规则!"
                                   */);
      }
      int size = vos.length;

      // 哈希表{业务类型主键=是否无入库环节(需要自动结算)}
      ArrayList<String> listBizTypeId = new ArrayList<String>();
      String strBizTypeId = null;
      for (int i = 0; i < size; i++) {
        strBizTypeId = vos[i].getHeadVO().getCbiztype();
        if (strBizTypeId == null) {
          continue;
        }
        Object oTemp = h.get(vos[i].getHeadVO().getCinvoiceid());
        if (oTemp == null) {
          continue;
        }
        Object data[] = (Object[]) oTemp;
        String verifyrule = (String) data[1];
        if ("Z".equals(verifyrule) && !listBizTypeId.contains(strBizTypeId)) {
          listBizTypeId.add(strBizTypeId);
        }
      }
      Hashtable<String, UFBoolean> mapBizAutoSettle = null;
      if (listBizTypeId.size() > 0) {
        String[] saBiztypeId = listBizTypeId.toArray(new String[listBizTypeId.size()]);
        mapBizAutoSettle = new PubDMO().getNoStoreStepHash(saBiztypeId);
      }
      if (mapBizAutoSettle == null) {
        mapBizAutoSettle = new Hashtable<String, UFBoolean>();
      }
      //
      SettleImpl beanSettle = new SettleImpl();
      for (int i = 0; i < size; i++) {
        InvoiceItemVO[] items = vos[i].getBodyVO();
        if (items == null || items.length <= 0)
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000073")/* @res "不存在表体行！" */);
        // 来源单据类型,虚拟发票不结算
        String sUpSourceBillType = items[0].getCupsourcebilltype();

        // since v55, 修正缺陷：如果本张发票的第一行即为自制的费用行，则其它存货行也没有机会参与自动结算了
        if (PuPubVO.getString_TrimZeroLenAsNull(sUpSourceBillType) == null) {
          for (InvoiceItemVO item : items) {
            sUpSourceBillType = item.getCupsourcebilltype();
            if (PuPubVO.getString_TrimZeroLenAsNull(sUpSourceBillType) != null) {
              break;
            }
          }
        }
        //
        Object oTemp = h.get(vos[i].getHeadVO().getCinvoiceid());
        if (oTemp == null)
          continue;
        Object data[] = (Object[]) oTemp;
        if (sUpSourceBillType != null && sUpSourceBillType.trim().length() > 0
            && vos[i].getHeadVO().getIinvoicetype().intValue() != 3) {
          String[] sRet = null;
          String verifyrule = (String) data[1];
          Integer billstatus = new Integer(data[0].toString());
          // 来源于入库单{45、47、4T}
          if (sUpSourceBillType.equals("45") || sUpSourceBillType.equals("47") || sUpSourceBillType.equals("4T")) {
            if (sSettleParaForGeneral.equals("审批时自动结算") && !verifyrule.equals("S") && !verifyrule.equals("N")
                && billstatus.intValue() == BillStatus.AUDITED.intValue()) {
              // 结算(加锁)
              arrRet = doSettle(vos[i], InvoiceVO.FROM_STO, arrPara, verifyrule, SettlebillVO.OPR_TYPE_APPROVE);
            }
          }
          // 来源于采购订单{21}
          else if (sUpSourceBillType.equals(ScmConst.PO_Order)) {
            if (!verifyrule.equals("N") && billstatus.intValue() == BillStatus.AUDITED.intValue()) {
              if (!"Z".equalsIgnoreCase(verifyrule)) {
                if (sSettleParaForOrder.equals("审批时自动结算")) {
                  arrRet = doSettle(vos[i], InvoiceVO.FROM_STO, arrPara, verifyrule, SettlebillVO.OPR_TYPE_APPROVE);
                }
              }
              // "Z"属性分两种情况：{无入库环节、有入库环节}
              else {
                // 无入库环节
                if (mapBizAutoSettle.containsKey(vos[i].getHeadVO().getCbiztype())
                    && mapBizAutoSettle.get(vos[i].getHeadVO().getCbiztype()).booleanValue()) {
                  if ("审批时自动结算".equals(sSettleParaForSO)) {
                    arrRet = doSettle(vos[i], InvoiceVO.FROM_STO, arrPara, verifyrule, SettlebillVO.OPR_TYPE_APPROVE);
                  }
                }
                else if ("审批时自动结算".equals(sSettleParaForOrder)) {

                  arrRet = beanSettle.doOrderToInvoiceSettle(new InvoiceVO[] { vos[i] }, arrPara, SettlebillVO.OPR_TYPE_APPROVE);
                  // 查询发票的累计结算数量/累计结算金额
//                  InvoiceDMO dmoInvoice = new InvoiceDMO();
//                  InvoiceItemVO[] tempBodyVO = null;
//                  // 没有结算不需查询
//                  ArrayList list = null;
//                  if (arrRet != null && arrRet.size() > 0)
//                    list = (ArrayList) arrRet.get(0);
//                  if (list != null && list.size() > 0)
//                    tempBodyVO = dmoInvoice.findItemsForHeader(invVO.getHeadVO().getCinvoiceid());
//                  if (tempBodyVO != null && tempBodyVO.length > 0){
//                    invVO.setChildrenVO(tempBodyVO);
//                  }
                  
                  //arrRet = doSettle(vos[i], InvoiceVO.FROM_STO, arrPara, verifyrule);
                }
              }
            }
          }
          // 来源于消耗汇总{50}
          else if (sUpSourceBillType.equals("50")) {
            if (sSettleParaForVMI.equals("审批时自动结算") && billstatus.intValue() == BillStatus.AUDITED.intValue()) {
              // 结算(加锁)
              arrRet = doSettle(vos[i], InvoiceVO.FROM_VMI, arrPara, verifyrule, SettlebillVO.OPR_TYPE_APPROVE);
            }
          }
          // 解锁
          UFBoolean bSucceed = new UFBoolean(false);
          ArrayList arrJS = null;
          if (arrRet != null && arrRet.size() > 0) {
            bSucceed = (UFBoolean) arrRet.get(1);
            arrJS = (ArrayList) arrRet.get(0);
          }
          if (arrJS != null && arrJS.size() > 0) {
            sRet = new String[arrJS.size()];
            arrJS.toArray(sRet);
            LockTool.releaseLockForPks(sRet, vos[i].getHeadVO().getCauditpsn());
          }
          if ((sUpSourceBillType.equals("45") || sUpSourceBillType.equals("47") || sUpSourceBillType.equals("4T"))
              && sSettleParaForGeneral.equals("审批时自动结算") && !verifyrule.equals("S") && !verifyrule.equals("N")
              && !bSucceed.booleanValue() && billstatus.intValue() == BillStatus.AUDITED.intValue()) {
            // 来源于入库单,结算失败,抛错
            throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040502",
                "UPP40040502-000093")/*
                                       * @res "结算失败！"
                                       */);
          }
          if (sUpSourceBillType.equals("50") && sSettleParaForVMI.equals("审批时自动结算") && !bSucceed.booleanValue()
              && billstatus.intValue() == BillStatus.AUDITED.intValue()) {
            // 来源于VMI,结算失败,抛错
            throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040502",
                "UPP40040502-000093")/*
                                       * @res "结算失败！"
                                       */);
          }
        }
      }
    }
    catch (Exception e) {
      PubDMO.throwBusinessException(e);
    }
    return arrRet;
  }

  /**
   * 作者：王印芬 功能：滤掉虚拟发票 该函数为平台注册函数，用于判断向应付传数据时，虚拟发票不可传 请不要随意修改及删除该方法，否则将导致平台运行不正确
   * 参数：InvoiceVO[] voaInv 发票VO数组 返回：InvoiceVO[] 滤掉虚拟发票的发票VO数组
   * 例外：BusinessException 参数不正确时抛出 日期：(2002-6-14 11:39:21) 修改日期，修改人，修改原因，注释标志：
   * 2002-09-27 wyf 修改对虚拟的判断，采用函数
   */
  public InvoiceVO[] filterVirtualInvoice(InvoiceVO[] voaInv) throws BusinessException {

    // 参数正确性检查
    if (voaInv == null) {
      SCMEnv.out("nc.bs.pi.InvoiceBO.isVirtual(InvoiceVO)传入参数不正确！");
      throw new BusinessException("nc.bs.pi.InvoiceBO.isVirtual(InvoiceVO)  Exception!", new BusinessException(
          nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000074")/*
                                                                                                 * @res
                                                                                                 * "需检验的发票为空或缺少相关数据项，无法检验发票是否为虚拟发票！"
                                                                                                 */));
    }
    // Vector vValidInv = new Vector();
    int iLen = voaInv.length;
    for (int i = 0; i < iLen; i++) {
      if (voaInv[i] == null || voaInv[i].getHeadVO() == null || voaInv[i].getHeadVO().getIinvoicetype() == null) {
        SCMEnv.out("nc.bs.pi.InvoiceBO.isVirtual(InvoiceVO)传入参数不正确！");
        throw new BusinessException("nc.bs.pi.InvoiceBO.isVirtual(InvoiceVO)  Exception!", new BusinessException(
            nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000074")/*
                                                                                                   * @res
                                                                                                   * "需检验的发票为空或缺少相关数据项，无法检验发票是否为虚拟发票！"
                                                                                                   */));
      }
      // 过滤时,不重新组织一个新数组,而是将原来数组中被过滤掉的发票设置为null
      if (voaInv[i].isVirtual())
        voaInv[i] = null;
    }
    return voaInv;
  }

  /**
   * 发票审批，组织暂估应付冲减VO, 调用应付的调差接口, 冲减暂估应付
   */
  public void adjustForZGYF(InvoiceVO[] voaInv) throws BusinessException {

    try {
      // 参数正确性检查
      if (voaInv == null || voaInv.length == 0) {
        return;
      }
      for (int i = 0; i < voaInv.length; i++) {
        if (voaInv[i] == null)
          return;
      }

      // 得到每个发票体id对应的发票头id,发票头id对应的审批日期和审批人
      Hashtable htHeadId = new Hashtable();
      Hashtable htAuditPsnId = new Hashtable();
      Hashtable htAuditDate = new Hashtable();
      InvoiceItemVO[] aInvoiceItemVOs = null;
      InvoiceHeaderVO aInvoiceHeaderVO = null;
      for (int i = 0; i < voaInv.length; i++) {

        aInvoiceHeaderVO = (InvoiceHeaderVO) voaInv[i].getParentVO();

        htAuditPsnId.put(aInvoiceHeaderVO.getCinvoiceid(), aInvoiceHeaderVO.getCauditpsn());
        htAuditDate.put(aInvoiceHeaderVO.getCinvoiceid(), aInvoiceHeaderVO.getDauditdate());

        aInvoiceItemVOs = (InvoiceItemVO[]) voaInv[i].getChildrenVO();
        if (aInvoiceItemVOs == null || aInvoiceItemVOs.length == 0) {
          continue;
        }

        for (int j = 0; j < aInvoiceItemVOs.length; j++) {
          htHeadId.put(aInvoiceItemVOs[j].getCinvoice_bid(), aInvoiceItemVOs[j].getCinvoiceid());
        }

      }

      // 判断应付是否启用
      ICreateCorpQueryService myService0 = null;
      myService0 = (ICreateCorpQueryService) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ICreateCorpQueryService.class.getName());
      String unitCode = ((InvoiceHeaderVO) voaInv[0].getParentVO()).getPk_corp();
      boolean bAPStartUp = myService0.isEnabled(unitCode, "AP");
      if (!bAPStartUp) {
        return;
      }

      // 获取暂估应付冲减VO
      IAdjuestVO washVO[] = new InvoiceDMO().washDataForZGYF(voaInv);

      if (washVO != null && washVO.length > 0) {
        /*
         * 生成并回写发票的处理编号, since v502 since v53, 修改，解决如下问题：
         * 如果是来源于同一行入库单时，要拆分成多个处理编号处理，否则发票弃审时按处理编号+入库单行删除红冲单时会多删除单据!
         */
        ArrayList<ArrayList<IAdjuestVO>> listRepeatVos = getVos(washVO);
        // 按分好组的多组数据回冲
        if (listRepeatVos.size() > 0) {
          PubDMO dmo = new PubDMO();
          for (int i = 0; i < listRepeatVos.size(); i++) {
            washVO = listRepeatVos.get(i).toArray(new IAdjuestVO[listRepeatVos.get(i).size()]);
            adjustForZGYFOneByOne(washVO, unitCode, htHeadId, htAuditPsnId, htAuditDate, dmo);
          }
        }
      }
    }
    catch (Exception e) {
      /* 调用采购公用方法按规范抛出异常 */
      nc.bs.pu.pub.PubDMO.throwBusinessException(e);
    }
  }

  /*
   * 设置是否最后一次回冲并保存暂估应付红冲单据,since v53
   */
  private void adjustForZGYFOneByOne(IAdjuestVO[] washVO, String unitCode, Hashtable htHeadId, Hashtable htAuditPsnId,
      Hashtable htAuditDate, PubDMO dmo) throws Exception {
    // 通过washVO[]组织入库单行id[]及消耗汇总ID[]
    ArrayList<String> listGeneralBid = new ArrayList<String>();
    ArrayList<String> listVmiHid = new ArrayList<String>();
    for (int i = 0; i < washVO.length; i++) {
      if (washVO[i].isVmi()) {
        listVmiHid.add(washVO[i].getDdhh());
      }
      else {
        listGeneralBid.add(washVO[i].getDdhh());
      }
    }
    String[] saGeneralBid = new String[listGeneralBid.size()];
    listGeneralBid.toArray(saGeneralBid);
    String[] saVmiHid = new String[listVmiHid.size()];
    listVmiHid.toArray(saVmiHid);

    // 根据入库单行id[]去查询入库单表体上的暂估数量(实收数量)
    HashMap htInNum = new HashMap();
    if (saGeneralBid != null && saGeneralBid.length > 0) {
      htInNum = dmo.queryArrayValues("ic_general_b", "cgeneralbid", new String[] {
        "ninnum"
      }, saGeneralBid, "dr=0");
    }
    // 根据VMI头id[]去查询暂估数量(出库数量-出库退回数量)
    // For V56 适应库存VMI调整做相应修改 by zhaoyha
    HashMap htInNumVmi = new HashMap();
    if (saVmiHid != null && saVmiHid.length > 0) {
      htInNumVmi = dmo.queryArrayValues("ic_vmi_sum", "cvmihid", new String[] {
        "coalesce(nrsvnum1,0)"
      }, saVmiHid, "dr=0");
    }
    // 根据入库单行id[]去查询ic_general_bb3上的暂估应付累计回冲(结算)数量
    HashMap htAccumWashNum = new HashMap();
    if (saGeneralBid != null && saGeneralBid.length > 0) {
      htAccumWashNum = dmo.queryArrayValues("ic_general_bb3", "cgeneralbid", new String[] {
        "naccumwashnum"
      }, saGeneralBid, "dr=0");
    }
    // 根据VMI头id[]去查询累计回冲(结算)数量
    HashMap htAccumWashNumVmi = new HashMap();
    if (saVmiHid != null && saVmiHid.length > 0) {
      htAccumWashNumVmi = dmo.queryArrayValues("ic_vmi_sum", "cvmihid", new String[] {
        "naccumwashnum"
      }, saVmiHid, "dr=0");
    }
    // 根据 实收数量 ==? （累计回冲数量 + 本次回冲数量）来组织 是否最后一次冲减
    String strGeneralBid = null;
    String strInvoiceHid = null;
    String strAuditPsnId = null;
    UFDate ufdatAuditDate = null;
    String strVmiBid = null;

    Object objTemp = null;
    Object[] oaTemp = null;
    UFDouble ufdInNum = new UFDouble(0);
    UFDouble ufdAccumWashNum = new UFDouble(0);
    UFBoolean ufbLast[] = new UFBoolean[washVO.length];

    IArapForGYLPublic iArap = (IArapForGYLPublic) NCLocator.getInstance().lookup(IArapForGYLPublic.class.getName());
    InvoiceDMO invoiceDMO = new InvoiceDMO();
    //
    ArrayList<String> listIdBB3 = new ArrayList<String>();
    ArrayList<String> listIdVmi = new ArrayList<String>();
    ArrayList<UFDouble> listNumBB3 = new ArrayList<UFDouble>();
    ArrayList<UFDouble> listNumVmi = new ArrayList<UFDouble>();
    for (int i = 0; i < washVO.length; i++) {
      strVmiBid = null;
      strGeneralBid = null;
      if (washVO[i].isVmi()) {
        strVmiBid = washVO[i].getDdhh();
      }
      else {
        strGeneralBid = washVO[i].getDdhh();
      }
      if ((strGeneralBid == null || strGeneralBid.trim().length() == 0)
          && (strVmiBid == null || strVmiBid.trim().length() == 0)) {
        continue;
      }
      // 实收数量
      if (washVO[i].isVmi()) {
        objTemp = htInNumVmi.get(strVmiBid);
      }
      else {
        objTemp = htInNum.get(strGeneralBid);
      }
      if (objTemp != null) {
        oaTemp = (Object[]) objTemp;
        if (oaTemp.length > 0 && oaTemp[0] != null) {
          ufdInNum = new UFDouble(oaTemp[0].toString());
        }
      }
      // 累计回冲数量
      ufdAccumWashNum = washVO[i].getShl();
      if (washVO[i].isVmi()) {
        objTemp = htAccumWashNumVmi.get(strVmiBid);
      }
      else {
        objTemp = htAccumWashNum.get(strGeneralBid);
      }
      if (objTemp != null) {
        oaTemp = (Object[]) objTemp;
        if (oaTemp.length > 0 && oaTemp[0] != null) {
          ufdAccumWashNum = (new UFDouble(oaTemp[0].toString())).add(ufdAccumWashNum);
        }
      }
      if (washVO[i].isVmi()) {
        htAccumWashNum.put(strVmiBid, new UFDouble[] {
          ufdAccumWashNum
        });
      }
      else {
        htAccumWashNum.put(strGeneralBid, new UFDouble[] {
          ufdAccumWashNum
        });
      }
      // 是否最后一次冲减
      if (ufdInNum.doubleValue() == ufdAccumWashNum.doubleValue()) {
        ufbLast[i] = UFBoolean.TRUE;
      }
      else {
        ufbLast[i] = UFBoolean.FALSE;
      }

      // 根据发票体id查询发票头id
      objTemp = htHeadId.get(washVO[i].getCinvoice_bid());
      if (objTemp != null && objTemp.toString().trim().length() > 0) {
        strInvoiceHid = objTemp.toString();
      }
      //
      washVO[i].setCinvoiceid(strInvoiceHid);

      // 根据发票头id得到审批人和审批日期
      objTemp = htAuditPsnId.get(strInvoiceHid);
      if (objTemp != null && objTemp.toString().trim().length() > 0) {
        strAuditPsnId = objTemp.toString();
      }

      objTemp = htAuditDate.get(strInvoiceHid);
      if (objTemp != null && objTemp.toString().trim().length() > 0) {
        ufdatAuditDate = new UFDate(objTemp.toString());
      }
      //
      if (washVO[i].isVmi()) {
        listIdVmi.add(washVO[i].getDdhh());
        listNumVmi.add(washVO[i].getShl());
      }
      else {
        listIdBB3.add(washVO[i].getDdhh());
        listNumBB3.add(washVO[i].getShl());
      }

      washVO[i].setIsdone(ufbLast[i]);
    }
    //
    String strClbh = invoiceDMO.updateClbh(washVO, unitCode, null, false);
    /*
     * 调用应付提供的保存+冲减方法冲减暂估应付 后两个参数: lylx (来源类型 0 订单行ID 1 出库单行ID 2 发票行ID ly: 0 销售
     * 1 采购
     */
    iArap.Adjuest(washVO, strClbh, strAuditPsnId, ufdatAuditDate.toString(), unitCode, 1, 1);
    //
    // 回写ic_general_bb3上的暂估应付累计回冲数量
    String[] saDdhhBB3 = null;
    UFDouble[] uaNumBB3 = null;
    if (listIdBB3.size() > 0) {
      saDdhhBB3 = listIdBB3.toArray(new String[listIdBB3.size()]);
      uaNumBB3 = listNumBB3.toArray(new UFDouble[listNumBB3.size()]);
      invoiceDMO.updateAccumWashNumForIC(saDdhhBB3, uaNumBB3, true);
    }
    // 回写ic_vmi_sum上的暂估应付累计回冲数量
    String[] saDdhhVmi = null;
    UFDouble[] uaNumVmi = null;
    if (listIdVmi.size() > 0) {
      saDdhhVmi = listIdVmi.toArray(new String[listIdVmi.size()]);
      uaNumVmi = listNumVmi.toArray(new UFDouble[listNumVmi.size()]);
      invoiceDMO.updateAccumWashNumForVmi(saDdhhVmi, uaNumVmi, true);
    }
  }

  /*
   * since v53, 为本批量审批的采购发票重新分配处理编号，解决问题：有不同发票相同来源入库单行时，逐个弃审发票时会多删除单据。
   * 思路：1)、按发票头ID分组 2)、保证一个处理编号下不同发票间入库单行ID不同
   */
  private ArrayList<ArrayList<IAdjuestVO>> getVos(IAdjuestVO[] washVO) {

    // 按发票头ID分组
    int iLen = washVO.length;
    ArrayList<IAdjuestVO> listVosSameHid = new ArrayList<IAdjuestVO>();
    String strInvoiceHIdCur = null;
    Hashtable<String, ArrayList<IAdjuestVO>> mapVos = new Hashtable<String, ArrayList<IAdjuestVO>>(100);
    for (int i = 0; i < iLen; i++) {
      strInvoiceHIdCur = washVO[i].getCinvoiceid();
      listVosSameHid = mapVos.get(strInvoiceHIdCur);
      if (listVosSameHid == null) {
        listVosSameHid = new ArrayList<IAdjuestVO>();
      }
      listVosSameHid.add(washVO[i]);
      mapVos.put(strInvoiceHIdCur, listVosSameHid);
    }
    // 按发票头ID全部数据
    ArrayList<ArrayList<IAdjuestVO>> listDealingVos = new ArrayList<ArrayList<IAdjuestVO>>();
    int iSize = mapVos.size();
    Enumeration<String> keySet = mapVos.keys();
    int iPos = 0;
    while (keySet.hasMoreElements()) {
      listDealingVos.add(mapVos.get(keySet.nextElement()));
      iPos++;
    }
    // 初始数据(第一张发票)
    ArrayList<ArrayList<IAdjuestVO>> listResultVos = new ArrayList<ArrayList<IAdjuestVO>>();
    ArrayList<IAdjuestVO> listVosSameClbh = listDealingVos.get(0);
    listDealingVos.remove(0);
    listResultVos.add(listVosSameClbh);
    boolean bHasSame = false;
    // 待处理数据(除去了第一张发票)
    int j = 0;
    while (listDealingVos.size() > 0) {
      listVosSameHid = listDealingVos.get(0);
      listDealingVos.remove(0);
      bHasSame = false;
      // 已经分配好处理编号的数据(多个处理编号)
      for (j = 0; j < listResultVos.size(); j++) {
        listVosSameClbh = listResultVos.get(j);
        // 同一处理编号
        for (int k = 0; k < listVosSameClbh.size(); k++) {
          // 同一张发票的多行数据
          for (int i = 0; i < listVosSameHid.size(); i++) {
            if (listVosSameHid.get(i).getDdhh().equals(listVosSameClbh.get(k).getDdhh())) {
              bHasSame = true;
              break;
            }
          }
          if (bHasSame) {
            break;
          }
        }
        // 如果某个处理编号下的所有入库单行 与 要处理的整张发票的所有行记录的入库单行均不重复，则将此发票归依到此处理编号名下
        if (!bHasSame) {
          for (int i = 0; i < listVosSameHid.size(); i++) {
            listVosSameClbh.add(listVosSameHid.get(i));
          }
          break;
        }
      }
      // 存在相同的入库单行ID(不同发票)，另生成一个处理编号
      if (bHasSame) {
        listResultVos.add(listVosSameHid);
      }
    }
    return listResultVos;
  }

  /*
   * since v53, 为本批量审批的采购发票重新分配处理编号，解决问题：有不同发票相同来源入库单行时，逐个弃审发票时会多删除单据。
   * 思路：1)、按发票头ID分组 2)、保证一个处理编号下不同发票间入库单行ID不同
   */
  private ArrayList<ArrayList<IAdjuestVO>> getVos_Del(IAdjuestVO[] washVO) {

    // 按发票头ID分组
    int iLen = washVO.length;
    ArrayList<IAdjuestVO> listVosSameHid = new ArrayList<IAdjuestVO>();
    String strInvoiceHIdCur = null;
    Hashtable<String, ArrayList<IAdjuestVO>> mapVos = new Hashtable<String, ArrayList<IAdjuestVO>>(100);
    for (int i = 0; i < iLen; i++) {
      strInvoiceHIdCur = washVO[i].getCinvoiceid();
      listVosSameHid = mapVos.get(strInvoiceHIdCur);
      if (listVosSameHid == null) {
        listVosSameHid = new ArrayList<IAdjuestVO>();
      }
      listVosSameHid.add(washVO[i]);
      mapVos.put(strInvoiceHIdCur, listVosSameHid);
    }
    // 按发票头ID全部数据
    ArrayList<ArrayList<IAdjuestVO>> listDealingVos = new ArrayList<ArrayList<IAdjuestVO>>();
    int iSize = mapVos.size();
    Enumeration<String> keySet = mapVos.keys();
    int iPos = 0;
    while (keySet.hasMoreElements()) {
      listDealingVos.add(mapVos.get(keySet.nextElement()));
      iPos++;
    }
    // 初始数据(第一张发票)
    ArrayList<ArrayList<IAdjuestVO>> listResultVos = new ArrayList<ArrayList<IAdjuestVO>>();
    ArrayList<IAdjuestVO> listVosSameClbh = listDealingVos.get(0);
    listDealingVos.remove(0);
    listResultVos.add(listVosSameClbh);
    boolean bSameFlag = false;
    // 待处理数据(除去了第一张发票)
    while (listDealingVos.size() > 0) {
      listVosSameHid = listDealingVos.get(0);
      listDealingVos.remove(0);
      bSameFlag = false;
      // 同一张发票的多行数据
      for (int i = 0; i < listVosSameHid.size(); i++) {
        // 已经分配好处理编号的数据(多个处理编号)
        for (int j = 0; j < listResultVos.size(); j++) {
          listVosSameClbh = listResultVos.get(j);
          // 逐个处理编号处理
          for (int k = 0; k < listVosSameClbh.size(); k++) {
            if (listVosSameHid.get(i).getDdhh().equals(listVosSameClbh.get(k).getDdhh())) {
              bSameFlag = true;
              break;
            }
          }
          if (bSameFlag) {
            break;
          }
        }
      }
      // 存在相同的入库单行ID(不同发票)，另生成一个处理编号
      if (bSameFlag) {
        listResultVos.add(listVosSameHid);
      }
      // 不存在相同的入库单行ID(不同发票)，合并到同一个处理编号(合并进第一个处理编号)
      else {
        for (int i = 0; i < listVosSameHid.size(); i++) {
          listResultVos.get(0).add(listVosSameHid.get(i));
        }
      }
    }
    return listResultVos;
  }
  
  /**
   * @function 费用发票取消传应付
   *
   * @author ouyangzhb 
   *
   * @param voaInv
   * @throws BusinessException 
   *
   * @return void
   *
   * @date 2011-05-10 
   */
  public void unAdjustForFEEZGYF(InvoiceVO[] voaInv) throws BusinessException {

	    try {
	      // 参数正确性检查
	      if (voaInv == null || voaInv.length == 0) {
	        return;
	      }

	      // 得到每个发票体id对应的发票头id
	      Hashtable htHeadId = new Hashtable();

	      InvoiceItemVO[] aInvoiceItemVOs = null;
	      for (int i = 0; i < voaInv.length; i++) {
	        aInvoiceItemVOs = (InvoiceItemVO[]) voaInv[i].getChildrenVO();
	        if (aInvoiceItemVOs == null || aInvoiceItemVOs.length == 0) {
	          continue;
	        }

	        for (int j = 0; j < aInvoiceItemVOs.length; j++) {
	          htHeadId.put(aInvoiceItemVOs[j].getCinvoice_bid(), aInvoiceItemVOs[j].getCinvoiceid());
	        }

	      }

	      // 判断应付是否启用
	      ICreateCorpQueryService myService0 = null;
	      myService0 = (ICreateCorpQueryService) nc.bs.framework.common.NCLocator.getInstance().lookup(
	          ICreateCorpQueryService.class.getName());
	      String unitCode = ((InvoiceHeaderVO) voaInv[0].getParentVO()).getPk_corp();
	      boolean bAPStartUp = myService0.isEnabled(unitCode, "AP");
	      if (!bAPStartUp) {
	        return;
	      }

	      // 获取暂估应付冲减VO
	      IAdjuestVO washVO[] = new InvoiceDMO().antiWashDataForFEEZGYF(voaInv);
//	      IAdjuestVO[] washVO = new InvoiceDMO().antiWashDataForZGYF(voaInv);

	      if (washVO != null && washVO.length > 0) {

	        // 通过washVO[]组织应付单行id[]
	        String[] saFEEBid = new String[washVO.length];
	        for (int i = 0; i < washVO.length; i++) {
	        	saFEEBid[i] = washVO[i].getDdhh();
	        }

	        String strInvoiceHid = null;
	        Object objTemp = null;

	        InvoiceDMO invoiceDMO = new InvoiceDMO();
	        //
	        ArrayList<IAdjuestVO> listAdjuestVO = new ArrayList<IAdjuestVO>();
	        ArrayList<String> listInvoiceHid = new ArrayList<String>();
	        for (int i = 0; i < washVO.length; i++) {

	          // 根据发票体id查询发票头id
	          objTemp = htHeadId.get(washVO[i].getCinvoice_bid());
	          if (objTemp == null || objTemp.toString().trim().length() == 0) {
	            continue;
	          }
	          strInvoiceHid = objTemp.toString();
	          //
	          if (!listInvoiceHid.contains(strInvoiceHid)) {
	            listInvoiceHid.add(strInvoiceHid);
	          }
	          //
	          washVO[i].setCinvoiceid(strInvoiceHid);
	          listAdjuestVO.add(washVO[i]);

	          // 调用应付提供的保存+冲减方法冲减暂估应付
	          // iArap.unAdjuest(strInvoiceHid,unitCode);

	          // 回写ic_general_bb3上的暂估应付累计回冲数量
//	          if (washVO[i].isVmi()) {
//	            invoiceDMO.updateAccumWashNumForVmi(new String[] {
//	              washVO[i].getDdhh()
//	            }, new UFDouble[] {
//	              washVO[i].getShl()
//	            }, false);
//	          }
//	          else {
//	            invoiceDMO.updateAccumWashNumForIC(new String[] {
//	              washVO[i].getDdhh()
//	            }, new UFDouble[] {
//	              washVO[i].getShl()
//	            }, false);
//	          }
	        }
	        // 调用应付提供的保存+冲减方法冲减暂估应付
	        if (listAdjuestVO.size() > 0) {
	          Hashtable hashHidClbh = new PubDMO().queryHtResultFromAnyTable("po_invoice", "cinvoiceid", new String[] {
	            "clbh"
	          }, " cinvoiceid in " + new TempTableUtil().getSubSql(listInvoiceHid));
	          if (hashHidClbh != null && hashHidClbh.size() > 0) {
	            Map<String, Map<String, String>> clbhs = new HashMap<String, Map<String, String>>();
	            Map<String, String> mapDdhh = null;
	            String strClbh = null;
	            Vector vClbh = null;
	            IAdjuestVO voAdjust = null;
	            //把来源类型设置为3，以便在后面的查询中为其设置附加条件
	            String strLylx = "3";
	            ArrayList<IAdjuestVO> listAdjuestVos = new ArrayList<IAdjuestVO>();
	            for (int i = 0; i < listAdjuestVO.size(); i++) {
	              voAdjust = (IAdjuestVO) listAdjuestVO.get(i);
	              strInvoiceHid = voAdjust.getCinvoiceid();
	              vClbh = (Vector) hashHidClbh.get(strInvoiceHid);
	              if (vClbh == null || vClbh.size() == 0) {
	                continue;
	              }
	              strClbh = (String) ((Object[]) vClbh.get(0))[0];
	              if (PuPubVO.getString_TrimZeroLenAsNull(strClbh) == null) {
	                continue;
	              }
	              listAdjuestVos.add(voAdjust);
	              mapDdhh = clbhs.get(strClbh);
	              if (mapDdhh == null) {
	                mapDdhh = new HashMap<String, String>();
	              }
	              mapDdhh.put(voAdjust.getDdhh(), strLylx);
	              clbhs.put(strClbh, mapDdhh);
	            }
	            //
	            if (clbhs.size() > 0) {
	              IArapForGYLPublic iArap = (IArapForGYLPublic) NCLocator.getInstance().lookup(
	                  IArapForGYLPublic.class.getName());
	              iArap.unAdjuestForGC(clbhs, unitCode);
	            }

	            // 更新处理编号
	            if (listAdjuestVos.size() > 0) {
	              invoiceDMO.updateClbh(listAdjuestVO.toArray(new IAdjuestVO[listAdjuestVO.size()]), null, null, true);
	            }
	          }
	        }
	      }
	    }
	    catch (Exception e) {
	      PubDMO.throwBusinessException(e);
	    }
	  }
  

  /**
   * 发票弃审，组织暂估应付冲减VO, 调用应付的调差接口, 冲减暂估应付
   */
  public void unAdjustForZGYF(InvoiceVO[] voaInv) throws BusinessException {

    try {
      // 参数正确性检查
      if (voaInv == null || voaInv.length == 0) {
    	  
        return;
      }

      // 得到每个发票体id对应的发票头id
      Hashtable htHeadId = new Hashtable();

      InvoiceItemVO[] aInvoiceItemVOs = null;
      for (int i = 0; i < voaInv.length; i++) {
//    	  //add by ouyangzhb 2011-05-10 过滤费用发票
//    	  if(voaInv[i].getHeadVO().getVdef20()!=null&&voaInv[i].getHeadVO().getVdef20().equals("Y")){
//    		  return;
//    	  }

        aInvoiceItemVOs = (InvoiceItemVO[]) voaInv[i].getChildrenVO();
        if (aInvoiceItemVOs == null || aInvoiceItemVOs.length == 0) {
          continue;
        }

        for (int j = 0; j < aInvoiceItemVOs.length; j++) {
          htHeadId.put(aInvoiceItemVOs[j].getCinvoice_bid(), aInvoiceItemVOs[j].getCinvoiceid());
        }

      }

      // 判断应付是否启用
      ICreateCorpQueryService myService0 = null;
      myService0 = (ICreateCorpQueryService) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ICreateCorpQueryService.class.getName());
      String unitCode = ((InvoiceHeaderVO) voaInv[0].getParentVO()).getPk_corp();
      boolean bAPStartUp = myService0.isEnabled(unitCode, "AP");
      if (!bAPStartUp) {
        return;
      }

      // 获取暂估应付冲减VO
      IAdjuestVO[] washVO = new InvoiceDMO().antiWashDataForZGYF(voaInv);

      if (washVO != null && washVO.length > 0) {

        // 通过washVO[]组织入库单行id[]
        String[] saGeneralBid = new String[washVO.length];
        for (int i = 0; i < washVO.length; i++) {
          saGeneralBid[i] = washVO[i].getDdhh();
        }

        String strInvoiceHid = null;
        Object objTemp = null;

        InvoiceDMO invoiceDMO = new InvoiceDMO();
        //
        ArrayList<IAdjuestVO> listAdjuestVO = new ArrayList<IAdjuestVO>();
        ArrayList<String> listInvoiceHid = new ArrayList<String>();
        for (int i = 0; i < washVO.length; i++) {

          // 根据发票体id查询发票头id
          objTemp = htHeadId.get(washVO[i].getCinvoice_bid());
          if (objTemp == null || objTemp.toString().trim().length() == 0) {
            continue;
          }
          strInvoiceHid = objTemp.toString();
          //
          if (!listInvoiceHid.contains(strInvoiceHid)) {
            listInvoiceHid.add(strInvoiceHid);
          }
          //
          washVO[i].setCinvoiceid(strInvoiceHid);
          listAdjuestVO.add(washVO[i]);

          // 调用应付提供的保存+冲减方法冲减暂估应付
          // iArap.unAdjuest(strInvoiceHid,unitCode);

          // 回写ic_general_bb3上的暂估应付累计回冲数量
          if (washVO[i].isVmi()) {
            invoiceDMO.updateAccumWashNumForVmi(new String[] {
              washVO[i].getDdhh()
            }, new UFDouble[] {
              washVO[i].getShl()
            }, false);
          }
          else {
            invoiceDMO.updateAccumWashNumForIC(new String[] {
              washVO[i].getDdhh()
            }, new UFDouble[] {
              washVO[i].getShl()
            }, false);
          }
        }
        // 调用应付提供的保存+冲减方法冲减暂估应付
        if (listAdjuestVO.size() > 0) {
          Hashtable hashHidClbh = new PubDMO().queryHtResultFromAnyTable("po_invoice", "cinvoiceid", new String[] {
            "clbh"
          }, " cinvoiceid in " + new TempTableUtil().getSubSql(listInvoiceHid));
          if (hashHidClbh != null && hashHidClbh.size() > 0) {
            Map<String, Map<String, String>> clbhs = new HashMap<String, Map<String, String>>();
            Map<String, String> mapDdhh = null;
            String strClbh = null;
            Vector vClbh = null;
            IAdjuestVO voAdjust = null;
            String strLylx = "1";
            ArrayList<IAdjuestVO> listAdjuestVos = new ArrayList<IAdjuestVO>();
            for (int i = 0; i < listAdjuestVO.size(); i++) {
              voAdjust = (IAdjuestVO) listAdjuestVO.get(i);
              strInvoiceHid = voAdjust.getCinvoiceid();
              vClbh = (Vector) hashHidClbh.get(strInvoiceHid);
              if (vClbh == null || vClbh.size() == 0) {
                continue;
              }
              strClbh = (String) ((Object[]) vClbh.get(0))[0];
              if (PuPubVO.getString_TrimZeroLenAsNull(strClbh) == null) {
                continue;
              }
              listAdjuestVos.add(voAdjust);
              mapDdhh = clbhs.get(strClbh);
              if (mapDdhh == null) {
                mapDdhh = new HashMap<String, String>();
              }
              mapDdhh.put(voAdjust.getDdhh(), strLylx);
              clbhs.put(strClbh, mapDdhh);
            }
            //
            if (clbhs.size() > 0) {
              IArapForGYLPublic iArap = (IArapForGYLPublic) NCLocator.getInstance().lookup(
                  IArapForGYLPublic.class.getName());
              iArap.unAdjuestForGC(clbhs, unitCode);
            }

            // 更新处理编号
            if (listAdjuestVos.size() > 0) {
              invoiceDMO.updateClbh(listAdjuestVO.toArray(new IAdjuestVO[listAdjuestVO.size()]), null, null, true);
            }
          }
        }
      }
    }
    catch (Exception e) {
      PubDMO.throwBusinessException(e);
    }
  }

  /**
   * 作者：王印芬 功能：过滤掉VMI发票 该函数为平台注册函数，用于判断向应付传数据时，VMI发票不可传
   * 请不要随意修改及删除该方法，否则将导致平台运行不正确 参数：InvoiceVO[] voaInv 发票VO数组 返回：InvoiceVO[]
   * 已滤掉VMI发票的发票VO数组 例外：BusinessException 参数不正确时抛出 日期：(2002-6-14 11:39:21)
   * 修改日期，修改人，修改原因，注释标志：
   */
  public InvoiceVO[] filterVMIInvoice(InvoiceVO[] voaInv) throws BusinessException {

    // 参数正确性检查
    if (voaInv == null) {
      SCMEnv.out("nc.bs.pi.InvoiceBO.filterVMIInvoice(InvoiceVO [])传入参数不正确！");
      throw new BusinessException("nc.bs.pi.InvoiceBO.filterVMIInvoice(InvoiceVO [])  Exception!",
          new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000075")/*
                                                                                                                       * @res
                                                                                                                       * "需检验的发票为空或缺少相关数据项，无法检验发票的业务类型！"
                                                                                                                       */));
    }

    // 得到所有业务类型
    int iLen = voaInv.length;
    String[] saBizType = new String[iLen];
    for (int i = 0; i < iLen; i++) {
      if (voaInv[i] == null || voaInv[i].getHeadVO() == null || voaInv[i].getHeadVO().getCbiztype() == null) {
        SCMEnv.out("nc.bs.pi.InvoiceBO.filterVMIInvoice(InvoiceVO [])传入参数不正确！");
        throw new BusinessException("nc.bs.pi.InvoiceBO.filterVMIInvoice(InvoiceVO [])  Exception!",
            new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000075")/*
                                                                                                                         * @res
                                                                                                                         * "需检验的发票为空或缺少相关数据项，无法检验发票的业务类型！"
                                                                                                                         */));
      }
      saBizType[i] = voaInv[i].getHeadVO().getCbiztype();
    }

    // 得到所有业务类型的核算规则
    Object[][] oa2Ret = null;
    try {
      oa2Ret = new nc.bs.pu.pub.PubDMO().queryArrayValue("bd_busitype", "pk_busitype", new String[] {
        "verifyrule"
      }, saBizType);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.filterVMIInvoice(InvoiceVO [])  Exception!", e);
    }

    // 结果合法性判断
    if (oa2Ret == null) {
      throw new BusinessException("nc.bs.pi.InvoiceBO.filterVMIInvoice(InvoiceVO [])  Exception!",
          new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000076")/*
                                                                                                                       * @res
                                                                                                                       * "数据错误，查不到某发票业务类型对应的核算规则！"
                                                                                                                       */));
    }

    // Vector vValidInv = new Vector();
    for (int i = 0; i < iLen; i++) {
      if (oa2Ret[i] == null || oa2Ret[i][0] == null) {
        throw new BusinessException("nc.bs.pi.InvoiceBO.filterVMIInvoice(InvoiceVO [])  Exception!",
            new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000076")/*
                                                                                                                         * @res
                                                                                                                         * "数据错误，查不到某发票业务类型对应的核算规则！"
                                                                                                                         */));
      }
      // 过滤
      if (oa2Ret[i][0].toString().equalsIgnoreCase("V")) {
        voaInv[i] = null;
      }
    }
    // 组织返回结果
    return voaInv;
  }

  /**
   * 作者：方益 功能：添加审判人员在工作流中无权限单据的过滤条件 参数： String auditPsn 操作员ID boolean bAudited
   * true为查询已审批的，false为查询未审批的 String pk_corp 当前公司ID 返回：WHERE后的SQL语句 例外：
   * 日期：(2002-10-24 14:04:11) 修改日期，修改人，修改原因，注释标志： 2002-11-06 wyf 加入公司限制
   */
  private String getAuditPsnCondition(String auditPsn, boolean bAudited, String pk_corp) {

    if (auditPsn == null) {
      return "";
    }

    String con = " ";
    // 查询未审批的
    if (!bAudited) {

      // 在审批流中尚未处理
      con += "AND (";
      con += "po_invoice.cinvoiceid IN ";
      con += "(SELECT billid FROM pub_workflownote "; // 子查询1
      con += "where receivedeleteflag = 'N' and ischeck = 'N' "; // 在工作流中但没有审批
      con += "and checkman = '" + auditPsn + "') "; // 操作员权限控制

      // 或者不在审批流中的单据
      // con += "OR NOT EXISTS ";
      con += " OR (po_invoice.cinvoiceid not in ";
      // con += "OR (NOT EXISTS ";
      // con += "(SELECT billid FROM pub_workflownote where billid =
      // po_invoice.cinvoiceid) ";
      con += "(SELECT billid FROM pub_workflownote, po_invoice where billid = po_invoice.cinvoiceid) ";
      con += "  AND po_invoice.pk_corp='" + pk_corp + "')";
      con += " ) ";
    }
    // 查询审批的
    else {
      // 在审批流中尚未处理
      con += "AND (";
      con += "po_invoice.cinvoiceid IN ";
      con += "(SELECT billid FROM pub_workflownote "; // 子查询1
      con += "where receivedeleteflag = 'N' and ischeck = 'Y' ";// and
      // finishflag
      // = 'Y'
      // ";
      // //在工作流中被审批结束
      con += "and checkman = '" + auditPsn + "') "; // 操作员权限控制

      // 或者不在审批流中的单据
      // con += "OR NOT EXISTS ";
      // con += "OR (NOT EXISTS ";
      // con += "(SELECT billid FROM pub_workflownote where billid =
      // po_invoice.cinvoiceid) ";
      con += "OR (po_invoice.cinvoiceid NOT IN ";
      con += "(SELECT billid FROM pub_workflownote, po_invoice where billid = po_invoice.cinvoiceid) ";
      con += "  AND po_invoice.pk_corp='" + pk_corp + "')";
      con += ") ";
    }

    return con;
  }

  /**
   * 作者：王印芬 功能：得到订单BEAN 请注意： 该方法必须与删除方法成对使用! 参数：无 返回：Order 订单BEAN
   * 例外：BusinessException 其中包裹BusinessException及SystemException异常 日期：(2003-11-24
   * 12:42:34) 修改日期，修改人，修改原因，注释标志：
   */
  private OrderImpl getBean_Order() throws BusinessException {
    String sMethodName = "nc.bs.po.OrderImpl.getBean_Order()";
    OrderImpl bean = null;
    try {
      bean = new OrderImpl();
    }
    catch (Exception e) {

      PubDMO.throwBusinessException(sMethodName, e);
    }
    return bean;
  }

  /**
   * 作者:汪维敏 功能描述:获取计划价格 输入参数:存货管理IDs 返回值:计划价 异常处理:BusinessException 日期: 修改日期:
   * 
   * @return nc.vo.pub.lang.UFDouble
   * @param param
   *          java.lang.String
   */
  public UFDouble[] getPlanPricesForPr(String[] sBaseIds, String sStoreOrgId, String sCorpId) throws BusinessException {
    // 验证参数有效性
    if (sBaseIds == null || sBaseIds.length == 0 || sCorpId == null)
      return null;

    // 计划价
    UFDouble[] uPlanPrice = null;
    // 存货管理ID、计划价的值对
    HashMap hResult = new HashMap();
    try {
      int size = sBaseIds.length;
      uPlanPrice = new UFDouble[size];
      InvoiceDMO dmo = new InvoiceDMO();
      // 如果库存组织是null，则从存货管理档案取价
      if (sStoreOrgId == null || sStoreOrgId.trim().length() == 0)
        hResult = dmo.getPlanPricesFrmInvMan(sBaseIds, sCorpId);
      else
        hResult = dmo.getPlanPricesForPr(sBaseIds, sStoreOrgId, sCorpId);
      if (hResult == null || hResult.size() == 0)
        return null;
      for (int i = 0; i < size; i++) {
        if (sBaseIds[i] == null)
          continue;
        uPlanPrice[i] = (UFDouble) hResult.get(sBaseIds[i]);
      }
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pr.pray.PraybillImpl.getPlanPricesForPr(String [], String, String)", e);
    }
    return uPlanPrice;
  }

  /**
   * 作者：王印芬 功能：判断一张发票是否可作废 该方法由discardInvoiceForSettle(String [])调用,请不要随意删除及修改
   * 参数： String sInvoiceId 发票ID 返回：无 例外： 日期：(2002-6-10 9:23:11)
   * 修改日期，修改人，修改原因，注释标志： 2002-09-09 wyf 修改提示方式，已结算的判断去掉
   */
  private UFBoolean isASettledInvoiceCouldBeDiscarded(String sInvoiceId) throws BusinessException {

    if (sInvoiceId == null || sInvoiceId.trim().length() == 0) {
      return new UFBoolean(false);
    }
    try {
      // 0不存在 1已作废 2正在审批 2已审批
      nc.bs.pu.pub.PubDMO dmoPuPub = new nc.bs.pu.pub.PubDMO();
      Object[][] ob = dmoPuPub.queryResultsFromAnyTable("po_invoice", new String[] {
          "dr", "ibillstatus"
      }, "cinvoiceid='" + sInvoiceId + "' ");
      if (ob == null || ob.length < 1 || ob[0][0] == null || ob[0][1] == null) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000077")/*
                                   * @res "相关发票不存在，出现错误！"
                                   */);
      }
      else {
        int dr = new Integer(ob[0][0].toString()).intValue();
        int status = new Integer(ob[0][1].toString()).intValue();
        if (dr != BillStatus.FREE.intValue()) {
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000078")/*
                                     * @res "相关发票已作废，不能作废结算单！"
                                     */);
        }
        if (status == BillStatus.AUDITING.intValue()) {
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000079")/*
                                     * @res "相关发票正在审批，不能作废结算单！"
                                     */);
        }
      }
      // 虚拟发票，不必做是否应付的检查{虚拟发票的审批与不审批认为没有什么实际的业务意义}
      ob = dmoPuPub.queryResultsFromAnyTable("po_invoice", new String[] {
        "bapflag"
      }, "cinvoiceid='" + sInvoiceId + "' and iinvoicetype <> 3 ");
      if (ob != null && ob.length >= 1 && ob[0][0] != null) {
        UFBoolean ufbApFlag = PuPubVO.getUFBoolean_NullAs(ob[0][0], UFBoolean.FALSE);
        if (ufbApFlag.booleanValue()) {
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000259")/*
                                     * @res "相关发票已传应付，不能作废结算单！"
                                     */);
        }
      }

    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.isAInvoiceCouldBeDiscarded(InvoiceVO) Exception!", e);
    }
    return new UFBoolean(true);
  }

  /**
   * 作者：汪维敏 功能：从采购入库单生成发票时，检查入库单累计结算数量和累计开票数量 如果累计结算数量>累计开票数量，发票不能保存和结算 参数：invVO
   * 待审批的请购单， sPara 入库单转发票时的自动结算配置 返回：boolean 例外：BusinessException 时间：
   */
  // private boolean isInNumRange(InvoiceVO invVO, String sPara) throws
  // BusinessException {
  //
  // InvoiceItemVO[] items = invVO.getBodyVO();
  //  
  //
  // //参数：入库单转发票时的自动结算配置
  // String sParaSettleInTime = sPara;
  //
  // //得到需检验的表体行
  // Vector stoVEC = new Vector();
  // for (int i = 0; i < items.length; i++) {
  // if (items[i].getStatus() != VOStatus.DELETED && items[i].getNinvoicenum()
  // != null) {
  // //检测入库单
  // if (items[i].getCupsourcebilltype().equals("45")) {
  // stoVEC.addElement(items[i]);
  // }
  // }
  // }
  // if (stoVEC.size() == 0) {
  // return true;
  // }
  //  
  //
  // try {
  // //公用DMO
  // nc.bs.pu.pub.PubDMO dmoPuPub = new nc.bs.pu.pub.PubDMO();
  //
  // //入库单累计结算数量、累计开票数量检查
  // int size = stoVEC.size();
  // if (size > 0 && !sParaSettleInTime.equals("不自动结算")) {
  // String[] sGeneralBids = null;
  // ArrayList arrGeneralBids = new ArrayList();
  // InvoiceItemVO curItem = null;
  // String sUpSourceBillRowId = null;
  // for (int i = 0; i < size; i++) {
  // curItem = ((InvoiceItemVO) stoVEC.elementAt(i));
  // sUpSourceBillRowId = curItem.getCupsourcebillrowid();
  // if (sUpSourceBillRowId != null && sUpSourceBillRowId.trim().length() > 0)
  // {
  // arrGeneralBids.add(sUpSourceBillRowId);
  // }
  // }
  // if (arrGeneralBids.size() > 0) {
  // sGeneralBids = new String[arrGeneralBids.size()];
  // arrGeneralBids.toArray(sGeneralBids);
  // }
  // //获取累计开票数量和累计结算数量
  // HashMap hGeneral =
  // dmoPuPub.queryArrayValues(
  // "ic_general_b INNER JOIN ic_general_bb3 ON ic_general_b.cgeneralbid =
  // ic_general_bb3.cgeneralbid",
  // "ic_general_b.cgeneralbid",
  // new String[] { "ic_general_b.ninnum", "ic_general_bb3.nsignnum",
  // "ic_general_bb3.naccountnum1" },
  // sGeneralBids,
  // null);
  // for (int i = 0; i < size; i++) {
  // curItem = ((InvoiceItemVO) stoVEC.elementAt(i));
  // sUpSourceBillRowId = curItem.getCupsourcebillrowid();
  // UFDouble dInvoiceNum = curItem.getNinvoicenum();
  // //如果累计结算数量>累计开票数量，发票不能保存和结算
  // if (sUpSourceBillRowId != null && sUpSourceBillRowId.trim().length() > 0)
  // {
  // if (hGeneral != null && hGeneral.size() > 0) {
  // Object[] ob = (Object[]) hGeneral.get(sUpSourceBillRowId);
  // if (ob == null) {
  // String[] value = new String[]{String.valueOf(curItem.getNShowRow())};
  // throw new
  // BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401","UPP40040401-000081",null,value)/*@res
  // "表体" + curItem.getNShowRow() + "：\n相关入库单行已被删除，发票不能保存！"*/);
  // }
  // //实收数量
  // UFDouble dNinNum = (ob[0] == null) ? new UFDouble(0.0) : new
  // UFDouble(ob[0].toString());
  // //累计开票数量
  //            
  // //累计结算数量
  // UFDouble dAccumnum = (ob[2] == null) ? new UFDouble(0.0) : new
  // UFDouble(ob[2].toString());
  // double d = dNinNum.doubleValue() - dAccumnum.doubleValue();
  // if (Math.abs(dInvoiceNum.doubleValue()) > Math.abs(d)) {
  // String[] value = new String[]{String.valueOf(curItem.getNShowRow())};
  // throw new
  // BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401","UPP40040401-000082",null,value)/*@res
  // "表体" + curItem.getNShowRow() + "：\n发票数量大于相关入库单行可结算数量，发票不能保存！"*/);
  // }
  // }
  // }
  // }
  // }
  // } catch (Exception e) {
  //    
  // PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.isInNumRange(InvoiceVO,String)
  // Exception!", e);
  // }
  // return true;
  // }
  /**
   * 作者：王印芬 功能：得到采购参数"差异转入方式" 参数：无 返回：String null,成本,损益 例外：Exception 返回null
   * 日期：(2002-3-13 11:39:21) 修改日期，修改人，修改原因，注释标志：
   */

  public String queryDiffModule(String pk_corp) throws BusinessException {

    String strPara = null;
    try {
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      strPara = initDMO.getParaString(pk_corp, "PO13");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.getDiffModule(String) Exception!", new BusinessException(
          nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000083")/*
                                                                                                 * @res
                                                                                                 * "取差异转入方式时出现系统故障！"
                                                                                                 */));
    }

    return strPara;
  }

  /**
   * 作者：王印芬 功能：得到采购参数"暂估处理方式" 参数：无 返回：String null,单到补差,单到回冲 例外：Exception 返回null
   * 日期：(2002-3-13 11:39:21) 修改日期，修改人，修改原因，注释标志：
   */

  public String queryEstimateModule(String pk_corp) throws BusinessException {

    String strPara = null;
    try {
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      strPara = initDMO.getParaString(pk_corp, "PO12");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.getEstimateModule(String) Exception!", new BusinessException(
          nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000084")/*
                                                                                                 * @res
                                                                                                 * "取暂估处理方式时出现系统故障！"
                                                                                                 */));
    }

    return strPara;
  }

  /**
   * 作者：汪维敏 功能：保存及审批操作时，前台需要刷新审批人，审批日期，ts，单据状态 参数： 返回： 例外： 日期：(2004-5-13
   * 13:21:13) 修改日期，修改人，修改原因，注释标志：
   * 
   * @param key
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList queryForSaveAudit(String key) throws BusinessException {
    ArrayList arr = new ArrayList();
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      arr = dmo.queryForSaveAudit(key);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.queryForSaveAudit(String)!", e);
    }
    return arr;
  }

  /**
   * 根据查询得到：入库单VO 及 需显示的入库单－＞发票VO 创建日期：(2001-6-18)
   * 
   * @return nc.vo.pi.InvoiceVO
   * @param key
   *          String
   * @exception BusinessException
   *              异常说明。
   */
  public Object[] queryGenenelVOsByFromWhere(String strBillType, String strFromWhere, ConditionVO[] powerVOs)
      throws BusinessException {

    // 查询
    Object[] ob = null;
    String sOperator = null;
    String ss = null;
    String corp = null;

    try {
      InvoiceDMO dmo = new InvoiceDMO();
      // 数据权限控制
      if (powerVOs[powerVOs.length - 2].getFieldName().equals("操作员")) {
        sOperator = powerVOs[powerVOs.length - 2].getValue();
      }
      if (powerVOs[powerVOs.length - 1].getFieldName().equals("公司")) {
        corp = powerVOs[powerVOs.length - 1].getValue();
      }
      if (strBillType.equals(nc.vo.scm.pu.BillTypeConst.STORE_SC)) {
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("ic_general_h", "ic_general_h", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("ic_general_b", "ic_general_b", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("sc_order", "sc_order", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("sc_order_b", "sc_order_b", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ob = dmo.findGenenelVOsFromScOrderByCondsMy(strFromWhere);
      }
      else {
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("ic_general_h", "ic_general_h", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("ic_general_b", "ic_general_b", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("po_order", "po_order", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ss = nc.bs.scm.datapower.ScmDps.getSubSql("po_order_b", "po_order_b", sOperator, new String[] {
          corp
        });
        if (ss != null && ss.trim().length() > 0)
          strFromWhere += " and " + ss + " ";
        ob = dmo.findGenenelVOsFromPoOrderByCondsMy(strFromWhere);
      }
      //设置入库单的表体供应商（实为来源订单的发票或供应商）用于发票分单 by zhaoyha
      if(!ArrayUtils.isEmpty(ob))
      dmo.setStockBodyVendorBasID((GeneralBillVO[]) ob[0]);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.findInvFrmStoVOsAndGeneralVOsMy(ConditionVO []) Exception!", e);
    }

    return ob;
  }

  /**
   * 根据查询得到：订单行已结算数量 创建日期：(2001-6-18)
   * 
   * @return nc.vo.pi.InvoiceVO
   * @param key
   *          String
   * @exception BusinessException
   *              异常说明。
   */
  public Object queryNaccumsettnum(String bllid_b) throws BusinessException {

    // 查询
    Object ob = null;
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      // if (strBillType.equals(nc.vo.pu.pub.BillTypeConst.STORE_SC)) {
      ob = dmo.findNaccumsettnumForScOrder(bllid_b);
      // } else {
      // ob = dmo.findNaccumsettnumForPoOrder(bllid_b);
      // }
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.findInvFrmStoVOsAndGeneralVOsMy(ConditionVO []) Exception!", e);
    }

    return ob;
  }

  public InvoiceVO[] queryInvoiceVOsByCondsMy(NormalCondVO[] normalVOs,
      ConditionVO[] definedVOs) throws BusinessException {
    return queryInvoiceVOsByCondsMy(null, normalVOs, definedVOs);
  }
  
  /**
   * 作者：王印芬 功能：得到符合根据票查询条件的发票VO 参数： NormalCondVO[] normalVOs 常用查询条件VO数组
   * ConditionVO[] definedVOs 自定义查询条件VO数组 返回：InvoiceVO[] 符合查询条件的发票VO数组 例外：
   * 日期：(2002-5-18 9:23:11) 修改日期，修改人，修改原因，注释标志：
   */
  public InvoiceVO[] queryInvoiceVOsByCondsMy(String strOprPsn,
      NormalCondVO[] normalVOs, ConditionVO[] definedVOs)
  throws BusinessException {

    boolean isWaitAudit = false;
    ArrayList arr = new ArrayList();
    arr = PuUtils.filterConditionByIsWaitAudit(definedVOs);
    if (arr != null && arr.size() == 2) {
      isWaitAudit = (Boolean) arr.get(0);
      definedVOs = (ConditionVO[]) arr.get(1);
    }
    else {
      definedVOs = null;
    }

    // V31 增加权限处理，转换名称、编码到相关档案主键
    if (definedVOs != null && definedVOs.length > 0) {
      for (int i = 0; i < definedVOs.length; i++) {
        if (definedVOs[i].getOperaCode().equalsIgnoreCase("in")
            && InvoicePubVO._Hash_InvoiceUI.get(definedVOs[i].getFieldCode()) != null) {
          // 转换操作符为IN且在注册表中注册过的条件
          definedVOs[i].setFieldCode((String) InvoicePubVO._Hash_InvoiceUI
              .get(definedVOs[i].getFieldCode()));
        }
      }
    }
    String fromWhere = getInvQueFromWhere(normalVOs, definedVOs);

    InvoiceVO[] retVOs = null;
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      retVOs = dmo.findInvoiceVOsByNoneItems(fromWhere);

      if (retVOs == null || retVOs.length < 1) {
        return null;
      }
      if (isWaitAudit) {
        Vector<InvoiceHeaderVO> vct = new Vector<InvoiceHeaderVO>();
        for (int i = 0; i < retVOs.length; i++) {
          vct.add(retVOs[i].getHeadVO());
        }
        InvoiceHeaderVO[] headVO = new InvoiceHeaderVO[vct.size()];
        vct.copyInto(headVO);
        headVO = (InvoiceHeaderVO[]) PuUtils.filterHeadByIsWaitAudit(headVO, BillTypeConst.PO_INVOICE, strOprPsn);
        if (headVO == null || headVO.length < 1) {
          return null;
        }
        retVOs = new InvoiceVO[headVO.length];
        for (int i = 0; i < headVO.length; i++) {
          retVOs[i] = new InvoiceVO();
          retVOs[i].setParentVO(headVO[i]);
        }
      }
    }
    catch (Exception e) {
      PubDMO
          .throwBusinessException(
              "nc.bs.pi.InvoiceBO.findInvoiceVOsByNoneItems(ConditionVO [], String, String, String, String, String [], String []) Exception!",
              e);
    }
    return retVOs;
  }

  /**
   * 作者：王印芬 功能：得到符合根据票查询条件的发票VO 参数： NormalCondVO[] normalVOs 常用查询条件VO数组
   * ConditionVO[] definedVOs 自定义查询条件VO数组 返回：InvoiceVO[] 符合查询条件的发票VO数组 例外：
   * 日期：(2002-5-18 9:23:11) 修改日期，修改人，修改原因，注释标志：
   */
  public InvoiceVO[] queryVoByHid(String billid) throws BusinessException {

    String fromWhere = " from po_invoice inner join po_invoice_b on po_invoice.dr =0 and po_invoice_b.dr =0 and po_invoice.cinvoiceid = po_invoice_b.cinvoiceid and po_invoice.cinvoiceid = '"
        + billid + "' ";

    InvoiceVO[] retVOs = null;
    try {

      InvoiceDMO dmo = new InvoiceDMO();
      retVOs = dmo.findInvoiceVOsByNoneItems(fromWhere);

    }
    catch (Exception e) {

      PubDMO
          .throwBusinessException(
              "nc.bs.pi.InvoiceBO.findInvoiceVOsByNoneItems(ConditionVO [], String, String, String, String, String [], String []) Exception!",
              e);
    }
    return retVOs;
  }

  /**
   * 作者：王印芬 功能：得到符合根据票查询条件的发票VO 参数： NormalCondVO[] normalVOs 常用查询条件VO数组
   * ConditionVO[] definedVOs 自定义查询条件VO数组 返回：InvoiceVO[] 符合查询条件的发票VO数组 例外：
   * 日期：(2002-5-18 9:23:11) 修改日期，修改人，修改原因，注释标志： 2002-11-05 wyf
   * 去掉常用条件中对公司的限制，以可以查询出所有有权限公司的单据
   */
  public InvoiceVO[] queryInvoiceVOsByCondsMy(NormalCondVO[] normalVOs, ConditionVO[] definedVOs, String auditPsn)
      throws BusinessException {

    // added by fangy 2002-10-24 18:00 begin
    // 添加审批流单据过滤条件
    boolean bAudited = false;
    String pk_corp = null, sOperator = null, ss1 = null, ss2 = null;

    for (int i = 0; normalVOs != null && i < normalVOs.length; i++) {
      // wyf 2002-11-05 add begin
      if (normalVOs[i].getKey().equals("公司")) {
        pk_corp = (String) normalVOs[i].getValue();
        // normalVOs[i].setKey("NULL") ;
      }
      // wyf 2002-11-05 add end
      else if (normalVOs[i].getKey().equals("审批")) {
        if (normalVOs[i].getValue().equals("是"))
          bAudited = true;
        break;
      }
    }
    // 数据权限控制
    if (definedVOs[definedVOs.length - 1].getFieldName().equals("操作员")) {
      sOperator = definedVOs[definedVOs.length - 1].getValue();
    }

    if (definedVOs != null && definedVOs.length > 0) {
      Vector v = new Vector();
      for (int i = 0; i < definedVOs.length - 1; i++)
        v.addElement(definedVOs[i]);

      definedVOs = new ConditionVO[v.size()];
      v.copyInto(definedVOs);
    }

    String sFromWhere = getInvQueFromWhere(normalVOs, definedVOs);
    sFromWhere += getAuditPsnCondition(auditPsn, bAudited, pk_corp);
    // added by fangy 2002-10-24 18:00 end
    InvoiceVO[] retVOs = null;
    try {
      ss1 = nc.bs.scm.datapower.ScmDps.getSubSql("po_invoice", "po_invoice", sOperator, new String[] {
        pk_corp
      });
      if (ss1 != null && ss1.trim().length() > 0)
        sFromWhere += " and " + ss1 + " ";
      ss2 = nc.bs.scm.datapower.ScmDps.getSubSql("po_invoice_b", "po_invoice_b", sOperator, new String[] {
        pk_corp
      });
      if (ss2 != null && ss2.trim().length() > 0)
        sFromWhere += " and " + ss2 + " ";

      InvoiceDMO dmo = new InvoiceDMO();
      retVOs = dmo.findInvoiceVOsByNoneItems(sFromWhere);

    }
    catch (Exception e) {

      throw new BusinessException(
          "nc.bs.pi.InvoiceBO.queryInvoiceVOsByCondsMy(NormalCondVO [], ConditionVO [], String) Exception!", e);
    }
    return retVOs;
  }

  /**
   * 作者：方益 功能：通过ID,TS,和当前的查询条件查询InvoiceVO的表体 注: 因效率问题,修改表体的查询模式,而做此修改. 参数：
   * NormalCondVO[] normalVOs 常用查询条件VO数组 ConditionVO[] definedVOs 自定义查询条件VO数组
   * InvoiceVO[] vos 目标InvoiceVO数组 返回：InvoiceVO[] 符合查询条件的发票VO数组 例外：
   * 日期：(2003-02-21 9:23:11) 修改日期，修改人，修改原因，注释标志：
   */
  public InvoiceVO[] queryItemsForInvoices(NormalCondVO[] normalVOs, ConditionVO[] definedVOs, InvoiceVO[] vos) throws BusinessException {

    // 输入条件合法性判断,这些VO表体都为空.
    if (vos == null || vos.length == 0)
      return null;

    boolean isWaitAudit = false;
    ArrayList arr = new ArrayList();
    arr = PuUtils.filterConditionByIsWaitAudit(definedVOs);
    if (arr != null && arr.size() == 2) {
      isWaitAudit = (Boolean) arr.get(0);
      definedVOs = (ConditionVO[]) arr.get(1);
    }
    else {
      definedVOs = null;
    }

    Vector tempVOs = new Vector();
    NormalCondVO[] normalTempVOs = new NormalCondVO[normalVOs.length];
    for (int i = 0; i < normalVOs.length; i++) {
      // 公司
      if (!normalVOs[i].getKey().equals("公司")) {
        tempVOs.add(normalVOs[i]);
      }
    }
    if (tempVOs != null && tempVOs.size() > 0) {
      normalTempVOs = new NormalCondVO[tempVOs.size()];
      tempVOs.copyInto(normalTempVOs);
    }
    // 拼接ID和TS条件:
    // 如:(id ='0001' and ts ='2002-09-20 12:00:23') or (id ='0003' and ts
    // ='2002-12-11 12:00:24')
    String bizSQL = getInvQueFromWhere(normalTempVOs, definedVOs);

    String id_ts = " and((po_invoice.cinvoiceid = '" + vos[0].getHeadVO().getPrimaryKey() + "'"
        + " and po_invoice.ts = '" + vos[0].getHeadVO().getTs() + "')";
    for (int i = 1; i < vos.length; i++) {
      id_ts += " or (po_invoice.cinvoiceid = '" + vos[i].getHeadVO().getPrimaryKey() + "'" + " and po_invoice.ts = '"
          + vos[i].getHeadVO().getTs() + "')";
    }
    id_ts += ")";

    // 查询
    InvoiceVO[] invs = null;
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      invs = dmo.findInvoiceVOsByAllItems(bizSQL + id_ts);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("InvoiceBean::queryItemsForInvoices(InvoicePK) Exception!", e);
    }
    /**
     * 对查询结果进行分析 如果某个InvoiceVO被删除了,因满足id_ts条件的ID不存在,则查询出的结果比原来的vos长度小
     * 如果某个InvoiceVO表头被修改,因满足id_ts条件的TS不存在,则查询出的结果比原来的vos长度小
     * 如果某个InvoiceVO表体被修改,如果该VO不满足bizSQL业务条件,则查询出的结果比原来的vos长度小
     */
    if (invs == null || vos.length != invs.length) {
      // 并发操作,抛出异常
      throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000085")/*
                                                                                                                         * @res
                                                                                                                         * "异常"
                                                                                                                         */, new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000086")/*
                                                                                                                       * @res
                                                                                                                       * "可能发生并发操作,请刷新界面,否则可能导致错误!"
                                                                                                                       */));
    }

    // 调整invs的顺序,按照vos的顺序返回.
    for (int i = 0; i < vos.length; i++) {
      String key1 = vos[i].getHeadVO().getPrimaryKey();
      for (int j = 0; j < invs.length; j++) {
        String key2 = invs[j].getHeadVO().getPrimaryKey();
        if (key1.equals(key2)) {
          vos[i].setChildrenVO(invs[j].getChildrenVO());
          break;
        }
      }
    }
    return vos;
  }

  /**
   * 得到启用日期 创建日期：(2001-10-22)
   * 
   * @return
   */

  public UFDouble queryNumPresControl(String pk_corp) throws BusinessException {

    UFDouble dPara = null;
    try {
      // 得到容差控制类型
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      dPara = initDMO.getParaDbl(pk_corp, "PO03");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.getNumPresControl(String) Exception!", new BusinessException(
          nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000087")/*
                                                                                                 * @res
                                                                                                 * "取数量容差数值时出现系统故障，发票数量容差检验无法完成！"
                                                                                                 */));
    }
    return dPara;

  }

  /**
   * 得到启用日期 创建日期：(2001-10-22)
   * 
   * @return
   */

  public String queryNumPresControlKind(String pk_corp) throws BusinessException {

    String strPara = null;
    try {
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      strPara = initDMO.getParaString(pk_corp, "PO02");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.getNumPresControlKind(String) Exception!",
          new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000087")/*
                                                                                                                       * @res
                                                                                                                       * "取数量容差数值时出现系统故障，发票数量容差检验无法完成！"
                                                                                                                       */));
    }
    return strPara;
  }

  /**
   * 得到启用日期 创建日期：(2001-10-22)
   * 
   * @return
   */

  public UFDouble queryPricePresControl(String pk_corp) throws BusinessException {

    UFDouble dPara = null;
    try {
      // 得到容差控制类型
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      dPara = initDMO.getParaDbl(pk_corp, "PO05");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.getPricePresControl(String) Exception!", new BusinessException(
          nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000088")/*
                                                                                                 * @res
                                                                                                 * "取单价容差数值时出现系统故障，发票单价容差检验无法完成！"
                                                                                                 */));
    }

    return dPara;

  }

  /**
   * 得到启用日期 创建日期：(2001-10-22)
   * 
   * @return
   */

  public String queryPricePresControlKind(String pk_corp) throws BusinessException {

    String strPara = null;
    try {
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      strPara = initDMO.getParaString(pk_corp, "PO04");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.getPricePresControlKind(String) Exception!",
          new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000088")/*
                                                                                                                       * @res
                                                                                                                       * "取单价容差数值时出现系统故障，发票单价容差检验无法完成！"
                                                                                                                       */));
    }

    return strPara;

  }

  /**
   * 根据查询条件得到"订单生成发票VO" 创建日期：(2001-6-18)
   * 
   * @return nc.vo.pi.InvoiceVO
   * @param key
   *          String
   * @exception BusinessException
   *              异常说明。
   */
  public nc.vo.sc.order.OrderVO[] queryScOrderVOsByFromWhere(String strFromWhere, nc.vo.pub.query.ConditionVO[] powerVOs, boolean isWaitAudit)
      throws BusinessException {

    // 查询
    nc.vo.sc.order.OrderVO[] ordVOs = null;
    String ss = null;
    String sOperator = null;
    String unitCode = null;
    nc.vo.sc.order.OrderVO[] ordVOs2 = null;
    try {
      InvoiceDMO dmo = new InvoiceDMO();
      // 数据权限控制
      if (powerVOs[powerVOs.length - 2].getFieldName().equals("操作员")) {
        sOperator = powerVOs[powerVOs.length - 2].getValue();
      }
      if (powerVOs[powerVOs.length - 1].getFieldName().equals("公司")) {
        unitCode = powerVOs[powerVOs.length - 1].getValue();
      }

      ss = nc.bs.scm.datapower.ScmDps.getSubSql("sc_order", "sc_order", sOperator, new String[] {
          unitCode
      });
      if (ss != null && ss.trim().length() > 0)
        strFromWhere += " and " + ss + " ";
      ss = nc.bs.scm.datapower.ScmDps.getSubSql("sc_order_b", "sc_order_b", sOperator, new String[] {
          unitCode
      });
      if (ss != null && ss.trim().length() > 0)
        strFromWhere += " and " + ss + " ";

      ordVOs = dmo.findScOrderVOsByCondsMy(strFromWhere);

      if(ordVOs != null){
        if (isWaitAudit) {
          Vector<nc.vo.sc.order.OrderVO> vctOrderVO = new Vector<nc.vo.sc.order.OrderVO>();
          Vector<nc.vo.sc.order.OrderHeaderVO> vct = new Vector<nc.vo.sc.order.OrderHeaderVO>();
          for (int i = 0; i < ordVOs.length; i++) {
            vct.add((nc.vo.sc.order.OrderHeaderVO) ordVOs[i].getParentVO());
          }
          nc.vo.sc.order.OrderHeaderVO[] headVO = new nc.vo.sc.order.OrderHeaderVO[vct.size()];
          vct.copyInto(headVO);
          headVO = (nc.vo.sc.order.OrderHeaderVO[]) PuUtils.filterHeadByIsWaitAudit(headVO, BillTypeConst.SC_ORDER, BsPuTool.getLoginOperator());
          if (headVO == null || headVO.length < 1) {
            return null;
          }
          HashMap<String, String> hOrderID = new HashMap<String, String>();
          for (int i = 0; i < headVO.length; i++) {
            hOrderID.put(headVO[i].getPrimaryKey(), headVO[i].getPrimaryKey());
          }
          for (int i = 0; i < ordVOs.length; i++) {
            if(hOrderID.containsKey(ordVOs[i].getParentVO().getPrimaryKey())){
              vctOrderVO.add(ordVOs[i]);
            }
          }

          if (vctOrderVO != null && vctOrderVO.size() > 0) {
            ordVOs2 = new nc.vo.sc.order.OrderVO[vctOrderVO.size()];
            vctOrderVO.copyInto(ordVOs2);
          }
        }else{
          ordVOs2 = ordVOs;
        }
      }else{
        ordVOs2 = null;
      }
    }
    catch (Exception e) {
      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.findOrderVOsByCondsMy(ConditionVO [], String) Exception!", e);
    }

    return ordVOs2;
  }

  /**
   * 作者：汪维敏 功能：刷新VO 返回：无
   * 例外：BusinessException，其中包裹BusinessException,SystemException 日期：(2002-4-12
   * 12:42:34) 修改日期，修改人，修改原因，注释标志：
   */
  InvoiceDMO dmo = null;

  private ArrayList refreshVO(ArrayList arr) throws BusinessException {
    ArrayList arrRet = new ArrayList();
    String key = (String) arr.get(0);
    try {
      dmo = new InvoiceDMO();
      InvoiceVO vo = dmo.findByPrimaryKey(key);
      arrRet.add(key);
      arrRet.add(vo);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.refreshVO(ArrayList)", e);
    }
    return arrRet;
  }

  /**
   * 作者：王印芬 功能：根据发票VO保存该发票，不论该发票的来源 参数：InvoiceVO invVO 需保存的发票VO Object paraList
   * 参数，真实数据结构为ArrayList. paraList[0] 数量容差值，结构为Object[][3] Object[][0]
   * 订单ID(String) Object[][1] 对应订单ID的数量容差下限(UFDouble) Object[][2]
   * 对应订单ID的数量容差上限(UFDouble) paraList[1] 单价容差值，结构为Object[][3] Object[][0]
   * 订单ID(String) Object[][1] 对应订单ID的单价容差下限(UFDouble) Object[][2]
   * 对应订单ID的单价容差上限(UFDouble) paraList[2] 结算参数，结构为一个ArrayList String sSettleRule
   * 业务类型核算规则 0当前日期(UFDate),1是否集团(UFBoolean) 返回：ArrayList 0 发票ID(String)
   * 新生成的发票为新ID,修改的发票为原有ID 1 发票VO(InvoiceVO) 与数据库中完全一致的发票VO 例外：Exception
   * 保存过程中的系统及业务异常 日期：(2002-3-13 11:39:21) 修改日期，修改人，修改原因，注释标志：
   */
  private ArrayList saveAInvoice(InvoiceVO invVO, Object paraList, String sSettleRule) throws BusinessException {
    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("saveAInvoice method begin:");

    // paraList 0数量容差值 1单价容差值
    ArrayList realParaList = (ArrayList) paraList;

    InvoiceHeaderVO hVO = invVO.getHeadVO();
    InvoiceItemVO[] bVOs = invVO.getBodyVO();

    // 保存后返回的VO
    InvoiceVO resultVO = null;
    Vector resultBodyVec = new Vector();

    ArrayList list = null;

    try {
      // 系统DMO
      nc.bs.pu.pub.PubImpl dmoPuPub = new nc.bs.pu.pub.PubImpl();

      // 发票DMO
      InvoiceDMO dmoInvoice = new InvoiceDMO();

      IICToPU_VmiSumDMO oInstance = (IICToPU_VmiSumDMO) NCLocator.getInstance().lookup(
          IICToPU_VmiSumDMO.class.getName());

      // ===============1 发票头保存
      // //////////表头
      String headKey = null;
      // 删除标志
      hVO.setDr(new Integer(0));
      if (hVO.getPrimaryKey() == null || hVO.getPrimaryKey().trim().length() == 0) {
        // 得到发票号
        String strVinvoiceCode = new nc.bs.pu.pub.GetSysBillCode().getSysBillNO(invVO);

        timer.addExecutePhase("获取发票号");

        hVO.setVinvoicecode(strVinvoiceCode);
        headKey = dmoInvoice.insertHeader(hVO);
        hVO.setPrimaryKey(headKey);
      }
      else {
        if (realParaList != null && realParaList.size() > 5 && realParaList.get(5) != null) {
          // 单据修改,允许修改单据号
          InvoiceVO oldVO = (InvoiceVO) realParaList.get(5);
          nc.bs.pu.pub.GetSysBillCode codeDmo = new nc.bs.pu.pub.GetSysBillCode();
          codeDmo.setBillNoWhenModify(invVO, oldVO, "vinvoicecode");
        }

        headKey = hVO.getPrimaryKey();
        dmoInvoice.updateHeader(hVO);
      }

      timer.addExecutePhase("保存或更新发票表头");

      // 定义和初始化用于批处理插入和更新操作的数组

      // 用于插入的发票行
      Vector insertV = new Vector();
      // 用于更新的发票行
      Vector updateV = new Vector();

      // //////////表体
//      Object[][] oIsCanPurchased = null;
//      int bodyLength = 0;
      int iRowCount = bVOs.length;
//      String[] sCmanids = new String[iRowCount];
//      for (int i = 0; i < iRowCount; i++) {
//        sCmanids[i] = bVOs[i].getCmangid();
//      }
//      oIsCanPurchased = dmoPuPub.queryArrayValue("bd_invmandoc", "pk_invmandoc", new String[] {
//        "iscanpurchased"
//      }, sCmanids, "bd_invmandoc.dr=0");

      timer.addExecutePhase("检查是否可采购");

      for (int i = 0; i < iRowCount; i++) {
        // 检查存货是否可采购
//        if (oIsCanPurchased != null && oIsCanPurchased[i] != null && oIsCanPurchased[i][0] != null
//            && oIsCanPurchased[i][0].toString().trim().length() > 0) {
//          if (oIsCanPurchased[i][0].toString().toUpperCase().equals("N")) {
//            bodyLength++;
//            continue;
//          }
//        }
        // ===============2 统计发票项编辑状态(包括新增,修改,删除等操作)
        switch (bVOs[i].getStatus()) {
          // 新增行
          case VOStatus.NEW:
            // 添加非删除标志
            bVOs[i].setDr(new Integer(0));
            // 将该VO放入到用于插入操作的数组中
            insertV.add(bVOs[i]);
            resultBodyVec.addElement(bVOs[i]);
            break;
          // 修改行
          case VOStatus.UPDATED:
            // 添加非删除标志
            bVOs[i].setDr(new Integer(0));
            // 有可能是从其他单据转入
            if (bVOs[i].getCinvoice_bid() == null || bVOs[i].getCinvoice_bid().trim().length() == 0) {
              //

              insertV.add(bVOs[i]);
            }
            else {
              // 将该VO放入到用于更新操作的数组中
              updateV.add(bVOs[i]);
            }
            resultBodyVec.addElement(bVOs[i]);
            break;
          // 删除行
          case VOStatus.DELETED:
            // 设置被删除标志
            bVOs[i].setDr(new Integer(1));
            // 将该VO放入到用于更新操作的数组中
            updateV.add(bVOs[i]);
            break;
          // 未做任何修改行
          case VOStatus.UNCHANGED:
            // 设置非删除标志
            bVOs[i].setDr(new Integer(0));
            // 有可能是从其他单据转入
            if (bVOs[i].getCinvoice_bid() == null || bVOs[i].getCinvoice_bid().trim().equals("")) {
              // 将该VO放入到用于插入操作的数组中
              insertV.add(bVOs[i]);
            }
            else {
              // 将该VO放入到用于更新操作的数组中
              updateV.add(bVOs[i]);
            }
            resultBodyVec.addElement(bVOs[i]);
            break;
          // 其他
          default:
        }
      }
//      if (bodyLength > 0 && bodyLength <= bVOs.length)
//        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
//            "UPP40040401-000089")/*
//                                   * @res "含有存货是不可采购的，不能保存为发票！"
//                                   */);

      timer.addExecutePhase("表体操作前的准备");

      // 回写单据（采购订单、委外订单、采购入库单）
      // 航天一院:参照含有不可采购存货的库存入库单生成采购发票时,只对保存成功的发票行进行回写，如：入库单开票数量
      InvoiceVO inWriteBackVO = (InvoiceVO) invVO.clone();
      inWriteBackVO.setChildrenVO(bVOs);
      inWriteBackVO.setUserConfirmFlag(invVO.getUserConfirmFlag() == null ? new UFBoolean(false) : invVO
          .getUserConfirmFlag());

      //For V56 by zhaoyha
      //根据不同的来源类型,是否费用存货进行分单
      InvoiceVO[] splittedInWriteBackVOs=(InvoiceVO[])SplitBillVOs.getSplitVOs(InvoiceVO.class.getName(),
          InvoiceHeaderVO.class.getName(), InvoiceItemVO.class.getName(), new InvoiceVO[]{inWriteBackVO},
          null,    new String[] {"cupsourcebilltype","bfeeflag"});
      for(InvoiceVO splittedVO:splittedInWriteBackVOs){
        splittedVO.setUserConfirmFlag(inWriteBackVO.getUserConfirmFlag());
        writeBackBill(splittedVO);
      }

      timer.addExecutePhase("回写操作");
      String sourcebilltype = null;
      if (insertV.size() > 0) {
        // 插入发票行
        InvoiceItemVO[] vos = new InvoiceItemVO[insertV.size()];
        insertV.copyInto(vos);

        dmoInvoice.insertItems(vos, headKey);
        // 回写VMI累计开票数量
        sourcebilltype = vos[0].getCsourcebilltype();
        if (sourcebilltype != null && sourcebilltype.equalsIgnoreCase("50")) {
          Object[][] rowinfo = null;
          rowinfo = new Object[vos.length][2];
          for (int k = 0, loopk = vos.length; k < loopk; k++) {
            rowinfo[k][0] = vos[k].getCsourcebillid();
            rowinfo[k][1] = vos[k].getNinvoicenum();
          }

          oInstance.writeBackTotalInvoiceNum(rowinfo);
        }
      }
      if (updateV.size() > 0) {
        // 更新发票行
        InvoiceItemVO[] vos = new InvoiceItemVO[updateV.size()];
        updateV.copyInto(vos);
        // 修改为修改单据行数量的差值
        String key = vos[0].getCinvoiceid();
        Hashtable hIsRel = new Hashtable();
        InvoiceDMO dmo = new InvoiceDMO();
        InvoiceVO oldvos = dmo.findByPrimaryKey(key);
        InvoiceItemVO[] oldItemVOs = (InvoiceItemVO[]) oldvos.getChildrenVO();
        UFDouble num = null;
        if (oldItemVOs != null && oldItemVOs.length > 0 && vos != null && vos.length > 0) {
          for (int i = 0; i < oldItemVOs.length; i++) {
            InvoiceItemVO tempItem = oldItemVOs[i];
            for (int j = 0; j < vos.length; j++) {
              if (tempItem.getCinvoice_bid().equals(vos[j].getCinvoice_bid())) {
                num = vos[j].getNinvoicenum().sub(tempItem.getNinvoicenum());
              }
              if (num == null) {
                num = new UFDouble(0);
              }
              hIsRel.put(tempItem.getCinvoice_bid(), num);
            }
          }
        }

        dmoInvoice.updateItems(vos);
        // 回写VMI累计开票数量
        sourcebilltype = vos[0].getCsourcebilltype();
        if (sourcebilltype != null && sourcebilltype.equalsIgnoreCase("50")) {
          Object[][] rowinfoDel = null;
          Object[][] rowinfoUpdate = null;
          rowinfoDel = new Object[vos.length][2];
          rowinfoUpdate = new Object[vos.length][2];
          int delNum = 0;
          int updateNum = 0;
          for (int k = 0, loopk = vos.length; k < loopk; k++) {
            if (vos[k].getStatus() == VOStatus.DELETED) {// 删除
              rowinfoDel[delNum][0] = vos[delNum].getCsourcebillid();
              rowinfoDel[delNum][1] = vos[delNum].getNinvoicenum().multiply(-1);
              delNum++;
            }
            else if (vos[k].getStatus() == VOStatus.UPDATED) {// 修改
              rowinfoUpdate[updateNum][0] = vos[k].getCsourcebillid();
              rowinfoUpdate[updateNum][1] = hIsRel.get(vos[k].getCinvoice_bid());
              updateNum++;
            }
          }
          // nc.bs.so.so016.BillConvertDMO convertDMO = new
          if (rowinfoDel.length >= 1) {
            ((IICToPU_VmiSumDMO) oInstance).writeBackTotalInvoiceNum(rowinfoDel);
          }
          if (rowinfoUpdate.length >= 1) {
            ((IICToPU_VmiSumDMO) oInstance).writeBackTotalInvoiceNum(rowinfoUpdate);
          }
        }
      }

      // 组合保存之后的发票VO
      resultVO = new InvoiceVO(resultBodyVec.size());
      resultVO.setParentVO(hVO);
      InvoiceItemVO[] items = new InvoiceItemVO[resultBodyVec.size()];
      resultBodyVec.copyInto(items);
      resultVO.setChildrenVO(items);

      timer.addExecutePhase("增加、更新发票表体");

      if (bVOs == null || bVOs.length <= 0)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000073")/* @res "不存在表体行！" */);

      // 自动结算
      //For V56 by zhaoyha
      //根据不同的来源类型进行分单
      InvoiceVO[] splittedResultVOs=(InvoiceVO[])SplitBillVOs.getSplitVOs(InvoiceVO.class.getName(),
          InvoiceHeaderVO.class.getName(), InvoiceItemVO.class.getName(), new InvoiceVO[]{resultVO},
          null,    new String[] {"cupsourcebilltype"});
      ArrayList arrRet=null;
      for(InvoiceVO splittedVO:splittedResultVOs)
       arrRet= autoSettle(splittedVO, splittedVO, ((ArrayList) realParaList.get(2)), sSettleRule);
      timer.addExecutePhase("autoSettle method");

      // 返回发票VO
      list = new ArrayList();
      list.add(headKey);
      list.add(resultVO);
      list.add(arrRet);

      timer.showAllExecutePhase("采购发票保存操作：saveAInvoice结束");

    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.saveAInvoice(InvoiceVO, Object) Exception!", e);
    }
    return list;
  }

  /**
   * 作者：汪维敏 功能：自动结算 参数： 返回： 例外： 日期：(2004-10-21 14:10:43) 修改日期，修改人，修改原因，注释标志：
   */
  private ArrayList autoSettle(InvoiceVO resultVO, InvoiceVO invVO, ArrayList arrPara, String sSettleRule)
      throws BusinessException {
    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("autoSettle method begin:");

    // 参数：入库单转发票时的自动结算配置
    String sSettleParaForGeneral = null;
    // 参数：订单转发票时的自动结算配置
    String sSettleParaForOrder = null;
    // 参数：VMI转发票时的自动结算配置
    String sSettleParaForVMI = null;
    // 参数：直运销售转发票时的自动结算配置
    String sSettleParaForSO = null;

    String pk_corp = null;
    ArrayList arrRet = null;
    try {
      // 系统DMO
      ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
          ISysInitQry.class.getName());
      pk_corp = invVO.getHeadVO().getPk_corp();

      // 获取参数
      Hashtable tPara = initDMO.queryBatchParaValues(pk_corp, new String[] {
          "PO30", "PO46", "PO77", "PO79"
      });
      if (tPara != null && tPara.size() > 0) {
        Object oTemp = tPara.get("PO30");
        if (oTemp != null)
          sSettleParaForGeneral = oTemp.toString();
        oTemp = tPara.get("PO46");
        if (oTemp != null)
          sSettleParaForOrder = oTemp.toString();
        oTemp = tPara.get("PO77");
        if (oTemp != null)
          sSettleParaForVMI = oTemp.toString();
        oTemp = tPara.get("PO79");
        if (oTemp != null)
          sSettleParaForSO = oTemp.toString();
      }
      if (sSettleParaForGeneral == null || sSettleParaForGeneral.length() == 0)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000068")/*
                                   * @res "无法获取参数，不知道入库单转发票时是否要立即结算！"
                                   */);
      if (sSettleParaForOrder == null || sSettleParaForOrder.length() == 0)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000069")/*
                                   * @res "无法获取参数，不知道采购订单转发票时是否要立即结算！"
                                   */);
      if (sSettleParaForVMI == null || sSettleParaForVMI.length() == 0)
        throw new BusinessException("无法获取参数，不知道VMI转发票时是否要立即结算！");
      if (sSettleParaForSO == null || sSettleParaForSO.length() == 0)
        throw new BusinessException("无法获取参数，不知道直运销售转发票时是否要立即结算！");

      timer.addExecutePhase("获取是否结算参数");

      // 来源单据类型，虚拟发票不结算
      String sUpSourceBillType = invVO.getBodyVO()[0].getCupsourcebilltype();

      // since v55, 修正缺陷：如果本张发票的第一行即为自制的费用行，则其它存货行也没有机会参与自动结算了
      if (PuPubVO.getString_TrimZeroLenAsNull(sUpSourceBillType) == null) {
        for (InvoiceItemVO item : invVO.getBodyVO()) {
          sUpSourceBillType = item.getCupsourcebilltype();
          if (PuPubVO.getString_TrimZeroLenAsNull(sUpSourceBillType) != null) {
            break;
          }
        }
      }
      if (sUpSourceBillType != null && sUpSourceBillType.trim().length() > 0
          && resultVO.getHeadVO().getIinvoicetype().intValue() != 3) {
        // 发票来源于入库单{采购入库单、委外加工收货单、期初暂估入库单}
        if (sUpSourceBillType.equals("45") || sUpSourceBillType.equals("47") || sUpSourceBillType.equals("4T")) {
          // 受托代销类型不能自动结算
          if (sSettleParaForGeneral.equals("保存时自动结算") && !sSettleRule.trim().equals("S")
              && !sSettleRule.trim().equals("N")) {
            arrRet = doSettle(resultVO, InvoiceVO.FROM_STO, arrPara, sSettleRule, null);
          }
        }
        // 发票来源于采购订单
        else if (sUpSourceBillType.equals("21") && !sSettleRule.trim().equals("S") && !sSettleRule.trim().equals("N")) {
          // 直运类采购业务类型
          if (sSettleRule.trim().equals("Z")) {
            if ("保存时自动结算".equals(sSettleParaForSO)){
              //无入库环节(与订单结算)
              if(new PubDMO().isAutoSettle(invVO.getHeadVO().getCbiztype())){
                arrRet = doSettle(resultVO, InvoiceVO.FROM_ORDER, arrPara, sSettleRule, null);
              }
              //有入库环节(走PO46参数,与入库单结算)
              else if ("保存时自动结算".equals(sSettleParaForOrder)){
                SettleImpl beanSettle = new SettleImpl();
                arrRet = beanSettle.doOrderToInvoiceSettle(new InvoiceVO[] { resultVO }, arrPara, null);
                // 查询发票的累计结算数量/累计结算金额
                InvoiceDMO dmoInvoice = new InvoiceDMO();
                InvoiceItemVO[] tempBodyVO = null;
                // 没有结算不需查询
                ArrayList list = null;
                if (arrRet != null && arrRet.size() > 0)
                  list = (ArrayList) arrRet.get(0);
                if (list != null && list.size() > 0)
                  tempBodyVO = dmoInvoice.findItemsForHeader(invVO.getHeadVO().getCinvoiceid());
                if (tempBodyVO != null && tempBodyVO.length > 0){
                  invVO.setChildrenVO(tempBodyVO);
                }
                //return arrRet;
             }
            }
          }
          // 非直运类采购业务类型
          else if ("保存时自动结算".equals(sSettleParaForOrder)) {
            arrRet = doSettle(resultVO, InvoiceVO.FROM_ORDER, arrPara, sSettleRule, null);
          }
        }
        // 发票来源于消耗汇总记录
        else if (sUpSourceBillType.equals("50")) {
          if (sSettleParaForVMI.equals("保存时自动结算")) {
            arrRet = doSettle(resultVO, InvoiceVO.FROM_VMI, arrPara, sSettleRule, null);
          }
        }
      }
      String[] sRet = null;
      UFBoolean bSucceed = null;
      if (arrRet != null && arrRet.size() > 0) {
        bSucceed = (UFBoolean) arrRet.get(1);
        arrRet = (ArrayList) arrRet.get(0);
      }
      if (arrRet != null && arrRet.size() > 0) {
        sRet = new String[arrRet.size()];
        arrRet.toArray(sRet);
        // LockBOAccess lockBo = new LockBOAccess();
        // lockBo.freePKArrayByUser(sRet,invVO.getHeadVO().getCoperator(),"");
        LockTool.releaseLockForPks(sRet, (String) invVO.getHeadVO().getAttributeValue("cuserid"));
      }

      // 来源于采购订单的发票保存结算失败，可以保存
      if (PuPubVO.getString_TrimZeroLenAsNull(sUpSourceBillType) != null) {

        if ((sUpSourceBillType.equals("45") || sUpSourceBillType.equals("47") || sUpSourceBillType.equals("4T"))
            && sSettleParaForGeneral.equals("保存时自动结算") && !sSettleRule.equals("S") && !sSettleRule.equals("N")
            && !bSucceed.booleanValue()) {
          // 来源于入库单,结算失败,抛错
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040502",
              "UPP40040502-000093")/* @res "结算失败！" */);
        }
        if (sUpSourceBillType.equals("50") && sSettleParaForVMI.equals("保存时自动结算") && !bSucceed.booleanValue()) {
          // 来源于VMI,结算失败,抛错
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040502",
              "UPP40040502-000093")/* @res "结算失败！" */);
        }
      }

      timer.addExecutePhase("doSettle method");
      timer.showAllExecutePhase("采购发票自动结算 autoSettle 操作结束");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.autoSettle", e);
    }
    return arrRet;
  }

  /**
   * 作者：王印芬 功能：保存一张发票 备注：该方法为平台注册方法，请不要随意删除与修改；修改后请通知脚本，作相应修改。 参数： InvoiceVO
   * invVO 需保存的发票VO Object paraList 其他参数，真实数据结构为ArrayList. paraList[0]
   * 数量容差值，结构为Object[][3] Object[][0] 订单ID(String) Object[][1]
   * 对应订单ID的数量容差下限(UFDouble) Object[][2] 对应订单ID的数量容差上限(UFDouble) paraList[1]
   * 单价容差值，结构为Object[][3] Object[][0] 订单ID(String) Object[][1]
   * 对应订单ID的单价容差下限(UFDouble) Object[][2] 对应订单ID的单价容差上限(UFDouble) paraList[2]
   * 结算参数，结构为一个ArrayList 0当前日期(UFDate),1是否集团(UFBoolean) 返回：ArrayList 结构: [0]
   * String 该发票的KEY [1] InvoiceVO 保存后的带有新信息的发票VO
   * 例外：BusinessException，其中包裹BusinessException,SystemException 日期：(2001-6-9
   * 12:42:34) 修改日期，修改人，修改原因，注释标志： 2002-04-17 wyf 去掉锁 2002-04-18 wyf 去掉并发
   */
  public ArrayList saveInvoice(InvoiceVO invVO, Object paraList) throws BusinessException {

    // 检查自定义项
    IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());
    srv.checkDefDataType(invVO);
    
    ArrayList realParaList = (ArrayList) paraList;

    InvoiceHeaderVO hVO = invVO.getHeadVO();
    if (hVO.getCinvoiceid() != null && hVO.getCinvoiceid().trim().length() > 0) {
      hVO.setTlastmaketime((new UFDateTime(new Date())).toString());
      hVO.setTaudittime(null);
    }
    else {
      hVO.setTmaketime((new UFDateTime(new Date())).toString());
      hVO.setTaudittime(null);
      hVO.setTlastmaketime(hVO.getTmaketime());
    }
    if (hVO.getCcurrencytypeid() == null
        || (hVO.getCcurrencytypeid() != null && hVO.getCcurrencytypeid().trim().length() == 0)) {
      hVO.setCcurrencytypeid(invVO.getBodyVO()[0].getCcurrencytypeid());
    }
    //设置表体费用存货标志 For V56
    setFeeFlag(invVO);
    
    //保存时做源头为订单的表体尾差处理 V55 根据最新需求变更
    //陈恩宇 2009.6.2 邮件
    //V56需求变更：发票保存时不处理尾差（销售发票、采购发票、内部结算清单）
    //dealLastRemnant(invVO);
    
    // 返回值
    ArrayList list = null;
    try {
      OrderDMO dmo = new OrderDMO();
      // (本次开票数量+累计开票数量)*订单或入库单的数量>0
      InvoiceItemVO[] newItems = (InvoiceItemVO[]) invVO.getChildrenVO();

      Vector vTemp = new Vector();
      String sUpSourceRowID = null;
      String sUpSourceType = null;
//      /* 国泰控股集团、邢钢:
//       * 采购发票参照采购入库单生成时,对税率进行修改为零(表头和表体均改)后,税率和税额显示为零,但保存后仍为未修改前状态,不生效.
//       * 
//       */
//      String sSourceRowID = null;
//      String sSourceType = null;
//      String iDiscounttaxtype = "应税内含";
//      OrderItemVO[] orderItemVOs = null;
//      int[] descriptions = new int[] {
//          SCMRelationsCal.DISCOUNT_TAX_TYPE_NAME, SCMRelationsCal.DISCOUNT_TAX_TYPE_KEY, SCMRelationsCal.NUM,
//          SCMRelationsCal.NET_PRICE_ORIGINAL, SCMRelationsCal.NET_TAXPRICE_ORIGINAL, SCMRelationsCal.TAXRATE,
//          SCMRelationsCal.MONEY_ORIGINAL, SCMRelationsCal.TAX_ORIGINAL, SCMRelationsCal.SUMMNY_ORIGINAL
//      };
//      String[] keys = null;
//      for (int i = 0; i < newItems.length; i++) {
//        sUpSourceRowID = newItems[i].getCupsourcebillrowid();
//        sSourceRowID = newItems[i].getCsourcebillrowid();
//        sSourceType = newItems[i].getCsourcebilltype();
//        if (sUpSourceRowID != null)
//          vTemp.addElement(sUpSourceRowID);
//        if (newItems[i].getCupsourcebilltype() != null)
//          sUpSourceType = newItems[i].getCupsourcebilltype();
//        //since v55,自制入库单才取档案税率
//        if (sSourceType != null //&& sSourceType.equals("21")
//            && sSourceType.equals("45") 
//            && (newItems[i].getNtaxrate() == null 
//                || (newItems[i].getNtaxrate() != null && newItems[i].getNtaxrate().doubleValue() == 0))) {
//          String strFromWhere = null;
//          String ss = ScmDps.getSubSql("po_order_b", "po_order_b", hVO.getCoperator(),
//              new String[] { newItems[i].getPk_corp() });
//          if (ss != null && ss.trim().length() > 0){
//            strFromWhere += " and " + ss + " ";
//          }
//          orderItemVOs = dmo.queryBodyArrayByConds(" FROM po_order_b WHERE po_order_b.corder_bid = '" + sSourceRowID + "' ");
//          if (orderItemVOs != null && orderItemVOs.length > 0 && orderItemVOs[0] != null) {
//            newItems[i].setNtaxrate(orderItemVOs[0].getNtaxrate());
//            newItems[i].setIdiscounttaxtype(orderItemVOs[0].getIdiscounttaxtype());
//          }
//          if (newItems[i].getIdiscounttaxtype().intValue() == 1)
//            iDiscounttaxtype = "应税外加";
//          else if (newItems[i].getIdiscounttaxtype().intValue() == 2)
//            iDiscounttaxtype = "不计税";
//          keys = new String[] {
//              iDiscounttaxtype, "idiscounttaxtype", "ninvoicenum", "noriginalcurprice", "norgnettaxprice", "ntaxrate",
//              "noriginalcurmny", "noriginaltaxmny", "noriginalsummny"
//          };
//          String sPara = new PubDMO().getPricePriorPolicyString(newItems[i].getPk_corp());
//          if (realParaList != null && realParaList.size() > 5) {
//            SCMRelationsCal.calculate(new InvoiceItemVO[] { newItems[i] }, 
//                new int[] { RelationsCalVO.PRICE_PRIOR_TO_TAXPRICE }, "ntaxrate", descriptions, keys);
//          }
//          else {
//            SCMRelationsCal.calculate(new InvoiceItemVO[] {newItems[i]}, 
//                new int[] { new Integer((sPara.equals("含税价格优先") ? 
//                    new Integer(RelationsCalVO.TAXPRICE_PRIOR_TO_PRICE) : 
//                    new Integer(RelationsCalVO.PRICE_PRIOR_TO_TAXPRICE))).intValue()}, 
//                "ntaxrate", descriptions, keys);
//          }
//        }
//      }
     
      // 公用DMO
      nc.bs.pu.pub.PubDMO dmoPuPub = new nc.bs.pu.pub.PubDMO();
      // 核算规则
      Object[][] oRule = dmoPuPub.queryResultsFromAnyTable("bd_busitype", new String[] {
        "verifyrule"
      }, "pk_busitype='" + hVO.getCbiztype() + "'");
      if (oRule == null || oRule[0] == null || oRule[0][0] == null)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000072")/*
                                   * @res "未找到该单据业务类型对应核算规则!"
                                   */);
      String sStoreOrgId = hVO.getCstoreorganization();
      // 核算规则是直运的，要求必须有库存组织才能保存
      if (((String) oRule[0][0]).trim().equals("Z") && (sStoreOrgId == null || sStoreOrgId.trim().length() == 0)) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000090")/*
                                   * @res
                                   * "此业务类型的核算规则是直运类,要求必须有库存组织才能保存，请输入库存组织！"
                                   */);
      }

      // 保存发票:同时进行回写订单及进行结算等
      list = saveAInvoice(invVO, paraList, (String) oRule[0][0]);
      // 刷新VO
      // setInvVONewTs(invVO);
      list = refreshVO(list);

      // 回写完订单后再检查，否则会因数据不一致导致逻辑错误
      if (vTemp.size() > 0
          && sUpSourceType != null
          && (sUpSourceType.equals(ScmConst.PO_Order) || sUpSourceType.equals(ScmConst.SC_Order)
              || sUpSourceType.equals("45") || sUpSourceType.equals("47"))) {

        String sUpSourceRowIDs[] = new String[vTemp.size()];
        vTemp.copyInto(sUpSourceRowIDs);

        Object oTemp[][] = null;
        Object o = new InvoiceDMO().queryRelatedData(sUpSourceType, sUpSourceRowIDs);
        if (o != null)
          oTemp = (Object[][]) o;

        if (oTemp != null) {
          for (int i = 0; i < newItems.length; i++) {
            sUpSourceRowID = newItems[i].getCupsourcebillrowid();
            if (sUpSourceRowID == null || newItems[i].getStatus() == VOStatus.DELETED)
              continue;
            UFDouble dInvoiceNum = newItems[i].getNinvoicenum();
            if (dInvoiceNum == null)
              continue;
            for (int j = 0; j < sUpSourceRowIDs.length; j++) {
              if (sUpSourceRowID.equals(sUpSourceRowIDs[j])) {
                Object o1 = oTemp[j][0];
                Object o2 = oTemp[j][1];
                if (o1 != null && o2 != null) {
                  UFDouble dAccumInvoiceNum = new UFDouble(o1.toString());
                  UFDouble nNum = new UFDouble(o2.toString());
                  if ((dInvoiceNum.doubleValue() + dAccumInvoiceNum.doubleValue()) * nNum.doubleValue() < 0) {
                    throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
                        "UPP40040401-000063")/*
                                               * @res "存在发票数量和来源单据数量正负不一致,请检查！"
                                               */);
                  }
                }
              }
            }
          }
        }

      }

    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.saveInvoice(InvoiceVO, Object) Exception!", e);
    }
    return list;

  }

  /**
   * 作者：王印芬 功能：发票保存成功后，调用该方法查询新的时间戮，并更新发VO头体时间戮 该方法返回后，参数发票VO的时间戮已改变
   * 参数：InvoiceVO voInvoice 需更新时间戮的发票VO invVO必须是已保存成功的VO，若头或体ID任一为空或空串，则不正确 返回：无
   * 例外：BusinessException，其中包裹BusinessException,SystemException 日期：(2002-4-12
   * 12:42:34) 修改日期，修改人，修改原因，注释标志：
   */
  // private void setInvVONewTs(InvoiceVO voInvoice) throws BusinessException
  // {
  //
  // //检验参数正确性
  // if (voInvoice == null
  // || voInvoice.getHeadVO().getCinvoiceid() == null
  // || voInvoice.getHeadVO().getCinvoiceid().trim().length() < 1
  // || voInvoice.getBodyVO() == null
  // || voInvoice.getBodyVO().length < 1) {
  // SCMEnv.out("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO)传入参数不正确！");
  // return;
  // }
  // //体ID正确性
  // Vector vBKey = new Vector();
  // InvoiceItemVO[] voaItem = voInvoice.getBodyVO();
  // int iLen = voaItem.length;
  // for (int i = 0; i < iLen; i++) {
  // if (voaItem[i].getCinvoice_bid() == null ||
  // voaItem[i].getCinvoice_bid().trim().length() < 1) {
  // SCMEnv.out("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO)传入参数不正确！");
  // return;
  // }
  // vBKey.addElement(voaItem[i].getCinvoice_bid());
  // }
  //
  // Object[] oRet = null;
  // String[] saBKey = new String[vBKey.size()];
  // vBKey.copyInto(saBKey);
  // try {
  // oRet = new
  // nc.bs.pu.pub.PubDMO().queryHBTsArrayByHBIDArray(voInvoice.getHeadVO().getCbilltype(),
  // new String[] { voInvoice.getHeadVO().getCinvoiceid()}, //主表ID数组
  // saBKey, null);
  // } catch (Exception e) {
  //    
  // throw new BusinessException("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO)
  // Exception!", e);
  // }
  //
  // //未查到结果，该情况不正确
  // BusinessException expRemote = new
  // BusinessException("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO)
  // Exception!", new
  // SystemException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401","UPPSCMCommon-000428")/*@res
  // "系统故障！"*/));
  // if (oRet == null) {
  // SCMEnv.out("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO) Exception！");
  // throw expRemote;
  // }
  //
  // //头TS
  // String sTemp = ((String[]) oRet[0])[0];
  // if (sTemp == null) {
  // SCMEnv.out("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO) Exception！");
  // throw expRemote;
  // } else {
  // voInvoice.getHeadVO().setTs(sTemp);
  // }
  // //体TS
  // //iLen为发票体长度
  // String[] saBTs = (String[]) oRet[1];
  // if (saBTs == null || saBTs.length < 1) {
  // SCMEnv.out("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO) Exception！");
  // throw expRemote;
  // }
  // for (int i = 0; i < iLen; i++) {
  // if (saBTs[i] == null || saBTs[i].trim().length() < 1) {
  // SCMEnv.out("nc.bs.pi.InvoiceBO.setInvVONewTs(InvoiceVO) Exception！");
  // throw expRemote;
  // }
  // voaItem[i].setTs(saBTs[i]);
  // }
  //
  // return;
  // }
  /**
   * 作者：汪维敏 功能：采购订单自动结算 参数： 返回： 例外： 日期：(2004-10-21 14:10:43) 修改日期，修改人，修改原因，注释标志：
   */
  private ArrayList settleForOrder(InvoiceVO vo, String sRule, ArrayList paraList, String strOprType) throws BusinessException {

    InvoiceItemVO[] items = vo.getBodyVO();
    InvoiceItemVO[] validItems = null;
    InvoiceHeaderVO head = vo.getHeadVO();
    //
    if (head == null || head.getCbiztype() == null) {
      SCMEnv.out("head.getCbiztype() == null, return directly");
    }
    // 处理是否有入库环节，如果有入库环节，则直接返回，不自动结算

    // ......... 待完成代码 .........

    //
    ArrayList arrRet = null;
    try {
      nc.bs.ps.settle.SettleImpl beanSettle = new nc.bs.ps.settle.SettleImpl();
      // 公用DMO
      nc.bs.pu.pub.PubDMO dmoPuPub = new nc.bs.pu.pub.PubDMO();

      // ------------非直运类核算规则的业务结算------------
      if (!sRule.trim().equals("Z")) {
        arrRet = beanSettle.doOrderToInvoiceSettle(new InvoiceVO[] {
          vo
        }, paraList, strOprType);
        // 查询发票的累计结算数量/累计结算金额
        InvoiceDMO dmoInvoice = new InvoiceDMO();
        InvoiceItemVO[] tempBodyVO = null;
        // 没有结算不需查询
        ArrayList list = null;
        if (arrRet != null && arrRet.size() > 0)
          list = (ArrayList) arrRet.get(0);
        if (list != null && list.size() > 0)
          tempBodyVO = dmoInvoice.findItemsForHeader(head.getCinvoiceid());
        if (tempBodyVO != null && tempBodyVO.length > 0)
          vo.setChildrenVO(tempBodyVO);
        return arrRet;
      }

      // ------------直运类核算规则的业务结算------------

      // 需要结算的进行结算
      Vector settleVOVEC = new Vector();
      Vector settleStoOrgVEC = new Vector();

      // ///////////////////////////////////////////////////////
      // 采购订单表头Id
      String[] sCorderId1 = null;
      ArrayList arrCorderId1 = new ArrayList();
      // 委外订单表头Id
      String[] sCorderId2 = null;
      ArrayList arrCorderId2 = new ArrayList();

      // 存货基础档案Id
      String[] sCbaseId = null;
      ArrayList arrCbaseId = new ArrayList();

      // add by yye for v5 begin
      // 采购订单表体Id
      String[] sCorder_Bid = null;
      ArrayList arrCorder_Bid = new ArrayList();
      // add by yye for v5 end

      // 获取用于批处理的值
      for (int i = 0; i < items.length; i++) {
        if (items[i].getCupsourcebilltype() != null
            && items[i].getCupsourcebilltype().equals(nc.vo.scm.pu.BillTypeConst.PO_ORDER)) {
          arrCorderId1.add(items[i].getCorderid());
          arrCorder_Bid.add(items[i].getCorder_bid());// add by yye
          // for v5

        }
        else if (items[i].getCupsourcebilltype() != null
            && items[i].getCupsourcebilltype().equals(nc.vo.scm.pu.BillTypeConst.SC_ORDER)) {
          arrCorderId2.add(items[i].getCorderid());

        }
        if (items[i].getCupsourcebilltype() != null && items[i].getCupsourcebilltype().trim().length() > 1)
          arrCbaseId.add(items[i].getCbaseid());
      }
      // 转换为数组
      if (arrCorderId1.size() > 0) {
        sCorderId1 = new String[arrCorderId1.size()];
        arrCorderId1.toArray(sCorderId1);
      }
      if (arrCorderId2.size() > 0) {
        sCorderId2 = new String[arrCorderId2.size()];
        arrCorderId2.toArray(sCorderId2);
      }

      if (arrCbaseId.size() > 0) {
        sCbaseId = new String[arrCbaseId.size()];
        arrCbaseId.toArray(sCbaseId);
      }

      // add by yye for v5 begin
      if (arrCorder_Bid.size() > 0) {
        // 得到采购订单表体Id数组
        sCorder_Bid = new String[arrCorder_Bid.size()];
        arrCorder_Bid.toArray(sCorder_Bid);
      }
      // add by yye for v5 end

      /*
       * comment by yye for v5 //获取采购订单库存组织 HashMap hCorderId1 = null; if
       * (sCorderId1 != null && sCorderId1.length > 0) hCorderId1 =
       * dmoPuPub.queryArrayValues("po_order", "corderid", new String[] {
       * "cstoreorganization" }, sCorderId1, "po_order.dr=0");
       */

      // add by yye for v5 begin
      HashMap hCorder_Bid = null;
      if (sCorder_Bid != null && sCorder_Bid.length > 0) {
        hCorder_Bid = dmoPuPub.queryArrayValues("po_order_b", "corder_bid", new String[] {
          "pk_arrvstoorg"
        }, sCorder_Bid, "po_order_b.dr=0");
      }
      // add by yye for v5 end

      // 获委外订单的库存组织
      HashMap hCorderId2 = null;
      if (sCorderId2 != null && sCorderId2.length > 0)
        hCorderId2 = dmoPuPub.queryArrayValues("sc_order", "corderid", new String[] {
          "cwareid"
        }, sCorderId2, "sc_order.dr=0");

      // 存货的劳务，折扣标志
      HashMap hCbaseId = null;
      if (sCbaseId != null && sCbaseId.length > 0)
        hCbaseId = dmoPuPub.queryArrayValues("bd_invbasdoc", "pk_invbasdoc", new String[] {
            "discountflag", "laborflag"
        }, sCbaseId, "bd_invbasdoc.dr=0");
      // ///////////////////////////////////////////////////////
      for (int i = 0; i < items.length; i++) {
        // 只处理从订单转入的行
        if (items[i].getCupsourcebilltype() != null && items[i].getCupsourcebilltype().trim().length() > 1) {
          // ==============得到该行对应库存组织及计量单位
          // 从采购还是委外订单转入
          Object[] s1 = null;

          Object[] s3 = null;
          if (items[i].getCupsourcebilltype() != null
              && items[i].getCupsourcebilltype().equals(nc.vo.scm.pu.BillTypeConst.PO_ORDER)) {
            /*
             * comment by yye for v5 if (hCorderId1 != null) s1 = (Object[])
             * hCorderId1.get(items[i].getCorderid());
             */

            // add by yye for v5 begin
            if (hCorder_Bid != null)
              s1 = (Object[]) hCorder_Bid.get(items[i].getCorder_bid());
            // add by yye for v5 end

          }
          else if (items[i].getCupsourcebilltype() != null
              && items[i].getCupsourcebilltype().equals(nc.vo.scm.pu.BillTypeConst.SC_ORDER)) {
            if (hCorderId2 != null)
              s1 = (Object[]) hCorderId2.get(items[i].getCorderid());

          }
          if (s1 == null && s1[0] == null) {
            throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
                "UPP40040401-000091")/*
                                       * @res "找不到相关某订单行对应的库存组织！"
                                       */);
          }
          // 结算时的存货：非劳务，非折扣
          if (hCbaseId != null)
            s3 = (Object[]) hCbaseId.get(items[i].getCbaseid());
          if (s3 == null) {
            throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
                "UPP40040401-000092")/*
                                       * @res "不能判断某存货的劳务或折扣属性，发票不能保存！"
                                       */);
          }
          if (s3[0].toString().equals("Y") || s3[1].toString().equals("Y")) {
            continue;
          }
          // 加入到可以结算的行列中
          settleVOVEC.add(items[i]);
          settleStoOrgVEC.add((s1 == null || s1[0] == null) ? null : (String) s1[0]);

        }
      }
      if (settleVOVEC.size() == 0) {
        SCMEnv.out("直运订单生成发票所有发票行都不是从订单转入.");
        return null;
      }
      // 拷贝需结算的数据
      validItems = new InvoiceItemVO[settleVOVEC.size()];
      String[] validOrgs = new String[settleStoOrgVEC.size()];

      settleVOVEC.copyInto(validItems);
      settleStoOrgVEC.copyInto(validOrgs);

      // 直运业务类型的库存组织不能为空
      // 如果不能从订单获取库存组织，则从发票获取
      if (validOrgs == null || validOrgs.length == 0 || validOrgs[0] == null) {
        if (sRule.trim().equals("Z")) {
          int size = validItems.length;
          validOrgs = new String[size];
          for (int i = 0; i < size; i++)
            validOrgs[i] = head.getCstoreorganization();
        }
      }
      vo.setChildrenVO(validItems);

      // 结算
      if (head.getCauditpsn() != null) {
        beanSettle.doDirectInvoiceBalance(head.getCaccountyear(), (UFDate) paraList.get(0), head.getCbiztype(), head
            .getCauditpsn(), head.getPk_corp(), vo, validOrgs, strOprType);
      }
      else {
        beanSettle.doDirectInvoiceBalance(head.getCaccountyear(), (UFDate) paraList.get(0), head.getCbiztype(), head
            .getCoperator(), head.getPk_corp(), vo, validOrgs, strOprType);
      }
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.settleForOrder", e);
    }

    return arrRet;
  }

  /**
   * @作者 zhf
   * @创建时间：2008-7-3下午12:59:38
   * @param vo
   * @param paraList
   * @throws BusinessException
   * @return ArrayList
   * @说明：(for v5.5) 根据VMI开票自动结算 支持部分开票结算自动暂估
   * @修改者：
   * @修改时间：
   * @修改说明：
   */

  private ArrayList settleForVMI(InvoiceVO vo, ArrayList paraList, String strOprType) throws BusinessException {
    InvoiceHeaderVO head = vo.getHeadVO();
    String estimateModule = queryEstimateModule(vo.getHeadVO().getPk_corp());
    String diffModule = queryDiffModule(vo.getHeadVO().getPk_corp());
    ArrayList arrRet = null;

    try {
      if (head.getCauditpsn() != null) {
        arrRet = new VMIImpl().doVMI2InvoiceSettle(vo, head.getCaccountyear(), (UFDate) paraList.get(0), head
            .getPk_corp(), head.getCauditpsn(), estimateModule, diffModule, (UFBoolean) paraList.get(2), strOprType);
      }
      else {
        arrRet = new VMIImpl().doVMI2InvoiceSettle(vo, head.getCaccountyear(), (UFDate) paraList.get(0), head
            .getPk_corp(), head.getCoperator(), estimateModule, diffModule, (UFBoolean) paraList.get(2), strOprType);
      }
    }
    catch (Exception e) {
      PubDMO.throwBusinessException(e);
    }

    return arrRet;
  }

  /**
   * 作者：汪维敏 功能：根据入库单生成发票自动结算 参数： 返回： 例外： 日期：(2004-10-21 14:10:43)
   * 修改日期，修改人，修改原因，注释标志：
   */
  private ArrayList settleForSto(InvoiceVO vo, ArrayList paraList,String strOprType) throws BusinessException {
    InvoiceItemVO[] items = vo.getBodyVO();
    InvoiceItemVO[] validItems = null;
    InvoiceHeaderVO head = vo.getHeadVO();
    ArrayList arrRet = null;

    try {
      nc.bs.ps.settle.SettleImpl beanSettle = new nc.bs.ps.settle.SettleImpl();
      // 公用DMO
      nc.bs.pu.pub.PubDMO dmoPuPub = new nc.bs.pu.pub.PubDMO();
      InvoiceDMO dmoInvoice = new InvoiceDMO();

      String[] sCbaseId = null;
      ArrayList arrCbaseId = new ArrayList();
      int size = items.length;

      for (int i = 0; i < size; i++) {
        if (items[i].getCupsourcebilltype() != null && items[i].getCupsourcebilltype().trim().length() > 1)
          arrCbaseId.add(items[i].getCbaseid());
      }

      if (arrCbaseId.size() > 0) {
        sCbaseId = new String[arrCbaseId.size()];
        arrCbaseId.toArray(sCbaseId);
      }

      HashMap hCbaseId = null;
      if (sCbaseId != null && sCbaseId.length > 0)
        hCbaseId = dmoPuPub.queryArrayValues("bd_invbasdoc", "pk_invbasdoc", new String[] {
            "discountflag", "laborflag"
        }, sCbaseId, "bd_invbasdoc.dr=0");

      // 发票行的入库单VO转化为数组
      Vector settleVOVEC = new Vector();
      Vector settleHVEC = new Vector();
      Vector settleBVEC = new Vector();
      Vector settleBb3VEC = new Vector();

      ArrayList arrWhere = new ArrayList();
      String[] sWhere = null;
      for (int i = 0; i < items.length; i++) {
        // 只处理从入库单转入的行
        if (items[i].getCupsourcebilltype() != null && items[i].getCupsourcebilltype().trim().length() > 1) {
          Object[] s1 = null;
          // 结算时的存货：非劳务，非折扣
          if (hCbaseId != null)
            s1 = (Object[]) hCbaseId.get(items[i].getCbaseid());
          if (s1 == null) {
            throw new BusinessException(NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000092")/* @res"不能判断某存货的劳务或折扣属性，发票不能保存！" */);
          }
          if (s1[0].toString().equals("Y") || s1[1].toString().equals("Y")) {
            continue;
          }
          arrWhere.add(items[i].getCupsourcebillrowid());
          settleVOVEC.add(items[i]);
        }
      }

      if (settleVOVEC.size() == 0) {
        SCMEnv.out("入库单生成发票所有发票行都不是从入库单转入.");/*-=notranslate=-*/
        throw new BusinessException(NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000261")/* @res"入库单开发票自动结算异常：入库单生成发票所有发票行都不是从入库单转入" */);
      }
      if (arrWhere.size() > 0) {
        sWhere = new String[arrWhere.size()];
        arrWhere.toArray(sWhere);
      }
      String strIdsSet = "";
      nc.bs.scm.pub.TempTableDMO tmpTblDmo = new nc.bs.scm.pub.TempTableDMO();
      strIdsSet = tmpTblDmo.insertTempTable(sWhere, nc.vo.scm.pub.TempTableVO.TEMPTABLE_PU_PI008,
          nc.vo.scm.pub.TempTableVO.TEMPPKFIELD_PU);
      if (strIdsSet == null || strIdsSet.trim().length() == 0)
        strIdsSet = "('TempTableDMOError')";

      String strWhere = "( ic_general_b.cgeneralbid in " + strIdsSet + ")";
      Object[] obGeneVO = dmoInvoice.findGeneralVOsFromIDs(strWhere);
      Vector geneHVEC = (Vector) obGeneVO[0];
      Vector geneBVEC = (Vector) obGeneVO[1];
      Vector geneBB3VEC = (Vector) obGeneVO[2];

      // v5调整 xhq 2006-03-02,
      // 暂时注释掉
      // Vector vReturn =
      // preDealStockVO(head.getPk_corp(),geneHVEC,geneBVEC,geneBB3VEC);
      // if(vReturn != null && vReturn.size() > 0){
      // geneHVEC = (Vector)vReturn.elementAt(0);
      // geneBVEC = (Vector)vReturn.elementAt(1);
      // geneHVEC = (Vector)vReturn.elementAt(2);
      // }
      // 暂时注释掉

      for (int i = 0; i < settleVOVEC.size(); i++) {
        String strUPBid = ((InvoiceItemVO) settleVOVEC.get(i)).getCupsourcebillrowid();

        boolean bVOExisted = false;
        for (int j = 0; j < geneHVEC.size(); j++) {
          if (((GeneralBillItemVO) geneBVEC.get(j)).getCgeneralbid().equals(strUPBid)) {
            settleHVEC.add((GeneralBillHeaderVO) geneHVEC.get(j));
            settleBVEC.add((GeneralBillItemVO) geneBVEC.get(j));
            settleBb3VEC.add((GeneralBb3VO) geneBB3VEC.get(j));

            // 采购发票审批时自动结算，提示“：相关入库单行已被删除，不能继续生成发票！”；控制错误；场景：入库单生成发票，复制发票行时
            // geneHVEC.remove(j);
            // geneBVEC.remove(j);
            // geneBB3VEC.remove(j);

            bVOExisted = true;
            break;
          }
        }
        if (bVOExisted == false) {
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000093")/*
                                     * @res "表体" + CommonConstant.BEGIN_MARK +
                                     * nRow + CommonConstant.END_MARK +
                                     * "：相关入库单行已被删除，不能继续生成发票！"
                                     */);
        }
      }

      // 拷贝需结算的数据
      validItems = new InvoiceItemVO[settleVOVEC.size()];
      GeneralBillHeaderVO[] gHeads = new GeneralBillHeaderVO[settleHVEC.size()];
      GeneralBillItemVO[] gItems = new GeneralBillItemVO[settleBVEC.size()];
      GeneralBb3VO[] gBb3s = new GeneralBb3VO[settleBb3VEC.size()];
      settleVOVEC.copyInto(validItems);
      settleHVEC.copyInto(gHeads);
      settleBVEC.copyInto(gItems);
      settleBb3VEC.copyInto(gBb3s);
      vo.setChildrenVO(validItems);

      // 结算
      if (head.getCauditpsn() != null) {
        arrRet = beanSettle.doStockToInvoiceSettle(head.getCaccountyear(), (UFDate) paraList.get(0),
            head.getCbiztype(), head.getCauditpsn(), head.getPk_corp(), vo, gHeads, gItems, gBb3s,
            queryEstimateModule(vo.getHeadVO().getPk_corp()), queryDiffModule(vo.getHeadVO().getPk_corp()),
            (UFBoolean) paraList.get(2), strOprType);
      }
      else {
        arrRet = beanSettle.doStockToInvoiceSettle(head.getCaccountyear(), (UFDate) paraList.get(0),
            head.getCbiztype(), head.getCoperator(), head.getPk_corp(), vo, gHeads, gItems, gBb3s,
            queryEstimateModule(vo.getHeadVO().getPk_corp()), queryDiffModule(vo.getHeadVO().getPk_corp()),
            (UFBoolean) paraList.get(2), strOprType);
      }

    }
    catch (Exception e) {

      PubDMO.throwBusinessException(e);
    }
    return arrRet;
  }

  // /**
  // * 弃审一张发票,该发票的"单据状态"由"审批"变为"自由"
  // *
  // * @param (1)invVO
  // * 待审批的请购单
  // * @return 无
  // * @exception 异常描述
  // * @see 需要参见的其它内容
  // * @sin 从类的那一个版本，此方法被添加进来。（可选）
  // * @param invVO
  // * nc.vo.pa.InvoiceVO
  // */
  // private void aunAuditAInvoice(InvoiceVO invVO) throws BusinessException {
  // // 1 弃审发票
  // InvoiceHeaderVO headVO = invVO.getHeadVO();
  // try {
  // // 更新
  // new InvoiceDMO().updateIbillStatusAndApproveForHID(
  // headVO.getCinvoiceid(), 0, null, null);
  // // 删除标志
  // headVO.setDr(new Integer(0));
  // // 弃审标志、审批人、审批日期
  // headVO.setIbillstatus(new Integer(0));
  // headVO.setCauditpsn(null);
  // headVO.setDauditdate(null);
  // }
  // catch (Exception e) {
  //
  // PubDMO.throwBusinessException(
  // "nc.bs.pi.InvoiceBO.unAuditAInvoice(InvoiceVO)", e);
  // }
  // }

  /**
   * 作者：王印芬 功能：弃审一组发票 备注：该方法为平台注册方法，请不要随意删除与修改；修改后请通知脚本，作相应修改。 参数： InvoiceVO[]
   * voaInvoice 需弃审的发票VO数组 返回：无
   * 例外：BusinessException，其中包裹BusinessException,SystemException 日期：(2002-4-28
   * 12:42:34) 修改日期，修改人，修改原因，注释标志：
   */
  public void unAuditInvoiceArray(InvoiceVO[] voaInvoice) throws BusinessException {

    try {
      //For V56 by zhaoyha
      //根据不同的来源类型进行分单
      voaInvoice=(InvoiceVO[])SplitBillVOs.getSplitVOs(InvoiceVO.class.getName(),
          InvoiceHeaderVO.class.getName(), InvoiceItemVO.class.getName(), voaInvoice,
          new String[]{"cinvoiceid"},    new String[] {"cupsourcebilltype"});
      // 系统DMO
      nc.bs.pub.para.SysInitDMO initDMO = new nc.bs.pub.para.SysInitDMO();
      InvoiceHeaderVO headVO = voaInvoice[0].getHeadVO();
      String pk_corp = headVO.getPk_corp();
      // 获取参数: 入库单转发票时的自动结算配置
      String sParaSettleInTime = initDMO.getParaString(pk_corp, "PO30");
      String sParaSettleInTimeOrder = initDMO.getParaString(pk_corp, "PO46");
      String sParaSettleInTimeZY = initDMO.getParaString(pk_corp, "PO79");//直运
      String sParaZGYF = initDMO.getParaString(pk_corp, "PO52");
      UFBoolean bZGYF = new UFBoolean(false);
      if (sParaZGYF != null)
        bZGYF = new UFBoolean(sParaZGYF);

      if (sParaSettleInTime == null || sParaSettleInTime.length() <= 0)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000094")/* @res "无法获取参数PO30！" */);
      if (sParaSettleInTimeOrder == null || sParaSettleInTimeOrder.length() <= 0)
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
            "UPP40040401-000229")/* @res "无法获取参数PO46！" */);
      if (sParaSettleInTimeZY == null || sParaSettleInTimeZY.length() <= 0)
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000271")/* @res "无法获取参数PO79！" */);

      Hashtable hRule = new Hashtable();// 核算规则
      String sRule = null;
      /**********************/
      // 核算规则
      String cinvoiceid[] = new String[voaInvoice.length];
      for (int i = 0; i < voaInvoice.length; i++) {
        cinvoiceid[i] = voaInvoice[i].getHeadVO().getCinvoiceid();
      }
      InvoiceDMO dmo = new InvoiceDMO();
      hRule = dmo.queryVerifyRuleAndBillStatus(cinvoiceid);
      // 哈希表{业务类型主键=是否无入库环节(需要自动结算)}
      ArrayList<String> listBizTypeId = new ArrayList<String>();
      String strBizTypeId = null;
      for (InvoiceVO vo : voaInvoice) {
        strBizTypeId = vo.getHeadVO().getCbiztype();
        if (strBizTypeId == null) {
          continue;
        }
        Object oTemp = hRule.get(vo.getHeadVO().getCinvoiceid());
        if (oTemp == null) {
          continue;
        }
        Object data[] = (Object[]) oTemp;
        String verifyrule = (String) data[1];
        if ("Z".equals(verifyrule) && !listBizTypeId.contains(strBizTypeId)) {
          listBizTypeId.add(strBizTypeId);
        }
      }
      Hashtable<String, UFBoolean> mapBizAutoSettle = null;
      if (listBizTypeId.size() > 0) {
        String[] saBiztypeId = listBizTypeId.toArray(new String[listBizTypeId.size()]);
        mapBizAutoSettle = new PubDMO().getNoStoreStepHash(saBiztypeId);
      }
      if (mapBizAutoSettle == null) {
        mapBizAutoSettle = new Hashtable<String, UFBoolean>();
      }
      /**********************/
      for (int i = 0; i < voaInvoice.length; i++) {
        headVO = voaInvoice[i].getHeadVO();
//        if (hRule.get(headVO.getCbiztype()) == null) {
//          // 获得核算规则
//          Object[][] oRule = new nc.bs.pu.pub.PubDMO().queryResultsFromAnyTable("bd_busitype", new String[] {
//            "verifyrule"
//          }, "pk_busitype='" + headVO.getCbiztype() + "'");
//          if (oRule == null || oRule[0][0] == null)
//            throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
//                "UPP40040401-000072")/*
//                                       * @res "未找到该单据业务类型对应核算规则!"
//                                       */);
//          hRule.put(headVO.getCbiztype(), oRule[0][0]);
//        }
        Object oTemp = hRule.get(headVO.getCinvoiceid());
        if (oTemp == null)
          continue;
        Object data[] = (Object[]) oTemp;
        sRule = (String) data[1];
//        sRule = (String) hRule.get(headVO.getCbiztype());

        // 来源单据类型
        String sUpSourceBillType = voaInvoice[i].getBodyVO()[0].getCupsourcebilltype();
        // 已结算的发票：不可弃审
        if (sUpSourceBillType != null && sUpSourceBillType.trim().length() > 0
            && headVO.getIinvoicetype().intValue() != 3) {
          if (sUpSourceBillType.equals("45") || sUpSourceBillType.equals("47") || sUpSourceBillType.equals("4T")) {
            if (!sRule.trim().equals("S") && sParaSettleInTime.equals("审批时自动结算")) {
              if (checkIsGenSettle(voaInvoice[i], bZGYF)) {
                throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
                "UPP40040401-000095")/*
                 * @res "发票已结算，不能弃审，请先删除结算单！"
                 */);
              }
            }
          }
          else if (sUpSourceBillType.equals(ScmConst.PO_Order)) {
            if (!sRule.trim().equals("Z") 
                && sParaSettleInTimeOrder.equals("审批时自动结算") 
                && checkIsGenSettle(voaInvoice[i], bZGYF)) {
              throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
              "UPP40040401-000095")/*
               * @res "发票已结算，不能弃审，请先删除结算单！"
               */);
              }
              //直运时，分两种情况：无入库环节、有入库环节
            }else if (sRule.trim().equals("Z") ){
              //无入库环节
              if(mapBizAutoSettle.containsKey(headVO.getCbiztype())
                  && mapBizAutoSettle.get(headVO.getCbiztype()).booleanValue()){
                if ( sParaSettleInTimeZY.equals("审批时自动结算") && checkIsGenSettle(voaInvoice[i], bZGYF)){
                  throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
                  "UPP40040401-000095")/*
                   * @res "发票已结算，不能弃审，请先删除结算单！"
                   */);
                }
              }else if (sParaSettleInTimeOrder.equals("审批时自动结算") && checkIsGenSettle(voaInvoice[i], bZGYF)){
                throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40040401",
                "UPP40040401-000095")/*
                 * @res "发票已结算，不能弃审，请先删除结算单！"
                 */);
                }
            }
          }
        }

        // 弃审 取消业务组对弃审后的状态操作
        // unAuditAInvoice(voaInvoice[i]);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.unAuditInvoiceArray(InvoiceVO [])", e);
    }
  }
  private boolean checkIsGenSettle(InvoiceVO vo,UFBoolean bZGYF){
    boolean isGenSettle = false;
    double d1 = 0.0;
    for (int j = 0; j < vo.getBodyVO().length; j++) {
      d1 = 0.0;
      if (vo.getBodyVO()[j].getNaccumsettmny() != null) {
        d1 = vo.getBodyVO()[j].getNaccumsettmny().doubleValue();
      }
      if (d1 != 0.0 && !bZGYF.booleanValue()) {
        isGenSettle = true;
      }
    }
    return isGenSettle;
  }

  /**
   * 作者：方益 功能：根据发票体中的存货价格回写存货档案的价格 参数：InvoiceVO vo 发票表头VO 返回：void
   * 例外：SQLException SQL异常 日期：(2001-08-04 11:39:21) 修改日期，修改人，修改原因，注释标志：
   */
  public void updateCostPriceForInv(InvoiceVO vo) throws BusinessException {

    // 入口参数判断
    if (vo == null || vo.getChildrenVO() == null)
      return;

    // 金额和数量合法性检查
    Vector v = new Vector();
    InvoiceItemVO[] items = (InvoiceItemVO[]) vo.getChildrenVO();
    String sStoreOrg = vo.getHeadVO().getCstoreorganization();
    String sPk_corp = vo.getHeadVO().getPk_corp();
    for (int i = 0; i < items.length; i++) {
      UFDouble num = items[i].getNinvoicenum();
      UFDouble sum = items[i].getNmoney();

      // 金额和数量不为空
      if (sum == null || num == null)
        continue;

      // 金额数量不为0
      if (sum.doubleValue() == 0 || num.doubleValue() == 0)
        continue;

      v.add(items[i]);
    }

    // 更新到存货管理档案
    InvoiceItemVO[] updateItems = null;
    if (v.size() > 0) {
      updateItems = new InvoiceItemVO[v.size()];
      v.copyInto(updateItems);
    }
    if (updateItems != null) {
      try {
        InvoiceDMO dmo = new InvoiceDMO();
        dmo.updateCostPriceForInv(updateItems, sStoreOrg, sPk_corp);
      }
      catch (Exception e) {

        PubDMO.throwBusinessException("InvoiceBean::updateRefSalePriceForInv(InvoiceVO) Exception!", e);
      }
    }
  }

  /**
   * 作者：汪维敏 功能：回写单据（采购订单、委外订单、采购入库单）,并进行数量容差和价格容差控制 参数：InvoiceVO
   * 例外：BusinessException 创建日期：(2004-2-27 16:42:43)
   */
  private void writeBackBill(InvoiceVO invVO) throws BusinessException {
    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("采购发票回写操作writeBackBill开始");

    InvoiceItemVO[] bVOs = invVO.getBodyVO();
    InvoiceVO writeBackVO = new InvoiceVO();
    writeBackVO.setParentVO(invVO.getParentVO());
    if (invVO.getUserConfirmFlag() != null)
      writeBackVO.setUserConfirmFlag(invVO.getUserConfirmFlag());
    try {
      String sBillType = bVOs[0].getCupsourcebilltype();
      // 回写采购订单，并进行数量容差和价格容差控制
      if (sBillType != null && sBillType.equals(nc.vo.scm.pu.BillTypeConst.PO_ORDER)) {
        //如果是费用发票(前面分单处理过,费用放到一张发票上),则调用专门接口
        if(bVOs[0].getBFeeFlag()!=null && bVOs[0].getBFeeFlag().booleanValue())
          writeBackToPoFeeOrder(invVO);
        else 
          writeBackToPoOrder(invVO, false,invVO.getHeadVO().getDr()==1?true:false);
        timer.addExecutePhase("回写采购订单writeBackToPoOrder");
      }
      // 回写委外订单
      else if (sBillType != null && sBillType.equals(nc.vo.scm.pu.BillTypeConst.SC_ORDER)) {
        writeBackToScOrder(invVO);
        timer.addExecutePhase("回写委外订单writeBackToScOrder");
      }
      // 回写采购入库单
      else if (sBillType != null
          && (sBillType.equals(nc.vo.scm.pu.BillTypeConst.STORE_PO)
              || sBillType.equals(nc.vo.scm.pu.BillTypeConst.STORE_ES) || sBillType
              .equals(nc.vo.scm.pu.BillTypeConst.STORE_SC))) {
        writeBackToIc(invVO);
        timer.addExecutePhase("回写采购入库单writeBackToIc");
        // 从采购入库单生成的发票要对订单进行价格容差，并回写累计发票数量
        ArrayList arr = new ArrayList();
        InvoiceItemVO[] items = (InvoiceItemVO[]) invVO.getChildrenVO();
        for (int i = 0; i < items.length; i++) {
          if (items[i].getCorder_bid() != null && items[i].getCorder_bid().length() > 0)
            arr.add(items[i]);
        }
        InvoiceItemVO[] bodyItems = null;
        if (arr.size() > 0) {
          bodyItems = new InvoiceItemVO[arr.size()];
          arr.toArray(bodyItems);
        }
        if (bodyItems != null && bodyItems.length > 0) {
          writeBackVO.setChildrenVO(bodyItems);
          // invVO.setChildrenVO(bodyItems);
          if (sBillType.equals(nc.vo.scm.pu.BillTypeConst.STORE_PO)
              || sBillType.equals(nc.vo.scm.pu.BillTypeConst.STORE_ES))
            writeBackToPoOrder(writeBackVO, true, false);
          else if (sBillType.equals(nc.vo.scm.pu.BillTypeConst.STORE_SC))
            writeBackToScOrder(writeBackVO);
          timer.addExecutePhase("回写采购订单writeBackToPoOrder");
        }
      }
      timer.showAllExecutePhase("采购发票回写操作writeBackBill结束");

    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.writeBackBill(InvoiceVO) Exception!", e);
    }
  }

  /**
   * 作者：汪维敏 功能：回写单据采购入库单 参数：InvoiceVO 例外：BusinessException 创建日期：(2004-2-27
   * 16:42:43)
   */
  private void writeBackToIc(InvoiceVO invVO) throws BusinessException {
    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("回写单据采购入库单操作writeBackToIc开始");

    InvoiceItemVO[] bVOs = invVO.getBodyVO();
    try {
      // 发票DMO
      InvoiceDMO dmoInvoice = new InvoiceDMO();

      // 用于回写采购入库单
      ArrayList arrIc = new ArrayList();
      nc.vo.scm.puic.ParaPoToIcLendRewriteVO[] vos = null;

      // 获取用于批处理的数据
      int iRowCount = bVOs.length;
      String[] sPrimaryKeys = null;
      ArrayList arr = new ArrayList();
      for (int i = 0; i < iRowCount; i++) {
        String temp = bVOs[i].getPrimaryKey();
        if (temp != null && temp.length() > 0)
          arr.add(temp);
      }
      if (arr.size() > 0) {
        sPrimaryKeys = new String[arr.size()];
        arr.toArray(sPrimaryKeys);
      }

      // 得到当前发票行的原有发票数量
      HashMap hInvoiceNum = new HashMap();
      if (sPrimaryKeys != null && sPrimaryKeys.length > 0)
        hInvoiceNum = dmoInvoice.findInvoiceNumByInvoiceBPKMyForIc2In(sPrimaryKeys);

      timer.addExecutePhase("得到当前发票行的原有发票数量findInvoiceNumByInvoiceBPKMy");

      for (int i = 0; i < iRowCount; i++) {
        if (bVOs[i].getCupsourcebillrowid() != null && !bVOs[i].getCupsourcebillrowid().trim().equals("")) {

          // 定义发票原有数量
          double nOriInvNum = 0.0;
          double nOriWasteNum = 0;
          // 获得该行的发票原有数量
          if (bVOs[i].getPrimaryKey() != null) {
            if (hInvoiceNum.get(bVOs[i].getPrimaryKey()) != null) {
              nOriInvNum = ((UFDouble[]) hInvoiceNum.get(bVOs[i].getPrimaryKey()))[0].doubleValue();
              nOriWasteNum = ((UFDouble[]) hInvoiceNum.get(bVOs[i].getPrimaryKey()))[1].doubleValue();
            }
          }
          // 发票数量修改了才修改订单:(订单累计发票数量 = 原订单累计发票数量 - 发票原数量 + 发票现数量))
          if (bVOs[i].getNreasonwastenum() == null || bVOs[i].getNreasonwastenum().toString().trim().length() == 0)
            bVOs[i].setNreasonwastenum(new UFDouble(0));
          if (bVOs[i].getNinvoicenum().doubleValue() != nOriInvNum
              || bVOs[i].getNreasonwastenum().doubleValue() != nOriWasteNum || bVOs[i].getStatus() == VOStatus.DELETED) {

            nc.vo.scm.puic.ParaPoToIcLendRewriteVO vo = new nc.vo.scm.puic.ParaPoToIcLendRewriteVO();
            vo.setCRowID(bVOs[i].getCupsourcebillrowid());
            double d1 = nOriInvNum;
            double dd1 = nOriWasteNum;
            double d2 = 0.0;
            double dd2 = 0;
            if (bVOs[i].getStatus() == VOStatus.DELETED) {
              d2 = 0.0;
              dd2 = 0;
            }
            else {
              if (bVOs[i].getNinvoicenum() != null)
                d2 = bVOs[i].getNinvoicenum().doubleValue();
              if (bVOs[i].getNreasonwastenum() != null)
                dd2 = bVOs[i].getNreasonwastenum().doubleValue();
            }

            vo.setDSubNum(new UFDouble(d2 - d1));
            vo.setDWasteSubNum(new UFDouble(dd2 - dd1));
            arrIc.add(vo);
          }
        }
      }
      if (arrIc.size() > 0) {
        vos = new nc.vo.scm.puic.ParaPoToIcLendRewriteVO[arrIc.size()];
        arrIc.toArray(vos);
      }

      timer.addExecutePhase("回写采购入库单前的准备");

      // 回写采购入库单
      if (vos != null && vos.length > 0) {
        // 入库开票时,如果入库单行累计开票数量-入库单行对应发票行累计损耗数量>入库单行实收数量 抛出异常
        dmoInvoice.isSignNumExceedInNum(vos);

        // nc.bs.ic.pub.ictopu.Ic2puDMO dmo = new
        // nc.bs.ic.pub.ictopu.Ic2puDMO();
        // IICToPU_Ic2puDMO dmo = (IICToPU_Ic2puDMO) new
        // InterServBO().getInterInstance(ProductCode.PROD_IC,InterRegister.IC0007);
        IICToPU_Ic2puDMO dmo = (IICToPU_Ic2puDMO) NCLocator.getInstance().lookup(IICToPU_Ic2puDMO.class.getName());
        dmo.writebackNsignnum(vos);
        // Object oInstance = new
        // InterServBO().getInterInstance(ProductCode.PROD_IC,InterRegister.IC0001)
        // ;
        // UFDouble[] dCost =
        // ((IICToPU)oInstance).writebackNsignnum(vos);

        timer.addExecutePhase("回写采购入库单writebackNsignnum");
      }

      timer.showAllExecutePhase("回写单据采购入库单操作writeBackToIc结束");

    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.writeBackToIc(InvoiceVO) Exception!", e);
    }
  }

  /**
   * 作者：汪维敏 功能：回写单据采购订单,并进行数量容差和价格容差控制,，从入库单拉式生成发票，要进行采购订单的价格容差，并回写累计发票数量
   * 参数：InvoiceVO isFrmIc 是否来自入库单 isDiscard 删除不做订单容差控制检查 例外：BusinessException
   * 创建日期：(2004-2-27 16:42:43)
   * <p>
   * <p>For V56 只用于普通存货(非费用)回写采购订单
   */
  private void writeBackToPoOrder(InvoiceVO invVO, boolean isFrmIc, boolean isDiscard) throws BusinessException {
    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("回写单据采购订单操作writeBackToPoOrder开始");

    InvoiceItemVO[] bVOs = invVO.getBodyVO();
    OrderImpl beanOrder = null;
    try {
      // 发票DMO
      InvoiceDMO dmoInvoice = new InvoiceDMO();

      ArrayList arrWriteBackId = new ArrayList();

      // 用于回写采购订单行
      ArrayList arrWriteBackOriNum = new ArrayList();
      ArrayList arrWriteBackCurNum = new ArrayList();
      ArrayList arrWriteBackPrice = new ArrayList();

      String[] sIds = null;
      UFDouble[] ufOriNums = null;
      UFDouble[] ufCurNums = null;
      UFDouble[] ufCurPrices = null;

      // 获取用于批处理的数据
      int iRowCount = bVOs.length;
      String[] sPrimaryKeys = null;
      String[] sCorder_bIds = null;
      ArrayList arr = new ArrayList();
      ArrayList arr1 = new ArrayList();
      for (int i = 0; i < iRowCount; i++) {
        String temp = bVOs[i].getPrimaryKey();
        if (temp != null && temp.length() > 0)
          arr.add(temp);
        String temp1 = bVOs[i].getCorder_bid();
        if (temp1 != null && temp1.length() > 0)
          arr1.add(temp1);
      }
      if (arr.size() > 0) {
        sPrimaryKeys = new String[arr.size()];
        arr.toArray(sPrimaryKeys);
      }
      if (arr1.size() > 0) {
        sCorder_bIds = new String[arr1.size()];
        arr1.toArray(sCorder_bIds);
      }

      // 得到当前发票行的原有发票数量
      HashMap hOrgColValues = new HashMap();
      if (sPrimaryKeys != null && sPrimaryKeys.length > 0 && arr1.size() > 0)
        hOrgColValues = dmoInvoice.findInvoiceNumByInvoiceBPKMy(sPrimaryKeys);

      timer.addExecutePhase("得到当前发票行的原有发票数量findInvoiceNumByInvoiceBPKMy");
      // 发票回写单价要进行和订单一样的精度控制
      SysInitDMO dmoInit = new SysInitDMO();
      String sNumPresKind = null;
      String sPricePresKind = null;
      String ccurtypeid = null;
      int iPriceDigit = 2;// 取本公司的单价精度
      Hashtable tPara = dmoInit.queryBatchParaValues(invVO.getHeadVO().getPk_corp(), new String[] {
          "PO02", "PO04", "BD505", "BD301"
      });
      if (tPara != null && tPara.size() > 0) {
        Object oTemp = tPara.get("PO02");
        if (oTemp != null)
          sNumPresKind = oTemp.toString();
        oTemp = tPara.get("PO04");
        if (oTemp != null)
          sPricePresKind = oTemp.toString();
        oTemp = tPara.get("BD505");
        if (oTemp != null)
          iPriceDigit = Integer.parseInt(oTemp.toString());
        oTemp = tPara.get("BD301");
        if (oTemp != null)
          ccurtypeid = oTemp.toString();
      }
      boolean bPriceCheck = sPricePresKind.equals("不保存");/*-=notranslate=-*/
      boolean bPriceHint = sPricePresKind.equals("提示");/*-=notranslate=-*/
      UFDouble dNumPresValue = null;
      UFDouble dPricePresValue = null;
      if (bPriceCheck || bPriceHint) {
        dPricePresValue = dmoInit.getParaDbl(invVO.getHeadVO().getPk_corp(), "PO05");
        dPricePresValue = PuPubVO.getUFDouble_NullAsZero(dPricePresValue);
      }
      UFDouble dPrice = null;
      for (int i = 0; i < iRowCount; i++) {
        // if (bVOs[i].getCupsourcebillrowid() != null &&
        // !bVOs[i].getCupsourcebillrowid().trim().equals("")) {
        if (bVOs[i].getCorder_bid() != null && bVOs[i].getCorder_bid().trim().length() > 0) {

          // 定义发票原有数量
          double nOriInvNum = 0.0;
          // 获得该行的发票原有数量
          String invoicebId=PuPubVO.getString_TrimZeroLenAsNull(bVOs[i].getPrimaryKey());
          if (invoicebId != null && hOrgColValues.get(invoicebId) != null){
              nOriInvNum = PuPubVO.getUFDouble_NullAsZero(((List<UFDouble>) hOrgColValues.get(invoicebId))
                  .get(0)).doubleValue();    
          }
          // 发票数量修改了才修改订单:(订单累计发票数量 = 原订单累计发票数量 - 发票原数量 + 发票现数量))
          // if (bVOs[i].getNinvoicenum().doubleValue() != nOriInvNum
          // || bVOs[i].getStatus() == VOStatus.DELETED) {

          // arrWriteBackId.add(bVOs[i].getCupsourcebillrowid());
          arrWriteBackId.add(bVOs[i].getCorder_bid());
          // 设置回写的单据ID,发票原数量和发票现数量

          arrWriteBackOriNum.add(new UFDouble(nOriInvNum));
          if (bVOs[i].getStatus() == VOStatus.DELETED){
            arrWriteBackCurNum.add(new UFDouble(0.0));
          }
          else{
            arrWriteBackCurNum.add(bVOs[i].getNinvoicenum());
          }

          // 发票本币单价
          if (bVOs[i].getNinvoicenum() != null && !bVOs[i].getNinvoicenum().equals(new UFDouble(0.0))) {
            if (bVOs[i].getCcurrencytypeid() != null && bVOs[i].getCcurrencytypeid().trim().equals(ccurtypeid)) {
              dPrice = bVOs[i].getNoriginalcurprice();
            }
            else {
              dPrice = (bVOs[i].getNmoney().div(bVOs[i].getNinvoicenum()))
                  .setScale(iPriceDigit, UFDouble.ROUND_HALF_UP);
              if (dPricePresValue != null) {
                dPrice = dPrice.multiply(dPricePresValue.div(100.0).add(1.0)).setScale(iPriceDigit,
                    UFDouble.ROUND_HALF_UP);
              }
            }
            arrWriteBackPrice.add(dPrice);
          }
          else
            arrWriteBackPrice.add(null);
          // }
        }
      }
      if (arrWriteBackId.size() > 0) {
        sIds = new String[arrWriteBackId.size()];
        arrWriteBackId.toArray(sIds);
      }
      if (arrWriteBackOriNum.size() > 0) {
        ufOriNums = new UFDouble[arrWriteBackOriNum.size()];
        arrWriteBackOriNum.toArray(ufOriNums);
      }
      if (arrWriteBackCurNum.size() > 0) {
        ufCurNums = new UFDouble[arrWriteBackCurNum.size()];
        arrWriteBackCurNum.toArray(ufCurNums);
      }
      if (arrWriteBackPrice.size() > 0) {
        ufCurPrices = new UFDouble[arrWriteBackPrice.size()];
        arrWriteBackPrice.toArray(ufCurPrices);
      }

      beanOrder = getBean_Order();

      timer.addExecutePhase("回写采购订单前的准备");

      // 回写采购订单
      if (ufOriNums != null && ufOriNums.length > 0 && ufCurNums != null && ufCurNums.length > 0) {

        ParaPiToPoRewriteVO voPara = new ParaPiToPoRewriteVO();
        voPara.setPk_corp(invVO.getHeadVO().getPk_purcorp());
        voPara.setCBodyIdArray(sIds);
        voPara.setDOldNumArray(ufOriNums);
        voPara.setDNumArray(ufCurNums);
        
        // 是否来自入库单
        voPara.setIsFromIc(isFrmIc);
        voPara.setDLocalNetPriceArray(ufCurPrices);
        voPara.setUserConfirm(invVO.getUserConfirmFlag() == null ? false : invVO.getUserConfirmFlag().booleanValue());

        if (invVO.getUserConfirmFlag() != null)
          voPara.setUserConfirm(invVO.getUserConfirmFlag().booleanValue());
        
        if(isDiscard) {
            beanOrder.rewritePiNumForDiscardInvoice(voPara);            
        }
        else {
          beanOrder.rewritePiNum(voPara);
        }
        timer.addExecutePhase("回写采购订单rewritePiNum");
      }
      timer.showAllExecutePhase("回写单据采购订单操作writeBackToPoOrder结束");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.writeBackToPoOrder(InvoiceVO) Exception!", e);
    }
  }

  /**
   * 
   * 方法功能描述：回写费用订单开票金额。
   * <P>只用于费用存货回写采购订单
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param invVO
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2009-4-8 下午03:05:53
   */
  private void writeBackToPoFeeOrder(InvoiceVO invVO) throws BusinessException
  {
    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("回写单据采购订单操作writeBackToPoOrder开始");

    InvoiceItemVO[] bVOs = invVO.getBodyVO();
    try {
      ArrayList<String> arrWriteBackId = new ArrayList<String>();

      // 用于回写采购订单行,费用开票金额
      List<UFDouble> writeBackDiffSumMny = new ArrayList<UFDouble>();

      // 获取用于批处理的数据
      int iRowCount = bVOs.length;
      ArrayList<String> bodyPKs = new ArrayList<String>();
      for (int i = 0; i < iRowCount; i++) {
        String temp = bVOs[i].getPrimaryKey();
        if (temp != null && temp.length() > 0)
          bodyPKs.add(temp);
      }

      // 得到当前发票行的原有发票数量
      HashMap hOrgColValues = new HashMap();
      if (bodyPKs.size() > 0)
        hOrgColValues = new InvoiceDMO().findInvoiceNumByInvoiceBPKMy(bodyPKs.toArray(new String[bodyPKs.size()]));

      timer.addExecutePhase("得到当前发票行的原有发票数量findInvoiceNumByInvoiceBPKMy");

      for (int i = 0; i < iRowCount; i++) {
        if (bVOs[i].getCorder_bid() != null && bVOs[i].getCorder_bid().trim().length() > 0) {
          // 定义发票原有开票金额
          double nOriSumMny = 0.0;
          // 获得该行的发票原有开票金额
          String invoicebId=PuPubVO.getString_TrimZeroLenAsNull(bVOs[i].getPrimaryKey());
          if (invoicebId != null && hOrgColValues.get(invoicebId) != null){
            nOriSumMny = PuPubVO.getUFDouble_NullAsZero(((List<UFDouble>) hOrgColValues.get(invoicebId))
                .get(1)).doubleValue();   
          }
          arrWriteBackId.add(bVOs[i].getCorder_bid());
          // 设置回写的单据ID,发票金额
          if (bVOs[i].getStatus() == VOStatus.DELETED){
            writeBackDiffSumMny.add(new UFDouble(0.0).sub(nOriSumMny));
          }
          else{
            writeBackDiffSumMny.add(PuPubVO.getUFDouble_NullAsZero(bVOs[i].getNoriginalsummny()).sub(nOriSumMny));
          }
        }
      }
      timer.addExecutePhase("回写采购订单前的准备");
      if (arrWriteBackId.size() > 0) {
        // 回写采购订单
        ParaPiToPoRewriteVO voPara = new ParaPiToPoRewriteVO();
        voPara.setPk_corp(invVO.getHeadVO().getPk_purcorp());
        voPara.setCBodyIdArray(arrWriteBackId.toArray(new String[arrWriteBackId.size()]));
        voPara.setnfeemny(writeBackDiffSumMny.toArray(new UFDouble[writeBackDiffSumMny.size()]));
        // 是否来自入库单
        voPara.setIsFromIc(false);
        voPara.setUserConfirm(invVO.getUserConfirmFlag() == null ? false : invVO.getUserConfirmFlag().booleanValue());
        if (invVO.getUserConfirmFlag() != null)
          voPara.setUserConfirm(invVO.getUserConfirmFlag().booleanValue());      
        //For V56 订单费用回写
        getBean_Order().rewritePiNumFee(voPara);
        timer.addExecutePhase("回写采购订单rewritePiNumFee");
      }
      timer.showAllExecutePhase("回写单据采购订单操作writeBackToPoOrder结束");
    }
    catch (Exception e) {
      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.writeBackToPoFeeOrder(InvoiceVO) Exception!", e);
    }
  }
  
  
  /**
   * 作者：汪维敏 功能：回写单据委外订单 参数：InvoiceVO 例外：BusinessException 创建日期：(2004-2-27
   * 16:42:43)
   */
  private void writeBackToScOrder(InvoiceVO invVO) throws BusinessException {
    nc.vo.scm.pu.Timer timer = new nc.vo.scm.pu.Timer();
    timer.start("回写单据委外订单操作writeBackToScOrder开始");

    InvoiceItemVO[] bVOs = invVO.getBodyVO();
    try {
      // 发票DMO
      InvoiceDMO dmoInvoice = new InvoiceDMO();
      ArrayList arrWriteBackId = new ArrayList();

      // 用于回写委外订单
      ArrayList arrWriteBackScOrderNum = new ArrayList();
      ArrayList arrWriteBackScOrderPrice = new ArrayList();// add for
      // v5

      String[] sIds = null;
      UFDouble[] ufScOrderNums = null;
      UFDouble[] ufScOrderPrices = null;

      // 获取用于批处理的数据
      int iRowCount = bVOs.length;
      String[] sPrimaryKeys = null;
      String[] sCorder_bIds = null;
      ArrayList arr = new ArrayList();
      ArrayList arr1 = new ArrayList();
      for (int i = 0; i < iRowCount; i++) {
        String temp = bVOs[i].getPrimaryKey();
        if (temp != null && temp.length() > 0)
          arr.add(temp);
        String temp1 = bVOs[i].getCorder_bid();
        if (temp1 != null && temp1.length() > 0)
          arr1.add(temp1);
      }
      if (arr.size() > 0) {
        sPrimaryKeys = new String[arr.size()];
        arr.toArray(sPrimaryKeys);
      }
      if (arr1.size() > 0) {
        sCorder_bIds = new String[arr1.size()];
        arr1.toArray(sCorder_bIds);
      }

      // 得到当前发票行的原有发票数量
      HashMap hOrgColValues = new HashMap();
      if (sPrimaryKeys != null && sPrimaryKeys.length > 0 && arr1.size() > 0)
        hOrgColValues = dmoInvoice.findInvoiceNumByInvoiceBPKMy(sPrimaryKeys);

      timer.addExecutePhase("得到当前发票行的原有发票数量findInvoiceNumByInvoiceBPKMy");

      // 得到累计发票数量
      HashMap hAccumInvoiceNum = new HashMap();
      if (sCorder_bIds != null && sCorder_bIds.length > 0) {
        // if
        // (bVOs[0].getCupsourcebilltype().equals(nc.vo.pu.pub.BillTypeConst.SC_ORDER))
        hAccumInvoiceNum = dmoInvoice.findAccumInvoiceNumByScOrderBPKMy(sCorder_bIds);

        timer.addExecutePhase("得到累计发票数量findAccumInvoiceNumByScOrderBPKMy");
      }
      for (int i = 0; i < iRowCount; i++) {
        if (bVOs[i].getCupsourcebillrowid() != null && !bVOs[i].getCupsourcebillrowid().trim().equals("")) {

          // 定义发票原有数量
          double nOriInvNum = 0.0;
          // 获得该行的发票原有数量
          String invoicebId=PuPubVO.getString_TrimZeroLenAsNull(bVOs[i].getPrimaryKey());
          if (invoicebId != null && hOrgColValues.get(invoicebId) != null){
              nOriInvNum = PuPubVO.getUFDouble_NullAsZero(((List<UFDouble>) hOrgColValues.get(invoicebId))
                  .get(0)).doubleValue();            
          }
          // 发票数量修改了才修改订单:(订单累计发票数量 = 原订单累计发票数量 - 发票原数量 + 发票现数量))
          // if (bVOs[i].getNinvoicenum().doubleValue() != nOriInvNum
          // || bVOs[i].getStatus() == VOStatus.DELETED) {//comment
          // for v5

          arrWriteBackId.add(bVOs[i].getCorder_bid());
          // 设置委外订单的累计发票数量
          UFDouble temp = (UFDouble) hAccumInvoiceNum.get(bVOs[i].getCorder_bid());
          double nOriAccumInvNum = (temp == null ? 0.0 : temp.doubleValue());
          double nNewAccumInvValue = 0.0;
          if (bVOs[i].getStatus() == VOStatus.DELETED) {
            nNewAccumInvValue = nOriAccumInvNum - nOriInvNum + 0.0;
          }
          else {
            nNewAccumInvValue = nOriAccumInvNum - nOriInvNum + bVOs[i].getNinvoicenum().doubleValue();
          }

          arrWriteBackScOrderNum.add(new UFDouble(nNewAccumInvValue));

          // 发票本币单价
          if (bVOs[i].getNinvoicenum() != null && !bVOs[i].getNinvoicenum().equals(new UFDouble(0.0)))
            arrWriteBackScOrderPrice.add(bVOs[i].getNmoney().div(bVOs[i].getNinvoicenum()));
          else
            arrWriteBackScOrderPrice.add(null);

          // }
        }
      }
      if (arrWriteBackId.size() > 0) {
        sIds = new String[arrWriteBackId.size()];
        arrWriteBackId.toArray(sIds);
      }
      if (arrWriteBackScOrderNum.size() > 0) {
        ufScOrderNums = new UFDouble[arrWriteBackScOrderNum.size()];
        arrWriteBackScOrderNum.toArray(ufScOrderNums);
      }

      if (arrWriteBackScOrderPrice.size() > 0) {
        ufScOrderPrices = new UFDouble[arrWriteBackScOrderPrice.size()];
        arrWriteBackScOrderPrice.toArray(ufScOrderPrices);
      }

      timer.addExecutePhase("委外订单回写前的准备");

      // 回写委外订单
      if (ufScOrderNums != null && ufScOrderNums.length > 0) {
        double[] nums = new double[ufScOrderNums.length];
        double[] prices = new double[ufScOrderPrices.length];
        for (int i = 0; i < ufScOrderNums.length; i++) {
          nums[i] = ufScOrderNums[i].doubleValue();
        }

        for (int i = 0; i < ufScOrderPrices.length; i++) {
          prices[i] = ufScOrderPrices[i].doubleValue();
        }

        dmoInvoice.updateAccumInvoiceNumByScOrderBPKMy(sIds, nums, prices, invVO);

        timer.addExecutePhase("委外订单回写操作updateAccumInvoiceNumByScOrderBPKMy");
      }
      timer.showAllExecutePhase("回写单据委外订单操作writeBackToScOrder结束");
    }
    catch (Exception e) {

      PubDMO.throwBusinessException("nc.bs.pi.InvoiceBO.writeBackToScOrder(InvoiceVO) Exception!", e);
    }
  }

  public ArrayList queryInfoForOrder(String corder_bid) throws Exception {

    ArrayList arrInfo = null;

    try {
      InvoiceDMO dmo = new InvoiceDMO();
      arrInfo = dmo.queryInfoForOrder(corder_bid);
    }
    catch (Exception e) {

    }
    return arrInfo;

  }

  /**
   * 给定某个单位，币种，日期，返回相应的折本和折辅汇率
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param pk_corp
   * @param pk_currtype
   * @param date
   * @return
   *          <p>
   *          UFDouble[] 第一位：折辅汇率 如果单主币核算或币种为主币，本位为null
   *          <p>
   *          第二位：折本汇率
   *          <p>
   * @author zhanghaiyan
   * @time 2007-8-7 下午12:03:08
   */
  public UFDouble[] getRateBoth(String pk_corp, String pk_currtype, String date) {
    try {
      BusinessCurrencyRateUtil dmo = new BusinessCurrencyRateUtil(pk_corp);
      if (CurrParamQuery.getInstance().getLocalCurrPK(pk_corp).equals(pk_currtype))
        return new UFDouble[] {
            null, new UFDouble(1.0)
        };
      else
        // if (dmo.isBlnLocalFrac()) {
        // if (dmo.isFracCurrType(pk_currtype))
        // return new UFDouble[] {
        // new UFDouble(1.0),
        // dmo
        // .getRate(pk_currtype, dmo.getLocalCurrPK(),
        // date) };
        // else
        // return new UFDouble[] {
        // dmo.getRate(pk_currtype, dmo.getFracCurrPK(), date),
        // dmo
        // .getRate(pk_currtype, dmo.getLocalCurrPK(),
        // date) };
        // } else {
        return new UFDouble[] {
            null, dmo.getRate(pk_currtype, CurrParamQuery.getInstance().getLocalCurrPK(pk_corp), date)
        };
      // }
    }
    catch (Exception e) {
      SCMEnv.out(e);
      return null;
    }
  }

  /**
   * 父类方法重写
   * 
   * @see nc.itf.pi.IInvoice#queryStordocByStoreorg(java.lang.String[])
   */
  public Hashtable queryStordocByStoreorg(String[] sCstoreorganization) throws Exception {
    // 参数正确性检查
    if (sCstoreorganization == null || sCstoreorganization.length == 0) {
      SCMEnv.out("nc.bs.pi.InvoiceImpl.queryStordocByStoreorg(String [])传入参数为空，不正确！");
      return null;
    }

    Hashtable hashtable = new Hashtable();

    try {
      InvoiceDMO dmo = new InvoiceDMO();
      String stor = null;
      for (String str : sCstoreorganization) {
        stor = dmo.queryStordocByStoreorg(str);
        hashtable.put(str, stor);
      }
    }
    catch (Exception e) {

    }
    return hashtable;

  }

  /**
   * 作者：lixiaodong 功能：取采购默认价格、按照原有取价规则取得价格 参数：RetPoVrmAndParaPriceVO voPara 参数VO
   * String pk_corp 公司主键 String saMangId[] 存货管理ID String saCurrId[] 币种ID
   * UFDouble[] daBRate 折本汇率数据 UFDouble[] daARate 折辅汇率数据 String sDate 单据日期 返回：
   * UFDouble[] 采购默认价格，为按币种折算过的价格 不返回空，且其中的价格数组等均不为空 例外：BusinessException
   * 包裹业务及系统异常 日期：(2008-03-06 下午01:34:45) 采购发票单价来源，单价根据新增参数PO82取价
   */
  private RetPoVrmAndParaPriceVO queryVrmAndParaPricesForPI(RetPoVrmAndParaPriceVO voPara, String sPara)
      throws BusinessException {

    String pk_corp = voPara.getPk_corp();
    // ---V5 modify:
    // String sStoOrgId = voPara.getStoOrgId() ;
    String[] saStoOrgId = voPara.getStoOrgIds();
    // ---
    String sVendMangId = voPara.getVendMangId();
    String[] saMangId = voPara.getSaInvMangId();
    String[] saBaseId = voPara.getSaInvBaseId();
    String[] saCurrId = voPara.getSaCurrId();
    UFDouble[] daBRate = voPara.getDaBRate();
    UFDouble[] daARate = voPara.getDaARate();
    UFDate dOrderDate = voPara.getDOrderDate();

    nc.vo.scm.pu.Timer timeDebug = new nc.vo.scm.pu.Timer();
    timeDebug.start();

    int iTotalLen = saBaseId.length;
    UFDouble[] daPrice = null;
    // 组织返回值
    RetPoVrmAndParaPriceVO voRet = new RetPoVrmAndParaPriceVO(iTotalLen);
    try {
      int iPriorPrice = PubDMO.getPricePriorPolicy(pk_corp);

      // 调用供应商管理接口取得价格
      // ICreateCorpQueryService corpDmo = (ICreateCorpQueryService)
      // NCLocator.getInstance().lookup(ICreateCorpQueryService.class.getName());
      // if (corpDmo.isEnabled(pk_corp, ProductCode.PROD_VRM) && saCurrId
      // != null && saCurrId.length > 0) { //"VRM"
      // VendorstockDMO vendorDmo = new VendorstockDMO();
      // IVrmToPu_VendorstockDMO vendorDmo = (IVrmToPu_VendorstockDMO)new
      // InterServBO().getInterInstance(ProductCode.PROD_VRM,InterRegister.VRM0001);
      // IVrmToPu_Vendorstock_D vendorDmo = (IVrmToPu_Vendorstock_D)
      // NCLocator.getInstance().lookup(IVrmToPu_Vendorstock_D.class.getName());
      // daPrice = vendorDmo.queryPriceForPO(
      // saMangId,
      // new String[]{sVendMangId},
      // saCurrId,
      // iPriorPrice==RelationsCalVO.PRICE_PRIOR_TO_TAXPRICE ? "无税价格优先" :
      // "含税价格优先"/*-=notranslate=-*/
      // );
      IAsk queryPrice = (IAsk) NCLocator.getInstance().lookup(IAsk.class.getName());

      //
      String strDate = null;
      if (voPara.getClientLink() != null) {
        strDate = voPara.getClientLink().getLogonDate().toString();
      }
      else if (voPara.getDOrderDate() != null) {
        strDate = voPara.getDOrderDate().toString();
      }
      else {
        strDate = new UFDate(System.currentTimeMillis()).toString();
      }

      if (PuPubVO.getString_TrimZeroLenAsNull(sPara) == null)
        throw new BusinessException("无法获取参数PO82！");

      if (AppConstant.GYSYXJG.equalsIgnoreCase(sPara.trim())) {
        daPrice = queryPrice.queryPriceForPO(saMangId, new String[] {
          sVendMangId
        }, saCurrId, iPriorPrice == RelationsCalVO.PRICE_PRIOR_TO_TAXPRICE ? "无税价格优先" : "含税价格优先"/*-=notranslate=-*/,
            strDate, null, null);
      }
      else if (AppConstant.DDJ.equalsIgnoreCase(sPara.trim())
          && !BillTypeConst.DRP_ASKGOOD.equalsIgnoreCase(voPara.getBilltype())) {
        daPrice = new UFDouble[iTotalLen];
        for (int i = 0; i < daPrice.length; i++) {
          if (PuPubVO.getString_TrimZeroLenAsNull(voPara.getOldPrice()[i]) != null && daPrice[i] == null) {
            daPrice[i] = new UFDouble(999999999);// 与前台(nc.ui.pi.invoice.InvBillPanel.setDefaultPrice(Integer[]))约定,若为"订单价",则取订单上原有价格
          }
        }
      }
      else if (AppConstant.RKDJ.equalsIgnoreCase(sPara.trim())) {
        daPrice = new UFDouble[iTotalLen];
        Boolean[] isFromSto = voPara.getIsFromSto();

        // 本位币
        ISysInitQry initDMO = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
            ISysInitQry.class.getName());
        SysInitVO initVO = initDMO.queryByParaCode(voPara.getPk_corp(), "BD301");
        String cCurrencyTypeID = null;
        if (initVO != null)
          cCurrencyTypeID = initVO.getPkvalue();

        if (isFromSto != null && isFromSto.length == voPara.getOldPrice().length) {
          for (int i = 0; i < daPrice.length; i++) {
            if (isFromSto[i]) {
              daPrice[i] = PuPubVO.getUFDouble_NullAsZero(voPara.getOldPrice()[i]);
              //传过来的价格已经是原币价格,返回时也要用原币价格,不需要折算
//              daPrice[i] = transValue(daPrice[i], cCurrencyTypeID, voPara.getSaCurrId()[i], voPara.getDaBRate()[i],
//                  voPara);
            }

          }
        }
      }
      timeDebug.addExecutePhase("调用询报价接口取得价格");/*-=notranslate=-*/

      // 如果询报价中找不到价格，根据系统参数到基础档案中查找
      Vector vParaIndex = new Vector();
      if (daPrice == null) {
        daPrice = new UFDouble[iTotalLen];
      }
      for (int i = 0; i < daPrice.length; i++) {
        if (daPrice[i] == null) {
          vParaIndex.addElement(new Integer(i));
        }
      }

      int iParaLen = vParaIndex.size();
      if (iParaLen > 0) {
        if (sPara != null) {
          UFDouble[] daBasePrice = new nc.bs.po.OrderImpl().queryPricesFromPara(voPara, sPara, iPriorPrice);
          if (daBasePrice != null && daBasePrice.length > 0) {
            for (int i = 0; i < iParaLen; i++) {
              if (daBasePrice[i] != null
              // &&
              // (daBasePrice[i].compareTo(nc.vo.pu.pub.VariableConst.ZERO)
              // != 0
              ) {
                int iIndex = ((Integer) vParaIndex.get(i)).intValue();
                daPrice[iIndex] = daBasePrice[i];
                if (sPara.equals("参考成本") || sPara.equals("计划价")) {/*-=notranslate=-*/
                  voRet.setPriceNoTaxAt(iIndex, true);
                }
              }
            }
          }
        }
      }

      timeDebug.addExecutePhase("根据系统参数到取采购价格");/*-=notranslate=-*/

    }
    catch (Exception e) {

      PubDMO.throwBusinessException(e);
    }

    // 设置返回值
    voRet.setDaQueryValue(daPrice);
    voRet.setPk_corp(pk_corp);
    // ---V5 modify:
    // voRet.setStoOrgId(sStoOrgId) ;
    voRet.setStoOrgIds(saStoOrgId);
    // ---
    voRet.setSaCurrId(saCurrId);
    voRet.setVendMangId(sVendMangId);
    voRet.setSaInvMangId(saMangId);
    voRet.setSaInvBaseId(saBaseId);
    voRet.setDOrderDate(dOrderDate);
    voRet.setDaBRate(daBRate);
    voRet.setDaARate(daARate);
    timeDebug.showAllExecutePhase("订单BS取VRM及采购默认价格时间");/*-=notranslate=-*/

    return voRet;
  }

  /**
   * 取采购默认价格、按照原有取价规则取得价格,采购发票制单时使用。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param：RetPoVrmAndParaPriceVO voPara 参数VO String pk_corp 公司主键 String
   *                               saMangId[] 存货管理ID String saCurrId[] 币种ID
   *                               UFDouble[] daBRate 折本汇率数据 UFDouble[] daARate
   *                               折辅汇率数据 String sDate 单据日期
   * @return： RetPoVrmAndParaPriceVO：包含按币种折算过的价格 不返回空，且其中的价格数组等均不为空
   * @throws BusinessException
   *           <p>
   * @author lixiaodong
   * @time 2008-3-31 上午09:54:53
   */

  public RetPoVrmAndParaPriceVO queryVrmAndParaPricesForPI(RetPoVrmAndParaPriceVO voPara) throws BusinessException {
    // 取得价格参数
    String pk_corp = voPara.getPk_corp();
    SysInitVO initVO = nc.ui.pub.para.SysInitBO_Client.queryByParaCode(pk_corp, "PO82");
    String values = initVO.getValue();
    RetPoVrmAndParaPriceVO voRetPrice = null;

    String sPara = AppConstant.getNameByIndex(values.substring(0, 1));// 查询第一个参数
    // 价格返回
    voRetPrice = queryVrmAndParaPricesForPI(voPara, sPara);
    cyclePriceVO(voRetPrice, values.substring(1, values.length()));// 没找到价格的用递归继续找
    return voRetPrice;
  }

  /**
   * 按PO83参数的取价顺序，重新组织voRetPrice并取价，直到voRetPrice.getPriceAt(i)取得价格。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param voRetPrice：存放查询订单的默认价格时的返回值
   * @param values：参数PO83的取价顺序(从第二个开始),1
   *          参考成本,2 计划价,3 订单最新价,4 订单最低价,5 供应商有效价格,6 入库单价
   * @return
   * @throws BusinessException
   *           <p>
   * @author lixiaodong
   * @time 2008-3-31 上午09:54:53
   */
  private RetPoVrmAndParaPriceVO cyclePriceVO(RetPoVrmAndParaPriceVO voRetPrice, String values)
      throws BusinessException {

    String pk_corp = voRetPrice.getPk_corp();
    // 取得默认价格并重新计算数量关系
    Vector<String> vecStoOrgId = new Vector<String>();
    Vector<String> vecInvId = new Vector<String>();
    Vector<String> vecInvBaseId = new Vector<String>();
    Vector<String> vecCurrId = new Vector<String>();
    Vector<UFDouble> vecBRate = new Vector<UFDouble>();
    Vector<UFDouble> vecARate = new Vector<UFDouble>();
    Vector<Integer> vecIndex = new Vector<Integer>();
    RetPoVrmAndParaPriceVO voRetPrice3 = null;
    String sPara = "";

    for (int i = 0; i < voRetPrice.getSaInvBaseId().length; i++) {

      if (voRetPrice != null && voRetPrice.getPriceAt(i) == null) {
        vecStoOrgId.addElement(voRetPrice.getStoOrgIds()[i]);
        vecInvId.addElement(voRetPrice.getSaInvMangId()[i]);
        vecInvBaseId.addElement(voRetPrice.getSaInvBaseId()[i]);
        vecCurrId.addElement(voRetPrice.getSaCurrId()[i]);
        vecBRate.addElement(voRetPrice.getDaBRate()[i]);
        vecARate.addElement(voRetPrice.getDaARate()[i]);
      }
    }
    if (vecStoOrgId == null || vecStoOrgId.size() <= 0 || PuPubVO.getString_TrimZeroLenAsNull(values) == null) {// 已经全部找到价格或者按取价参数循环完毕
      return voRetPrice;
    }
    sPara = AppConstant.getNameByIndex(values.substring(0, 1));
    if (vecStoOrgId != null && vecStoOrgId.size() > 0) {
      // 存货基本ID 管理ID 币种 折本汇率 折辅汇率
      // 取默认价格
      RetPoVrmAndParaPriceVO voPara2 = new RetPoVrmAndParaPriceVO(1);
      voPara2.setPk_corp(pk_corp);
      voPara2.setStoOrgIds((String[]) vecStoOrgId.toArray(new String[vecStoOrgId.size()]));
      voPara2.setVendMangId(voRetPrice.getVendMangId());
      voPara2.setSaInvMangId((String[]) vecInvId.toArray(new String[vecInvBaseId.size()]));
      voPara2.setSaInvBaseId((String[]) vecInvBaseId.toArray(new String[vecInvBaseId.size()]));
      voPara2.setSaCurrId((String[]) vecCurrId.toArray(new String[vecInvBaseId.size()]));
      voPara2.setDaBRate((UFDouble[]) vecBRate.toArray(new UFDouble[vecInvBaseId.size()]));
      voPara2.setDaARate((UFDouble[]) vecARate.toArray(new UFDouble[vecInvBaseId.size()]));
      voPara2.setDOrderDate(voRetPrice.getDOrderDate());
      voPara2.setBizTypeId(voRetPrice.getBizTypeId());
      // 价格返回
      voRetPrice3 = queryVrmAndParaPricesForPI(voPara2, sPara);
      if (voRetPrice3 != null) {
        for (int ii = 0; ii < voRetPrice3.getSaInvBaseId().length; ii++) {
          for (int iii = 0; iii < voRetPrice.getSaInvBaseId().length; iii++) {
            if (voRetPrice3.getPriceAt(ii) != null
                && (voRetPrice3.getSaInvBaseId()[ii] + voRetPrice3.getSaInvMangId()[ii] + voRetPrice3.getSaCurrId()[ii]
                    + voRetPrice3.getDaARate()[ii] + voRetPrice3.getDaBRate()[ii]).equalsIgnoreCase(voRetPrice
                    .getSaInvBaseId()[iii]
                    + voRetPrice.getSaInvMangId()[iii]
                    + voRetPrice.getSaCurrId()[iii]
                    + voRetPrice.getDaARate()[iii]
                    + voRetPrice.getDaBRate()[iii])) {
              voRetPrice.setBaPriceNoTaxSet(iii, voRetPrice3.isSetPriceNoTaxAt(ii));
              voRetPrice.setDaQueryValue(iii, voRetPrice3.getPriceAt(ii));
            }
          }
        }
      }
    }
    if (PuPubVO.getString_TrimZeroLenAsNull(values) != null && values.length() > 0) {
      cyclePriceVO(voRetPrice, values.substring(1, values.length()));// 没找到价格的用递归继续找下一个参数的价格
    }
    return voRetPrice;
  }

  public UFDouble transValue(UFDouble daPrice, String orgCurrPk, String desCurrPk, UFDouble ufBRate,
      RetPoVrmAndParaPriceVO voPara) throws Exception {
    if (orgCurrPk.trim().equals(desCurrPk)) {// 原币和本币相同不折算
      return daPrice;
    }
    String corpId = voPara.getPk_corp();
    BusinessCurrencyRateUtil curTool = new BusinessCurrencyRateUtil(corpId);

    try {
      // 金额
      if (daPrice == null) {
        daPrice = null;
      }
      else {
        daPrice = curTool.getOriginAmountByOpp(orgCurrPk, desCurrPk, daPrice, ufBRate, voPara.getClientLink().getLogonDate()
            .toString());
      }

    }
    catch (Exception ex) {
      throw ex;
    }
    return daPrice;
  }

  /**
   * 方法功能描述：结算完毕自动传应付。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param settleItemVOs
   * @throws BusinessException
   *           <p>
   * @author zhanghongfang
   * @time 2008-8-21 下午04:28:56
   */
  public void settleAllToARAP(SettlebillItemVO[] settleItemVOs, String strLoginCorp, String sOprator, String strOprType)
      throws BusinessException {
    ISysInitQry myService = (ISysInitQry) nc.bs.framework.common.NCLocator.getInstance().lookup(
        ISysInitQry.class.getName());
    UFBoolean bAutoSettle = myService.getParaBoolean(strLoginCorp, "PO07");
    if (!PuPubVO.getUFBoolean_NullAs(bAutoSettle, new UFBoolean(false)).booleanValue())
      return;
    ArrayList<String> invoiceList = new ArrayList<String>();
    for (SettlebillItemVO vo : settleItemVOs) {
      // zhf 为 结算自动传应付准备数据
      if (PuPubVO.getString_TrimZeroLenAsNull(vo.getCinvoiceid()) != null
          && !invoiceList.contains(vo.getCinvoiceid().trim())) {
        invoiceList.add(vo.getCinvoiceid().trim());
      }
    }
    if (invoiceList != null && invoiceList.size() > 0) {
      try {
        doCrtAPBill(invoiceList.toArray(new String[invoiceList.size()]), sOprator, strOprType);
      }
      catch (Exception e) {
        PubDMO.throwBusinessException(e);
      }
    }
  }

  /**
   * 结算完毕，自动传应付。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例:发票结算完毕，自动传应付失败，不影响结算操作。
   * <p>
   * <b>参数说明</b>
   * 
   * @param  saCinvoiceid   发票头ID数组
   * @param  strOper    操作员ID
   * @param  strOprType   操作类型{APPROVE}，如果是审批类型，则在配置了审批自动传应付组件时，就不必再传应付了
   * @author lixiaodong
   * @throws BusinessException
   * @throws NamingException
   * @throws SystemException
   * @time 2008-8-15 下午01:16:36
   */
  public String[] doCrtAPBill(String[] saCinvoiceid, String strOper, String strOprType) throws BusinessException {
    if (saCinvoiceid == null || saCinvoiceid.length < 1 || PuPubVO.getString_TrimZeroLenAsNull(strOper) == null) {
      return null;
    }
    InvoiceVO[] voaInvoice = null;
    String strHidSet = new TempTableUtil().getSubSql(saCinvoiceid);
    // 查询表头
    try {
      // 未审批通过单据不自动传应付
      voaInvoice = new InvoiceDMO().findInvoiceVOsByAllItems("from po_invoice where cinvoiceid in " + strHidSet
          + " and ibillstatus = 3 and bapflag = 'N' ");
    }
    catch (Exception e) {
      PubDMO.throwBusinessException(e);
    }
    if (voaInvoice == null) {
      return null;
    }
    int iLen = voaInvoice.length;
    // 业务类型主键
    ArrayList<String> listBiztypeId = new ArrayList<String>();
    for (int i = 0; i < iLen; i++) {
      if (!listBiztypeId.contains(voaInvoice[i].getHeadVO().getCbiztype())) {
        listBiztypeId.add(voaInvoice[i].getHeadVO().getCbiztype());
      }
    }
    // UAP服务，根据业务类型下"CRTBILL"驱动动作是否配置了相应被驱动动作，来确定业务类型是否配置了传应付组件
    IPFMetaModel srvPFMetaModel = (IPFMetaModel) NCLocator.getInstance().lookup(IPFMetaModel.class.getName());
    MessagedriveVO[] driveVOs = null;
    String strBiztypeId = null;
    HashMap<String, String> mapApproveDrive = new HashMap<String, String>();
    HashMap<String, String> mapCrtApBillDrive = new HashMap<String, String>();
    for (int i = 0; i < listBiztypeId.size(); i++) {
      strBiztypeId = listBiztypeId.get(i);
      driveVOs = srvPFMetaModel.queryAllMsgdrvVOs(null, "25", strBiztypeId, "APPROVE");
      if (driveVOs != null && driveVOs.length > 0) {
        mapApproveDrive.put(strBiztypeId, "");
      }
      driveVOs = srvPFMetaModel.queryAllMsgdrvVOs(null, "25", strBiztypeId, "CRTAPBILL");
      if (driveVOs != null && driveVOs.length > 0) {
        mapCrtApBillDrive.put(strBiztypeId, "");
      }
    }
    InvoiceVO invoiceVO = null;
    try {
      // 滤掉虚拟发票
      voaInvoice = filterVirtualInvoice(voaInvoice);
      
      // 过滤掉费暂估应付的发票
      //
      InvoiceItemVO[] bodyVO = null;
      InvoiceHeaderVO headVO = null;
      int intLen = voaInvoice.length;
      int iCnt = 0;
      String strLoginDate = BsPuTool.getLoginDate().toString();
      for (int j = 0; j < intLen; j++) {
        invoiceVO = voaInvoice[j];
        bodyVO = invoiceVO.getBodyVO();
        headVO = invoiceVO.getHeadVO();
        // 业务类型未配置传应付组件，则不自动传应付
        if (!mapCrtApBillDrive.containsKey(headVO.getCbiztype())) {
          SCMEnv.out("采购发票“" + invoiceVO.getHeadVO().getVinvoicecode() + "”业务类型未配置传应付组件，则不自动传应付");/*-=notranslate=-*/
          continue;
        }
        /*
         * 如果配置了发票审批自动传应付时，则结算完毕自动传应付不必要做了，否则会重复传应付。
         */
        if (strOprType != null && SettlebillVO.OPR_TYPE_APPROVE.equals(strOprType) && mapApproveDrive.containsKey(headVO.getCbiztype())) {
          SCMEnv.out("采购发票“" + invoiceVO.getHeadVO().getVinvoicecode() + "”配置了审批自动传应付,不必要结算完毕自动传应付");/*-=notranslate=-*/
          continue;
        }
        // PO52为是时才有必要要求发票整张单据结算完毕
        if (!isSettleAll(invoiceVO)) {
          SCMEnv.out("采购发票“票号：" + invoiceVO.getHeadVO().getVinvoicecode() + "”未整单结算完毕,不能自动传应付");/*-=notranslate=-*/
          iCnt++;
          continue;
        }
        // 调用N_strType_SAVE脚本，正式应付
        IPFBusiAction bsBusiAction = (IPFBusiAction) NCLocator.getInstance().lookup(IPFBusiAction.class.getName());
        bsBusiAction
            .processAction("CRTAPBILL", BillTypeConst.PO_INVOICE, strLoginDate, null, voaInvoice[j], null, null);
      }
      if (iCnt == intLen) {
        SCMEnv.out("所有参与此次结算的采购发票均未整单结算完毕,不能自动传应付");/*-=notranslate=-*/
        return null;
      }
    }
    catch (Exception e) {
      PubDMO.throwBusinessException(e);
    }
    return null;
  }

  /**
   * 方法功能描述：判断发票是否完全结算完毕。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param vo
   * @return
   * @throws SystemException
   * @throws NamingException
   * @throws SQLException
   * @throws BusinessException
   *           <p>
   * @author lixiaodong
   * @time 2008-8-15 下午03:02:58
   */
  private boolean isSettleAll(InvoiceVO vo) throws BusinessException {

    if (vo == null || vo.getBodyLen() < 1) {
      return false;
    }
    InvoiceItemVO[] bodyVO = vo.getBodyVO();
    Object oTemp = null;
    // 发票未结算完毕
    for (int i = 0; i < bodyVO.length; i++) {
      if (Math.abs(PuPubVO.getUFDouble_NullAsZero(bodyVO[i].getNaccumsettmny()).doubleValue()) != Math.abs(PuPubVO
          .getUFDouble_NullAsZero(bodyVO[i].getNmoney()).doubleValue())) {
        return false;
      }
    }
    // 发票结算完毕
    return true;
  }

  /**
   * 更新采购发票应付标志
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param voaInvoice
   * @throws BusinessException
   *           <p>
   * @author czp
   * @time 2008-10-7 下午02:27:09
   */
  public void updateApFlag(InvoiceVO[] voaInvoice, UFBoolean bApFlag) throws BusinessException {
    if (voaInvoice == null || voaInvoice.length == 0) {
      return;
    }
    ArrayList<String> listHid = new ArrayList<String>();
    for (InvoiceVO vo : voaInvoice) {
      listHid.add(vo.getHeadVO().getPrimaryKey());
    }
    ArrayList arr = new ArrayList();
    arr.add(listHid.toArray());
    arr.add(bApFlag);
    //
    updateBapFlag(arr);
  }

  public void updateBapFlag(ArrayList arr) throws BusinessException {
    InvoiceDMO dmo = null;
    try {
      dmo = new InvoiceDMO();
    }
    catch (SystemException e) {
      // 日志异常
      nc.vo.scm.pub.SCMEnv.out(e);
      // 按规范抛出异常
      nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
    }
    catch (NamingException e) {
      // 日志异常
      nc.vo.scm.pub.SCMEnv.out(e);
      // 按规范抛出异常
      nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
    }
    dmo.updateBapFlag(arr);
  }

  /**
   * 作者：王印芬 功能：保存后进行辅计量存货的检查，并检查辅计量时相关信息是否完全 该检查在脚本中置于保存（onSaveMy）后，所以数据库中应已有主键
   * 该方法为脚本配置方法，请不要随意修改参数、返回值、名称 参数：voChecked 待保存的VO 返回：无 例外：无 日期：(2001-10-13
   * 11:39:21) 修改日期，修改人，修改原因，注释标志：
   */
  public void validateAssistUnit(InvoiceVO vo) throws BusinessException {

    String sMethodName = "nc.bs.po.OrderImpl.validateAssistUnit(OrderVO)";
    // 参数正确性检查
    if (vo == null) {
      return;
    }

    // 需检查的VO
    InvoiceVO voChecked = getCheckVO(vo);
    // 所有
    InvoiceItemVO[] voaCheckedItem = voChecked.getBodyVO();

    // 主键
    String sOrderId = voChecked.getHeadVO().getPrimaryKey();
    String strWhere = "";
    if (PuPubVO.getString_TrimZeroLenAsNull(sOrderId) == null) {// 新增
      Set<String> invBaseID=new HashSet<String>();
      for(InvoiceItemVO item:voChecked.getBodyVO())
        invBaseID.add(item.getCbaseid());
      strWhere = "pk_invbasdoc in " + 
        new TempTableUtil().getSubSql(invBaseID.toArray(new String[invBaseID.size()]))
        + "  and dr=0";
    }
    else {
      strWhere = "pk_invbasdoc IN (SELECT cbaseid FROM po_invoice_b WHERE cinvoiceid='" + sOrderId + "' AND dr=0 )";
    }

    // 存放各存货是辅计量管理的Hashtable
    Hashtable htAssistUnit = null;
    try {
      // 得到各存货的是否辅计量Hashtable
      htAssistUnit = new PubDMO().queryHtResultFromAnyTable("bd_invbasdoc", "pk_invbasdoc", new String[] {
        "assistunit"
      }, strWhere);
    }
    catch (Exception e) {

      PubDMO.throwBusinessException(sMethodName, e);
    }

    if (htAssistUnit == null) {
      return;
    }

    // 检查
    String sBaseId = null;
    int iBodyLen = voaCheckedItem.length;
    for (int i = 0; i < iBodyLen; i++) {
      sBaseId = voaCheckedItem[i].getCbaseid();
      // 无辅计量
      if (!htAssistUnit.containsKey(sBaseId)) {
        continue;
      }
      // 取辅计量值
      Vector vecAssistUnit = (Vector) htAssistUnit.get(sBaseId);
      String sAssistManaged = ((Object[]) vecAssistUnit.get(0))[0].toString();

      // 是辅计量管理
      if (sAssistManaged.equalsIgnoreCase("Y")) {
        if ((voaCheckedItem[i].getCassistunit() == null || voaCheckedItem[i].getCassistunit().equals("") || voaCheckedItem[i]
            .getNassistnum() == null)
            // 并且主数量大于0时
            && voaCheckedItem[i].getNinvoicenum() != null && voaCheckedItem[i].getNinvoicenum().doubleValue() != 0) {
          PubDMO.throwBusinessException(sMethodName, new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
              .getStrByID("4004020201", "UPP4004020201-000208", null, new String[] {
                new Integer(i + 1).toString()
              })/* @res "行号为{0}存在为辅计量管理的存货，但无辅单位或辅数量，请检查" */));
        }
      }
    }
  }

  /**
   * 作者：王印芬 功能：返回界面上的VO，主要用于如各项检查(如空、最高限价等)，滤掉了DELETE的行及历史行 参数： 返回：OrderVO
   * 界面上的VO 例外：无 日期：(2003-06-03 11:39:21) 修改日期，修改人，修改原因，注释标志：
   */
  public InvoiceVO getCheckVO(InvoiceVO vo) {

    // 界面VO，真正作检查(如空、最高限价等)的行
    InvoiceItemVO[] voaCheckItem = null;
    // 所有VO，包括删除的及历史行
    InvoiceItemVO[] voaAllItem = vo.getBodyVO();
    if (voaAllItem != null) {
      Vector vecCheckBody = new Vector();
      int iTotalLen = voaAllItem.length;
      for (int i = 0; i < iTotalLen; i++) {
        // 已删除的行及历史行不作检查
        if (voaAllItem[i].getStatus() != VOStatus.DELETED) {
          vecCheckBody.addElement(voaAllItem[i]);
        }
      }

      int iCheckLen = vecCheckBody.size();
      if (iCheckLen != 0) {
        voaCheckItem = new InvoiceItemVO[iCheckLen];
        vecCheckBody.copyInto(voaCheckItem);
      }
    }

    InvoiceVO voCheck = new InvoiceVO();
    voCheck.setParentVO(vo.getParentVO());
    voCheck.setChildrenVO(voaCheckItem);

    return voCheck;
  }

  /**
   * 过滤掉未结算完毕的单据
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param voaInv
   *          待过滤的采购发票VO数组
   * @return
   * @throws BusinessException
   *           <p>
   * @author czp
   * @time 2008-9-27 上午11:04:17
   */
  public InvoiceVO[] filterVirtualInvoiceNotSettleEnd(InvoiceVO[] voaInv) throws BusinessException {
    //
    if (voaInv == null || voaInv.length == 0) {
      return null;
    }
    ArrayList<InvoiceVO> listVo = new ArrayList<InvoiceVO>();
    for (InvoiceVO vo : voaInv) {
      if (vo == null)
        continue;
      if (isSettleAll(vo)) {
        listVo.add(vo);
      }
    }
    if (listVo.size() == 0) {
      return null;
    }
    return listVo.toArray(new InvoiceVO[listVo.size()]);
  }

  /**
   * 根据业务类型返回业务类型VO
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param strBizTypeId
   *          业务类型主键
   * @return 业务类型VO
   *         <p>
   * @author czp
   * @time 2008-10-17 下午01:04:01
   */
  public BusitypeVO getBusitypeVO(String strBizTypeId) throws BusinessException {

    Collection coVos = null;
    BusitypeVO[] voaBusitype = null;
    BusitypeVO voBusitype = new BusitypeVO();
    voBusitype.setPk_busitype(strBizTypeId);
    IUAPQueryBS srvQuery = (IUAPQueryBS) NCLocator.getInstance().lookup(IUAPQueryBS.class.getName());
    coVos = srvQuery.retrieve(voBusitype, new Boolean(true));
    voaBusitype = (BusitypeVO[]) coVos.toArray(new BusitypeVO[coVos.size()]);
    if (voaBusitype == null || voaBusitype.length == 0) {
      return null;
    }
    return voaBusitype[0];
  }

  /**
   * 判定业务类型的流程配置中A驱动动作下的被驱动动作中是否含有B
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param String
   *          strBizTypeId 业务类型ID
   * @param String
   *          strBillTypeCode 单据类型编码，如采购发票“25”
   * @param String
   *          strActionSrc 驱动动作，如“CRTAPBILL”
   * @param String
   *          strActionDst 被驱动动作，如“SAVE”
   * @return A驱动动作下的被驱动动作中是否含有B，则返回true,否则返回false
   * @throws BusinessException
   *           <p>
   * @author czp
   * @time 2008-10-8 下午02:21:19
   */
  public boolean isValidActionDrive(String strBizTypeId, String strBillTypeCode, String strActionSrc,
      String strActionDst) throws BusinessException {
    //
    if (strBizTypeId == null || strBillTypeCode == null || strActionSrc == null || strActionDst == null) {
      SCMEnv.out((strBizTypeId == null || strBillTypeCode == null || strActionSrc == null || strActionDst == null)
          + ":(strBizTypeId == null || strBillTypeCode == null || strActionSrc == null || strActionDst == null)");
      return false;
    }
    // 业务类型主键
    // UAP服务，查询驱动
    IPFMetaModel srvPFMetaModel = (IPFMetaModel) NCLocator.getInstance().lookup(IPFMetaModel.class.getName());
    MessagedriveVO[] driveVOs = null;
    boolean bExistFlag = false;
    // 查询发票(25)传应付动作(CRTAPBILL)的所有被驱动动作
    driveVOs = srvPFMetaModel.queryAllMsgdrvVOs(null, strBillTypeCode, strBizTypeId, strActionSrc);
    if (driveVOs == null || driveVOs.length == 0) {
      SCMEnv.out("单据类型：" + strBillTypeCode + "的驱动动作" + strActionSrc + "没有配置任何被驱动动作");/*-=notranslate=-*/
      return false;
    }
    // 判断发票(25)传应付动作(CRTAPBILL)的所有被驱动动作中是否有保存动作(SAVE)
    bExistFlag = false;
    for (MessagedriveVO vo : driveVOs) {
      if (vo != null && strActionDst.equalsIgnoreCase(vo.getActiontype())) {
        bExistFlag = true;
        break;
      }
    }
    if (!bExistFlag) {
      SCMEnv.out("单据类型：" + strBillTypeCode + "的驱动动作" + strActionSrc + "配置的被驱动动作中无" + strActionDst + "动作");/*-=notranslate=-*/
      return false;
    }
    return true;
  }

  /**
   * 检查流程配置中的N_25_CRTAPBILL 是否配置了被驱动动作N_25_WASHAPBILL，未配置，则抛异常
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param voaInvoice
   *          发票VO数组
   * @throws BusinessException
   *           <p>
   * @author czp
   * @time 2008-10-8 下午02:21:19
   */
  public void check25DriveSetValid(InvoiceVO[] voaInvoice) throws BusinessException {
    //
    if (voaInvoice == null || voaInvoice.length == 0) {
      return;
    }
    // 暂估应付启用才有必要判断
    ISysInitQry sysQry = (ISysInitQry) NCLocator.getInstance().lookup(ISysInitQry.class.getName());
    UFBoolean ufbZgyf = sysQry.getParaBoolean(BsPuTool.getLoginCorp(null), "PO52");
    if (ufbZgyf == null) {
      ufbZgyf = UFBoolean.FALSE;
    }
    boolean bAdjustForZGYF = ufbZgyf.booleanValue();
    if (!bAdjustForZGYF) {
      SCMEnv.out("本公司未启用暂估应付，不必要检查流程配置中的N_25_CRTAPBILL 是否配置了被驱动动作N_25_WASHAPBILL，未配置");/*-=notranslate=-*/
      return;
    }
    // 业务类型主键
    ArrayList<String> listBiztypeId = new ArrayList<String>();
    for (InvoiceVO vo : voaInvoice) {
      if (!listBiztypeId.contains(vo.getHeadVO().getCbiztype())) {
        listBiztypeId.add(vo.getHeadVO().getCbiztype());
      }
    }
    if (listBiztypeId.size() == 0) {
      return;
    }
    int iSize = listBiztypeId.size();
    // UAP服务，查询驱动
    IPFMetaModel srvPFMetaModel = (IPFMetaModel) NCLocator.getInstance().lookup(IPFMetaModel.class.getName());
    // 查询业务类型下单据类型集合
    IUAPQueryBS srvQuery = (IUAPQueryBS) NCLocator.getInstance().lookup(IUAPQueryBS.class.getName());
    String strBiztypeId = null;
    String strBiztypeName = null;
    MessagedriveVO[] driveVOs = null;
    Collection coVos = null;
    BusitypeVO voBusitype = null;
    BusitypeVO[] voaBusitype = null;
    ArrayList<String> listBiztypeIdErr = new ArrayList<String>();
    boolean bExistFlag = false;
    for (int i = 0; i < iSize; i++) {
      strBiztypeId = listBiztypeId.get(i);
      if (strBiztypeId == null) {
        continue;
      }
      // 查询发票(25)传应付动作(CRTAPBILL)的所有被驱动动作
      driveVOs = srvPFMetaModel.queryAllMsgdrvVOs(null, "25", strBiztypeId, "CRTAPBILL");
      if (driveVOs == null || driveVOs.length == 0) {
        listBiztypeIdErr.add(strBiztypeId);
        continue;
      }
      // 判断发票(25)传应付动作(CRTAPBILL)的所有被驱动动作中是否有暂估冲减应付动作(WASHAPBILL)
      bExistFlag = false;
      for (MessagedriveVO vo : driveVOs) {
        if (vo != null && "WASHAPBILL".equalsIgnoreCase(vo.getActiontype())) {
          bExistFlag = true;
          break;
        }
      }
      if (!bExistFlag) {
        listBiztypeIdErr.add(strBiztypeId);
        continue;
      }
    }
    if (listBiztypeIdErr.size() == 0) {
      SCMEnv.out("检查通过：公司启用了暂估应付，流程配置中的N_25_CRTAPBILL 均配置了被驱动动作N_25_WASHAPBILL");/*-=notranslate=-*/
      return;
    }
    //
    String strBiztypeNames = "";
    for (int i = 0; i < listBiztypeIdErr.size(); i++) {
      voBusitype = new BusitypeVO();
      voBusitype.setPk_busitype(strBiztypeId);
      coVos = srvQuery.retrieve(voBusitype, new Boolean(true));
      voaBusitype = (BusitypeVO[]) coVos.toArray(new BusitypeVO[coVos.size()]);
      if (voaBusitype != null && voaBusitype.length > 0 && voaBusitype[0] != null
          && PuPubVO.getString_TrimZeroLenAsNull(voaBusitype[0].getBusiname()) != null) {
        strBiztypeNames += voaBusitype[0].getBusiname();
        strBiztypeNames += ",";
      }
    }
    if (strBiztypeNames.length() > 0) {
      strBiztypeNames = strBiztypeNames.substring(0, strBiztypeNames.length() - 1);
      // "本公司启用了暂估应付，部分业务类型流程配置错误：发票传应付动作(CRTAPBILL)的被驱动动作“冲暂估应付”(WASHAPBILL)未配置。存在配置错误的业务类型列表如下:{0}");
      throw new BusinessException(NCLangResOnserver.getInstance().getStrByID("40040401", "UPP40040401-000262", null,
          new String[] {
            strBiztypeNames
          }));

    }
  }

  /**
   * 采购发票的流程配置中，如果配置了传应付，则要求传应付被驱动动作列表中必须含有SAVE动作 即，检查流程配置中的N_25_CRTAPBILL
   * 是否配置了被驱动动作N_XX_SAVE，未配置，则抛异常
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param voaInvoice
   * @throws BusinessException
   *           <p>
   * @author czp
   * @time 2008-10-20 下午04:09:19
   */
  public void checkDriveCRTAPBILL(InvoiceVO[] voaInvoice) throws BusinessException {
    //
    if (voaInvoice == null || voaInvoice.length == 0) {
      return;
    }
    // 业务类型主键
    ArrayList<String> listBiztypeId = new ArrayList<String>();
    for (InvoiceVO vo : voaInvoice) {
      if (!listBiztypeId.contains(vo.getHeadVO().getCbiztype())) {
        listBiztypeId.add(vo.getHeadVO().getCbiztype());
      }
    }
    if (listBiztypeId.size() == 0) {
      return;
    }
    int iSize = listBiztypeId.size();
    // UAP服务，查询驱动
    IPFMetaModel srvPFMetaModel = (IPFMetaModel) NCLocator.getInstance().lookup(IPFMetaModel.class.getName());
    // 查询业务类型下单据类型集合
    IUAPQueryBS srvQuery = (IUAPQueryBS) NCLocator.getInstance().lookup(IUAPQueryBS.class.getName());
    String strBiztypeId = null;
    String strBiztypeName = null;
    MessagedriveVO[] driveVOs = null;
    Collection coVos = null;
    BusitypeVO voBusitype = null;
    BusitypeVO[] voaBusitype = null;
    ArrayList<String> listBiztypeIdErr = new ArrayList<String>();
    boolean bExistFlag = false;
    for (int i = 0; i < iSize; i++) {
      strBiztypeId = listBiztypeId.get(i);
      if (strBiztypeId == null) {
        continue;
      }
      // 查询发票(25)传应付动作(CRTAPBILL)的所有被驱动动作
      driveVOs = srvPFMetaModel.queryAllMsgdrvVOs(null, "25", strBiztypeId, "CRTAPBILL");
      if (driveVOs == null || driveVOs.length == 0) {
        listBiztypeIdErr.add(strBiztypeId);
        continue;
      }
      // 判断发票(25)传应付动作(CRTAPBILL)的所有被驱动动作中是否有暂估冲减应付动作(WASHAPBILL)
      bExistFlag = false;
      for (MessagedriveVO vo : driveVOs) {
        if (vo != null && "SAVE".equalsIgnoreCase(vo.getActiontype())) {
          bExistFlag = true;
          break;
        }
      }
      if (!bExistFlag) {
        listBiztypeIdErr.add(strBiztypeId);
        continue;
      }
    }
    if (listBiztypeIdErr.size() == 0) {
      SCMEnv.out("发票传应付付组件业务类型流程配置检查通过：N_25_CRTAPBILL均正确配置了被驱动动作N_XX_SAVE");/*-=notranslate=-*/
      return;
    }
    //
    String strBiztypeNames = "";
    for (int i = 0; i < listBiztypeIdErr.size(); i++) {
      voBusitype = new BusitypeVO();
      voBusitype.setPk_busitype(listBiztypeIdErr.get(i));
      coVos = srvQuery.retrieve(voBusitype, new Boolean(true));
      voaBusitype = (BusitypeVO[]) coVos.toArray(new BusitypeVO[coVos.size()]);
      if (voaBusitype != null && voaBusitype.length > 0 && voaBusitype[0] != null
          && PuPubVO.getString_TrimZeroLenAsNull(voaBusitype[0].getBusiname()) != null) {
        strBiztypeNames += voaBusitype[0].getBusiname() + "[编码:" + voaBusitype[0].getBusicode() + "]";
        strBiztypeNames += ",";
      }
    }
    if (strBiztypeNames.length() > 0) {
      String strResId = "UPP40040401-000267";
      if (listBiztypeIdErr.size() > 1) {
        strResId = "UPP40040401-000268";
      }
      strBiztypeNames = strBiztypeNames.substring(0, strBiztypeNames.length() - 1);
      // "要完成传应付功能，要求发票传应付组件的被驱动动作列表中必须含有应付单据的SAVE动作。存在配置错误的业务类型列表如下:{0}");
      throw new BusinessException(NCLangResOnserver.getInstance().getStrByID("40040401", strResId, null, new String[] {
        strBiztypeNames
      }));

    }
  }

  /**
   * 方法功能描述：追加增行情形下发票保存的并发检查。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * 
   * @param inVO
   * @return
   * @throws Exception
   *           <p>
   * @author lixiaodong
   * @time 2008-10-24 下午03:04:46
   */
  public UFBoolean checkVoNoChanged(nc.vo.pi.InvoiceVO inVO) throws Exception {
    UFBoolean isContinueLine = UFBoolean.FALSE;
    java.util.Hashtable<Integer, String> h = new java.util.Hashtable<Integer, String>();
    nc.bs.pu.pub.PubDMO pubDMO = new nc.bs.pu.pub.PubDMO();
    nc.vo.pi.InvoiceVO[] splitInvoiceVO = new nc.vo.pi.InvoiceVO[2];
    java.util.Vector<nc.vo.pi.InvoiceItemVO> vctItemVO21 = new java.util.Vector<nc.vo.pi.InvoiceItemVO>();
    java.util.Vector<nc.vo.pi.InvoiceItemVO> vctItemVO45 = new java.util.Vector<nc.vo.pi.InvoiceItemVO>();
    if (inVO.getChildrenVO() != null && inVO.getChildrenVO().length > 0) {
      for (int i = 0; i < inVO.getChildrenVO().length; i++) {
        if (PuPubVO.getString_TrimZeroLenAsNull(((nc.vo.pi.InvoiceItemVO[]) inVO.getChildrenVO())[i]
            .getCupsourcebilltype()) != null) {
          if (!h.containsValue(((nc.vo.pi.InvoiceItemVO[]) inVO.getChildrenVO())[i].getCupsourcebilltype())) {
            h.put(i, ((nc.vo.pi.InvoiceItemVO[]) inVO.getChildrenVO())[i].getCupsourcebilltype());
          }
          if (nc.vo.scm.pu.BillTypeConst.PO_ORDER.equalsIgnoreCase(((nc.vo.pi.InvoiceItemVO[]) inVO.getChildrenVO())[i]
              .getCupsourcebilltype())) {
            vctItemVO21.add(((nc.vo.pi.InvoiceItemVO[]) inVO.getChildrenVO())[i]);
          }
          else if (nc.vo.scm.pu.BillTypeConst.STORE_PO.equalsIgnoreCase(((nc.vo.pi.InvoiceItemVO[]) inVO
              .getChildrenVO())[i].getCupsourcebilltype())) {
            vctItemVO45.add(((nc.vo.pi.InvoiceItemVO[]) inVO.getChildrenVO())[i]);
          }
        }
      }
      if (h != null && h.size() > 1) {// 追加增行
        isContinueLine = UFBoolean.TRUE;
      }
    }
    if (isContinueLine.booleanValue()) {
      if (vctItemVO21 != null && vctItemVO21.size() > 0) {
        splitInvoiceVO[0] = new InvoiceVO();
        splitInvoiceVO[0].setParentVO(inVO.getHeadVO());
        splitInvoiceVO[0].setChildrenVO((nc.vo.pi.InvoiceItemVO[]) vctItemVO21
            .toArray(new nc.vo.pi.InvoiceItemVO[vctItemVO21.size()]));
        pubDMO.checkVoNoChanged(splitInvoiceVO[0]);
      }
      if (vctItemVO45 != null && vctItemVO45.size() > 0) {
        splitInvoiceVO[1] = new InvoiceVO();
        splitInvoiceVO[1].setParentVO(inVO.getHeadVO());
        splitInvoiceVO[1].setChildrenVO((nc.vo.pi.InvoiceItemVO[]) vctItemVO45
            .toArray(new nc.vo.pi.InvoiceItemVO[vctItemVO45.size()]));
        pubDMO.checkVoNoChanged(splitInvoiceVO[1]);
      }
    }
    return isContinueLine;

  }

  /**
   * 根据表头ID数组返回轻量发票头VO数组(为减少从服务器端下载数据量设计)
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param saHid              表头ID数组，非空，非零长
   * @param saFieldHeld        需要保留的表头字段列表，非空
   * @return 根据表头ID数组查询发票头VO数组，再根据saFieldName决定保留字段，清空其它未指定的字段返回轻量发票头VO
   * @throws BusinessException
   * <p>
   * @author czp
   * @time 2008-12-11 下午07:50:20
   */
  public InvoiceHeaderVO[] findLightHeaderVosByHids(String[] saHid, String[] saFieldHeld) throws BusinessException{
    if(saHid == null || saHid.length == 0){
      return null;
    }
    if(saFieldHeld == null || saFieldHeld.length == 0){
      return null;
    }
    InvoiceVO[] voaInvoice = null;
    //
    String[] saFieldHeadAll = InvoiceHeaderVO.getDbFields();
    int iLenHeaderFields = saFieldHeadAll.length; 
    InvoiceDMO dmo = null;
    try{
      dmo = new InvoiceDMO();
    }catch(SystemException e){
      SCMEnv.out(e);
      throw new BusinessException(e.getMessage());
    }catch(NamingException e){
      SCMEnv.out(e);
      throw new BusinessException(e.getMessage());
    }
    //只返回表头部分信息
    String strSQL = " cinvoiceid in " + new TempTableUtil().getSubSql(saHid) + " and dr = 0 ";
    InvoiceHeaderVO[] headers = (InvoiceHeaderVO[]) dmo.queryAllHeadData(strSQL);
    if(headers == null || headers.length == 0){
      return null;
    }
    int iLen = headers.length;
    voaInvoice = new InvoiceVO[iLen];
    //
    ArrayList<String> listFieldHeld = new ArrayList<String>();
    for(int i=0 ; i<saFieldHeld.length; i++){
      listFieldHeld.add(saFieldHeld[i]);
    }
    for(int i=0; i<iLen; i++){
      for(int j=0; j<iLenHeaderFields; j++){
        //如果不是前台需要的，则清空此值
        if(!listFieldHeld.contains(saFieldHeadAll[j])){
          headers[i].setAttributeValue(saFieldHeld[i], null);
        }
      }
    }
    return headers;
  }
  
  /**
   * 
   * 方法功能描述：过滤掉资产仓(发票行和相应的入库单行的仓库)的发票行。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param invoiceItemVos 发票行VO
   * @param source 发票行来源(订单,入库单等),常量定义在InvoiceVO中
   * @return 过滤掉资产仓的发票行VO列表,不为空,可能长度为0
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2008-12-12 下午01:59:12
   */
  public List<InvoiceItemVO> filteUncalculateInvCost(InvoiceItemVO[] invoiceItemVos, int source) 
  throws BusinessException{
    //保存返回值
    List<InvoiceItemVO> retVos=new ArrayList<InvoiceItemVO>();
    if(invoiceItemVos==null || invoiceItemVos.length==0) return retVos;
    //保存发票表体ID
    ArrayList<String> invoiceItemIDs=new ArrayList<String>();
    ArrayList<String> stockOrderItemIDs=new ArrayList<String>();
    for(InvoiceItemVO vo:invoiceItemVos){
     invoiceItemIDs.add(vo.getCinvoice_bid());
     if(vo.getCupsourcebillrowid()!=null && vo.getCupsourcebillrowid().trim().length()>0)
       stockOrderItemIDs.add(vo.getCupsourcebillrowid());
    } 
    String whereClause=new TempTableUtil().getSubSql(stockOrderItemIDs);
    StringBuilder fromClause= new StringBuilder("po_invoice_b a left outer join ");
    fromClause.append("ic_general_b b on a.cupsourcebillrowid=");
    //如果来源于订单
    if(InvoiceVO.FROM_ORDER==source){
      fromClause.append("b.cfirstbillbid ");
      whereClause=" (b.cfirstbillbid in "+whereClause + " or b.cfirstbillbid is null)";
    //如果来源于入库单
    }else{
      fromClause.append("b.cgeneralbid ");
      whereClause=" (b.cgeneralbid in "+whereClause + " or b.cgeneralbid is null)";
    }
    fromClause.append("left outer join ic_general_h c on b.cgeneralhid=c.cgeneralhid ");
    String[] selectClause= new String[]{"coalesce(a.cwarehouseid,'    ')","coalesce(c.cwarehouseid,'    ')"};
    whereClause+=" and a.dr=0 and (b.dr=0 or b.dr is null) and (c.dr=0 or c.dr is null) ";
    try {
      //查询发票仓库信息
      //包括发票和入库单上的仓库
      PubDMO dmo=new PubDMO();
      Map invoiceStockWareHouses=dmo.queryArrayValues(fromClause.toString(), 
          "a.cinvoice_bid", selectClause, invoiceItemIDs.toArray(new String[0]), whereClause);
      List<String> warehouseIDs=new ArrayList<String>();
      for(Object o:invoiceStockWareHouses.values()){
        Object[] unCalWHs=(Object[])o;
        warehouseIDs.add(unCalWHs[0].toString());
        warehouseIDs.add(unCalWHs[1].toString());
      }
      //查询仓库是否成本计算库
      Map warehouseCalCostInfo=dmo.queryArrayValues("bd_stordoc", "pk_stordoc",
          new String[] {"iscalculatedinvcost"},
          warehouseIDs.toArray(new String[0]),
          "coalesce(iscalculatedinvcost,'Y')='N' and dr=0");
      
      for(InvoiceItemVO vo:invoiceItemVos){
        String invoiceItemID=vo.getCinvoice_bid();
        //得到发票行和入库单的仓库信息
        Object[] unCalWHs=(Object[])invoiceStockWareHouses.get(invoiceItemID);
        if(unCalWHs==null || unCalWHs.length<2 || unCalWHs[0]==null || unCalWHs[1]==null){
         retVos.add(vo); 
         continue;
        }
        if(!warehouseCalCostInfo.containsKey(unCalWHs[0].toString()) && 
            !warehouseCalCostInfo.containsKey(unCalWHs[1].toString())){
          retVos.add(vo);
        }
      }
    }
    catch (Exception e) {
      //日志异常
      nc.vo.scm.pub.SCMEnv.out(e);
      //按规范抛出异常
      nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
    }
    return retVos;
  }
  
  /**
   * 
   * 方法功能描述：保存时做源头为订单的发票尾差处理。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param invVO 发票VO
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2009-2-13 上午11:24:03
   */
  private void dealLastRemnant(InvoiceVO invVO) throws BusinessException {
    if(invVO==null) return;
   
    //来源订单的发票items,及来源订单信息<corder_bid,InvoiceItemVO>
    Map<String,InvoiceItemVO> invoiceItemsFromOrder=new HashMap<String,InvoiceItemVO>();
    List<String> poOrderIds=new ArrayList<String>();
    List<String> scOrderIds=new ArrayList<String>();
    for(InvoiceItemVO item:invVO.getBodyVO()){
      //如果是费用存货 V56
      if(item.getBFeeFlag()!=null && item.getBFeeFlag().booleanValue()) continue;
      //只处理来源于订单的发票,且为新增(UNCHANGED)或修改状态
      if(PuPubVO.getString_TrimZeroLenAsNull(item.getCorder_bid())!=null  
          && (PuPubVO.getString_TrimZeroLenAsNull(item.getCinvoice_bid())==null || item.getStatus()==VOStatus.UPDATED)
          ){
        invoiceItemsFromOrder.put(item.getCorder_bid(),item);
        //来源于采购订单
        if(ScmConst.PO_Order.equals(item.getCsourcebilltype()))
          poOrderIds.add(item.getCorder_bid());
        //来源于委外订单
        else if(ScmConst.SC_Order.equals(item.getCsourcebilltype()))
          scOrderIds.add(item.getCorder_bid());
      }
    }
    if(poOrderIds.size()==0 && scOrderIds.size()==0) return;
    // 查询相应的订单信息
    Map<String,OrderItemVO> poOrdersItems=getOrderItemsForDealRemnant(ScmConst.PO_Order, poOrderIds.toArray(new String[0]));
    Map<String,OrderItemVO> scOrdersItems=new HashMap<String,OrderItemVO>();
    if(scOrderIds.size()>0)
      scOrdersItems=getOrderItemsForDealRemnant(ScmConst.SC_Order, scOrderIds.toArray(new String[0]));
    // 查询以前开票信息
    HashMap<String, InvoiceItemVO[]> preInvoiceItems=queryInvoiceBodysStore(poOrderIds.toArray(new String[0]));
    if(preInvoiceItems==null) preInvoiceItems=new HashMap<String, InvoiceItemVO[]>();
    // 生成尾差处理公共算法的参数信息
    List<InvoiceItemVO> remnantInvoiceItems=new ArrayList<InvoiceItemVO>();
    ArrayList prevoiusInvoiceItems=new ArrayList<InvoiceItemVO[]>();
    List<OrderItemVO> sourceOrderItems=new ArrayList<OrderItemVO>();
    for(Object key:invoiceItemsFromOrder.keySet()){
      //要处理的发票信息
      InvoiceItemVO invoiceItem = invoiceItemsFromOrder.get(key);
      //以前开票信息
      InvoiceItemVO[] preInvItems = preInvoiceItems.get(key);
      if(preInvItems==null) preInvItems=new InvoiceItemVO[0];
      List<InvoiceItemVO> filtedPreInvItems=new ArrayList<InvoiceItemVO>();
      //如果是更新发票行,则要从以前开票信息中去除
      if(invoiceItem.getStatus()==VOStatus.UPDATED &&
          PuPubVO.getString_TrimZeroLenAsNull(invoiceItem.getCinvoice_bid())!=null){
        for(InvoiceItemVO vo:preInvItems){
          if(!vo.getCinvoice_bid().equals(invoiceItem.getCinvoice_bid()))
            filtedPreInvItems.add(vo);
        }
        preInvItems=filtedPreInvItems.toArray(new InvoiceItemVO[0]);
      }
      
      //对应的订单
      OrderItemVO orderItem = poOrdersItems.get(key);
      if(orderItem==null) orderItem= scOrdersItems.get(key);
      if(orderItem==null) continue;
      //如果发票币种,价格与订单均相同，则进行容差处理
      if(invoiceItem.getCcurrencytypeid().equals(orderItem.getCcurrencytypeid())
          && invoiceItem.getNoriginalcurprice().equals(orderItem.getNoriginalnetprice())){
        remnantInvoiceItems.add(invoiceItem);
        prevoiusInvoiceItems.add(preInvItems);
        sourceOrderItems.add(orderItem);
      }
    }
    realDealRemnant(invVO, remnantInvoiceItems, prevoiusInvoiceItems,
        sourceOrderItems);
  }

  /**
   * 方法功能描述：进行尾差处理。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param invVO 发票VO
   * @param remnantInvoiceItems 要处理的发票行VOs
   * @param prevoiusInvoiceItems 相应行VO对应订单的以前开票信息
   * @param sourceOrderItems 相应发票行VO对应的订单
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2009-2-17 下午03:45:33
   */
  private void realDealRemnant(InvoiceVO invVO,
      List<InvoiceItemVO> remnantInvoiceItems, ArrayList prevoiusInvoiceItems,
      List<OrderItemVO> sourceOrderItems) throws BusinessException {
    try {
      //取得含税价格优先,还是无税优先(1无税,0含税)
      int iPricePriorPolicy = PubDMO.getPricePriorPolicy(invVO.getPk_corp())==6 ? 1:0;
      //调用公共方法时行尾差处理
      nc.vo.transfer.UpToDownEqualValueTool
      .setValueEqualToUpBillForStore(ScmConst.PO_Order, ScmConst.PO_Invoice, iPricePriorPolicy,
          sourceOrderItems.toArray(new OrderItemVO[0]), prevoiusInvoiceItems,
          remnantInvoiceItems.toArray(new InvoiceItemVO[0]));
      //重新设置金额,税额,价税合计(原币)
      for(InvoiceItemVO vo:remnantInvoiceItems){
        //得到汇率
        UFDouble exchgRate=PuPubVO.getUFDouble_NullAsZero(vo.getNexchangeotobrate());
        if(exchgRate.doubleValue()==0.0) exchgRate=new UFDouble(1.0);
        //得到换算工具
        BusinessCurrencyRateUtil currencyTool=new BusinessCurrencyRateUtil(invVO.getPk_corp());
        //得到金额精度
        int nMoneyDecimal = BsPuTool.getCCurrDecimal(invVO.getPk_corp());
        if(iPricePriorPolicy==0)
          vo.setNoriginalcurmny(PuPubVO.getUFDouble_NullAsZero(vo.getNoriginalsummny())
              .sub(PuPubVO.getUFDouble_NullAsZero(vo.getNoriginaltaxmny())));
        else
          vo.setNoriginalsummny(PuPubVO.getUFDouble_NullAsZero(vo.getNoriginalcurmny())
              .add(PuPubVO.getUFDouble_NullAsZero(vo.getNoriginaltaxmny())));
        //换算本币
        vo.setNmoney(currencyTool.getAmountByOpp(vo.getCcurrencytypeid(),BsPuTool.getLocalCurtype(), 
            PuPubVO.getUFDouble_NullAsZero(vo.getNoriginalcurmny()), exchgRate, null, nMoneyDecimal));
        vo.setNsummny(currencyTool.getAmountByOpp(vo.getCcurrencytypeid(),BsPuTool.getLocalCurtype(), 
            PuPubVO.getUFDouble_NullAsZero(vo.getNoriginalsummny()), exchgRate, null, nMoneyDecimal));
      }
    }
    catch (Exception e) {
      //日志异常
      nc.vo.scm.pub.SCMEnv.out(e);
      //按规范抛出异常
      nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
    }
  }
   
  
  /**
   * 
   * 方法功能描述：根据订单表体ID得到订单表体数据。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param orderType 采购订单(21)或委外订单(61)
   * @param orderIds 订单表体ID数组
   * @return Map(表体ID,订单体VO)
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2009-2-13 上午11:25:06
   */
  public Map<String,OrderItemVO> getOrderItemsForDealRemnant(String orderType,String[] orderIds) 
    throws BusinessException{
    
    if(orderIds==null && orderIds.length==0) return new HashMap<String,OrderItemVO>();
    String[] selectCols=new String[]{"nordernum","ccurrencytypeid","noriginalnetprice",
        "noriginalcurmny","norgnettaxprice","noriginaltaxpricemny","noriginaltaxmny"};
    String tableName="po_order_b";
    //需要处理精度的价格字段
    Set<String> priceCols=new HashSet<String>(Arrays.asList("noriginalnetprice","norgnettaxprice"));
    if(ScmConst.SC_Order.equals(orderType)){
      tableName="sc_order_b";
      selectCols[5]="noriginalsummny";
    }
    try {
      Map retMap = new PubDMO().queryArrayValues(tableName, "corder_bid",
          selectCols, orderIds, " dr=0");
      Map<String,OrderItemVO> results=new HashMap<String,OrderItemVO>();
      //得到单价精度
      int nPriceDecimal=BsPuTool.getPriceDigit(null);
      for(Object key:retMap.keySet()){
        OrderItemVO item=new OrderItemVO();
        item.setAttributeValue("corder_bid", key);
        Object[] columns=(Object[])retMap.get(key);
        for(int i=0;i<columns.length;++i)
          if(i==5) item.setAttributeValue("noriginaltaxpricemny",  columns[i]);
          else item.setAttributeValue(selectCols[i], columns[i]);
        //处理价格精度
        for(String col:priceCols)
          item.setAttributeValue(col, 
              PuPubVO.getUFDouble_NullAsZero(item.getAttributeValue(col)).add(new UFDouble(0),nPriceDecimal));
        results.put(key.toString(), item);
      }
      return results;
    }
    catch (Exception e) {
      //日志异常
      nc.vo.scm.pub.SCMEnv.out(e);
      //按规范抛出异常
      nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
    }
    return null;
  }
  
  
 /**
  * 
  * 父类方法重写
  * 
  * @see nc.itf.pi.IInvoice#queryFeeOrderArrayForInvoice(nc.vo.pi.NormalCondVO[], nc.vo.pub.query.ConditionVO[])
  */
  public OrderVO[] queryFeeOrderArrayForInvoice(NormalCondVO[] voaNormal,
      ConditionVO[] voaDefined) throws BusinessException{
    //从订单实现 类中查询符合条件的所有订单
    OrderVO[] allOrders=new OrderImpl().queryOrderArrayForInvoice(voaNormal, voaDefined);
    if(allOrders==null || allOrders.length==0) return new OrderVO[0];
    //过滤出其中的费用行
    Set<String> invBasID=new HashSet<String>();
    //得到所有订单行存货基本ID
    for(OrderVO orderVo:allOrders){
      OrderItemVO[] items=orderVo.getBodyVO();
      if(items==null || items.length==0) continue;
      for(OrderItemVO item:items)
        invBasID.add(item.getCbaseid());
    }
    List<OrderVO> newOrders=new ArrayList<OrderVO>();
    if(invBasID.size()>0){
      //查询费用行存货
      try {
        Map invLaborInfo=new PubDMO().queryArrayValues("bd_invbasdoc", "pk_invbasdoc", new String[]{"laborflag"},
            invBasID.toArray(new String[invBasID.size()]), " laborflag='Y' ");
        for(OrderVO orderVo:allOrders){
          OrderItemVO[] items=orderVo.getBodyVO();
          if(items==null || items.length==0) continue;
          List<OrderItemVO> newItems=new ArrayList<OrderItemVO>();
          //提出费用订单行
          for(OrderItemVO item:items)
            if(invLaborInfo.containsKey(item.getCbaseid()))
              newItems.add(item);
          if(newItems.size()>0){
           orderVo.setChildrenVO(newItems.toArray(new OrderItemVO[newItems.size()]));
           newOrders.add(orderVo);
          }
        }
      }
      catch (Exception e) {
        //日志异常
        nc.vo.scm.pub.SCMEnv.out(e);
        //按规范抛出异常
        nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
      }
    }
    return newOrders.toArray(new OrderVO[newOrders.size()]);
  }
  
  /**
   * 
   * 方法功能描述：得到发票表体费用(劳务和折扣)存货行。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param invVO
   * @return Set＜费用存货基本ID＞
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2009-3-31 下午03:32:46
   */
  public Set<String> getFeeInventory(InvoiceVO invVO) throws BusinessException{
    //组织存货基本ID
    String[] invBasIDs=new String[invVO.getBodyVO().length];
    for(int i=0;i<invBasIDs.length;++i)
      invBasIDs[i]=invVO.getBodyVO()[i].getCbaseid();
    try {
      Map laborInvInfo=new PubDMO().queryArrayValues("bd_invbasdoc", "pk_invbasdoc", new String[]{"laborflag","discountflag"},
          invBasIDs, " laborflag='Y' or discountflag='Y' ");
      if(laborInvInfo!=null) return laborInvInfo.keySet();
    }
    catch (Exception e) {
      //日志异常
      nc.vo.scm.pub.SCMEnv.out(e);
      //按规范抛出异常
      nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
    }
    return new HashSet<String>();
  }
  
  /**
   * 
   * 父类方法重写
   * 
   * @see nc.itf.pi.IInvoice#discardInvoiceForShop(nc.vo.pi.InvoiceVO[])
   */
  public void discardInvoiceForShop(InvoiceVO[] vos) throws BusinessException{
    if(vos==null || vos.length==0) return;
    //检查是否可删除
    for(InvoiceVO vo:vos)
      isASettledInvoiceCouldBeDiscarded(vo.getHeadVO().getCinvoiceid());
    //作废发票
    discardInvoiceArray(vos, null);
  }
  
  /**
   * 
   * 方法功能描述：设置发票表体行的费用存货标志。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param invVO
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2009-4-8 下午03:30:56
   */
  public void setFeeFlag(InvoiceVO invVO) throws BusinessException {
    Set<String> feeInventory=getFeeInventory(invVO);
    for(InvoiceItemVO item:invVO.getBodyVO()){
      if(feeInventory.contains(item.getCbaseid()))
        item.setBFeeFlag(UFBoolean.TRUE);
      else
        item.setBFeeFlag(UFBoolean.FALSE);
    }
  }
  
  /**
   * 
   * 方法功能描述：流程平台处理（送审或审批）后查询信息。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param vos
   * @return
   * @throws BusinessException
   * <p>
   * @author zhaoyha
   * @time 2009-8-20 上午11:22:54
   */
  public Map<String,Map<String,Object>> getNewInfoAfterPf(InvoiceVO[] vos) throws BusinessException{
    //组织发票ID
    String[] IDs=new String[vos.length];
    for(int i=0;i<IDs.length;++i)
      IDs[i]=vos[i].getPrimaryKey();
    Map queryInfos = null;
    try {
      queryInfos=new PubDMO().queryArrayValues("po_invoice", "cinvoiceid", new String[]{"ibillstatus","ts"},
          IDs, " dr=0 ");
      if(queryInfos!=null){
        for(Object key:queryInfos.keySet()){
         Map<String,Object> columns=new HashMap<String, Object>();
         columns.put("ibillstatus", 
             PuPubVO.getInteger_NullAs(((Object[])queryInfos.get(key))[0],0));
         columns.put("ts", ((Object[])queryInfos.get(key))[1]);
         queryInfos.put(key, columns);
        }
      }
    }
    catch (Exception e) {
      //日志异常
      nc.vo.scm.pub.SCMEnv.out(e);
      //按规范抛出异常
      nc.bs.scm.pub.ScmPubDMO.throwBusinessException(e);
    }   
    return queryInfos;
  }
 
  /**
   * 
   * 方法功能描述：过滤出可送审的VO。
   * <p>
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param vos
   * @return
   * <p>
   * @author zhaoyha
   * @time 2009-8-20 下午06:41:14
   */
  protected InvoiceVO[] getNeedSendAuditVos(InvoiceVO[] vos){
    if(null==vos || 0==vos.length) return vos;
    List<InvoiceVO> filterVos=new ArrayList<InvoiceVO>();
    for(InvoiceVO vo:vos){
      SCMEnv.out("------zhaoyha debug------");
      SCMEnv.out("vo.getHeadVO().getIbillstatus():"+vo.getHeadVO().getIbillstatus());
      SCMEnv.out("SCMPfPubUtil.isNeedSendToAudit(ScmConst.PO_Invoice, vo.getHeadVO().getPk_corp(), vo.getHeadVO().getCbiztype(), vo.getPrimaryKey(), vo.getHeadVO().getCoperator()))："+
          System.getProperty("line.separator")+
          SCMPfPubUtil.isNeedSendToAudit(ScmConst.PO_Invoice, vo.getHeadVO().getPk_corp(),
              vo.getHeadVO().getCbiztype(), vo.getPrimaryKey(), vo.getHeadVO().getCoperator()));
      SCMEnv.out("------zhaoyha debug------");
      if((BillStatus.FREE.intValue()==vo.getHeadVO().getIbillstatus().intValue() ||
          BillStatus.AUDITFAIL.intValue()==vo.getHeadVO().getIbillstatus().intValue())
          && SCMPfPubUtil.isNeedSendToAudit(ScmConst.PO_Invoice, vo.getHeadVO().getPk_corp(),
          vo.getHeadVO().getCbiztype(), vo.getPrimaryKey(), vo.getHeadVO().getCoperator()))
        filterVos.add(vo);
    }
    return filterVos.toArray(new InvoiceVO[filterVos.size()]);
  }
  
  /**
   * 
   * 方法功能描述：设置发票是否需要送审的标志。
   * <p>
   * <p>用getAttributeValue("bNeedSendAudit")可以读取UFBoolean,TRUE-是，null/FALSE-否
   * <b>examples:</b>
   * <p>
   * 使用示例
   * <p>
   * <b>参数说明</b>
   * @param vos
   * <p>
   * @author zhaoyha
   * @time 2009-8-27 上午09:22:43
   */
  public void setNeedSendAuditFlag(InvoiceVO[] vos){
    if(null==vos || 0==vos.length) return;
    Set<InvoiceVO> needVos=new HashSet<InvoiceVO>(Arrays.asList(getNeedSendAuditVos(vos)));
//    SCMEnv.out("------zhaoyha debug------");
//    SCMEnv.out("返回的需要送审的VO："+needVos);
//    SCMEnv.out("------zhaoyha debug------");
    for(InvoiceVO vo:vos)
      if(needVos.contains(vo))
        vo.getHeadVO().setAttributeValue(ConstantVO.EXT_ATTR_ISNEEDSENDAUDIT, UFBoolean.TRUE);
      else
        vo.getHeadVO().setAttributeValue(ConstantVO.EXT_ATTR_ISNEEDSENDAUDIT, UFBoolean.FALSE);
  }
  /**
 * @function 费用暂估应付的红冲单
 *
 * @author QuSida
 *
 * @param voaInv
 * @throws BusinessException 
 *
 * @return void
 *
 * @date 2010-9-26 下午03:14:24
 */
public void adjustForFeeZGYF(InvoiceVO[] voaInv) throws BusinessException {
	
	    try {
	      // 参数正确性检查
	      if (voaInv == null || voaInv.length == 0) {
	        return;
	      }
	      for (int i = 0; i < voaInv.length; i++) {
	        if (voaInv[i] == null)
	          return;
	      }

	      // 得到每个发票体id对应的发票头id,发票头id对应的审批日期和审批人
	      Hashtable htHeadId = new Hashtable();
	      Hashtable htAuditPsnId = new Hashtable();
	      Hashtable htAuditDate = new Hashtable();
	      InvoiceItemVO[] aInvoiceItemVOs = null;
	      InvoiceHeaderVO aInvoiceHeaderVO = null;
	      for (int i = 0; i < voaInv.length; i++) {

	        aInvoiceHeaderVO = (InvoiceHeaderVO) voaInv[i].getParentVO();

	        htAuditPsnId.put(aInvoiceHeaderVO.getCinvoiceid(), aInvoiceHeaderVO.getCauditpsn());
	        htAuditDate.put(aInvoiceHeaderVO.getCinvoiceid(), aInvoiceHeaderVO.getDauditdate());

	        aInvoiceItemVOs = (InvoiceItemVO[]) voaInv[i].getChildrenVO();
	        if (aInvoiceItemVOs == null || aInvoiceItemVOs.length == 0) {
	          continue;
	        }

	        for (int j = 0; j < aInvoiceItemVOs.length; j++) {
	          htHeadId.put(aInvoiceItemVOs[j].getCinvoice_bid(), aInvoiceItemVOs[j].getCinvoiceid());
	        }

	      }

	      // 判断应付是否启用
	      ICreateCorpQueryService myService0 = null;
	      myService0 = (ICreateCorpQueryService) nc.bs.framework.common.NCLocator.getInstance().lookup(
	          ICreateCorpQueryService.class.getName());
	      String unitCode = ((InvoiceHeaderVO) voaInv[0].getParentVO()).getPk_corp();
	      boolean bAPStartUp = myService0.isEnabled(unitCode, "AP");
	      if (!bAPStartUp) {
	        return;
	      }

	      // 获取暂估应付冲减VO
	      IAdjuestVO washVO[] = new InvoiceDMO().washDataForFeeZGYF(voaInv);

	      if (washVO != null && washVO.length > 0) {
	        /*
	         * 生成并回写发票的处理编号, since v502 since v53, 修改，解决如下问题：
	         * 如果是来源于同一行入库单时，要拆分成多个处理编号处理，否则发票弃审时按处理编号+入库单行删除红冲单时会多删除单据!
	         */
	        ArrayList<ArrayList<IAdjuestVO>> listRepeatVos = getVos(washVO);
	        // 按分好组的多组数据回冲
	        if (listRepeatVos.size() > 0) {
	          PubDMO dmo = new PubDMO();
	          for (int i = 0; i < listRepeatVos.size(); i++) {
	            washVO = listRepeatVos.get(i).toArray(new IAdjuestVO[listRepeatVos.get(i).size()]);
	            adjustForFeeZGYFOneByOne(washVO, unitCode, htHeadId, htAuditPsnId, htAuditDate, dmo);
	          }
	        }
	      }
	    }
	    catch (Exception e) {
	      /* 调用采购公用方法按规范抛出异常 */
	      nc.bs.pu.pub.PubDMO.throwBusinessException(e);
	    }
	  }

	  /*
	   * 设置是否最后一次回冲并保存暂估应付红冲单据,since v53
	   */
	  private void adjustForFeeZGYFOneByOne(IAdjuestVO[] washVO, String unitCode, Hashtable htHeadId, Hashtable htAuditPsnId,
	      Hashtable htAuditDate, PubDMO dmo) throws Exception {
	    // 通过washVO[]组织入库单行id[]及消耗汇总ID[]
	    ArrayList<String> listGeneralBid = new ArrayList<String>();
	    ArrayList<String> listVmiHid = new ArrayList<String>();
	    for (int i = 0; i < washVO.length; i++) {
	      if (washVO[i].isVmi()) {
	        listVmiHid.add(washVO[i].getDdhh());
	      }
	      else {
	        listGeneralBid.add(washVO[i].getDdhh());
	      }
	    }
	    String[] saGeneralBid = new String[listGeneralBid.size()];
	    listGeneralBid.toArray(saGeneralBid);
	    String[] saVmiHid = new String[listVmiHid.size()];
	    listVmiHid.toArray(saVmiHid);

	    // 根据入库单行id[]去查询入库单表体上的暂估数量(实收数量)
//	    HashMap htInNum = new HashMap();
//	    if (saGeneralBid != null && saGeneralBid.length > 0) {
//	      htInNum = dmo.queryArrayValues("ic_general_b", "cgeneralbid", new String[] {
//	        "ninnum"
//	      }, saGeneralBid, "dr=0");
//	    }
	    // 根据VMI头id[]去查询暂估数量(出库数量-出库退回数量)
	    // For V56 适应库存VMI调整做相应修改 by zhaoyha
//	    HashMap htInNumVmi = new HashMap();
//	    if (saVmiHid != null && saVmiHid.length > 0) {
//	      htInNumVmi = dmo.queryArrayValues("ic_vmi_sum", "cvmihid", new String[] {
//	        "coalesce(nrsvnum1,0)"
//	      }, saVmiHid, "dr=0");
//	    }
	    // 根据入库单行id[]去查询ic_general_bb3上的暂估应付累计回冲(结算)数量
//	    HashMap htAccumWashNum = new HashMap();
//	    if (saGeneralBid != null && saGeneralBid.length > 0) {
//	      htAccumWashNum = dmo.queryArrayValues("ic_general_bb3", "cgeneralbid", new String[] {
//	        "naccumwashnum"
//	      }, saGeneralBid, "dr=0");
//	    }
	    // 根据VMI头id[]去查询累计回冲(结算)数量
//	    HashMap htAccumWashNumVmi = new HashMap();
//	    if (saVmiHid != null && saVmiHid.length > 0) {
//	      htAccumWashNumVmi = dmo.queryArrayValues("ic_vmi_sum", "cvmihid", new String[] {
//	        "naccumwashnum"
//	      }, saVmiHid, "dr=0");
//	    }
	    // 根据 实收数量 ==? （累计回冲数量 + 本次回冲数量）来组织 是否最后一次冲减
	    String strGeneralBid = null;
	    String strInvoiceHid = null;
	    String strAuditPsnId = null;
	    UFDate ufdatAuditDate = null;
	    String strVmiBid = null;

	    Object objTemp = null;
	    Object[] oaTemp = null;
	    UFDouble ufdInNum = new UFDouble(0);
	    UFDouble ufdAccumWashNum = new UFDouble(0);
	    UFBoolean ufbLast[] = new UFBoolean[washVO.length];

	    IArapForGYLPublic iArap = (IArapForGYLPublic) NCLocator.getInstance().lookup(IArapForGYLPublic.class.getName());
	    InvoiceDMO invoiceDMO = new InvoiceDMO();
	    //
	    ArrayList<String> listIdBB3 = new ArrayList<String>();
	    ArrayList<String> listIdVmi = new ArrayList<String>();
	    ArrayList<UFDouble> listNumBB3 = new ArrayList<UFDouble>();
	    ArrayList<UFDouble> listNumVmi = new ArrayList<UFDouble>();
	    for (int i = 0; i < washVO.length; i++) {
	      strVmiBid = null;
//	      strGeneralBid = null;
//	      if (washVO[i].isVmi()) {
//	        strVmiBid = washVO[i].getDdhh();
//	      }
//	      else {
//	        strGeneralBid = washVO[i].getDdhh();
//	      }
//	      if ((strGeneralBid == null || strGeneralBid.trim().length() == 0)
//	          && (strVmiBid == null || strVmiBid.trim().length() == 0)) {
//	        continue;
//	      }
	      // 实收数量
//	      if (washVO[i].isVmi()) {
//	        objTemp = htInNumVmi.get(strVmiBid);
//	      }
//	      else {
//	        objTemp = htInNum.get(strGeneralBid);
//	      }
//	      if (objTemp != null) {
//	        oaTemp = (Object[]) objTemp;
//	        if (oaTemp.length > 0 && oaTemp[0] != null) {
//	          ufdInNum = new UFDouble(oaTemp[0].toString());
//	        }
//	      }
//	      // 累计回冲数量
//	      ufdAccumWashNum = washVO[i].getShl();
//	      if (washVO[i].isVmi()) {
//	        objTemp = htAccumWashNumVmi.get(strVmiBid);
//	      }
//	      else {
//	        objTemp = htAccumWashNum.get(strGeneralBid);
//	      }
//	      if (objTemp != null) {
//	        oaTemp = (Object[]) objTemp;
//	        if (oaTemp.length > 0 && oaTemp[0] != null) {
//	          ufdAccumWashNum = (new UFDouble(oaTemp[0].toString())).add(ufdAccumWashNum);
//	        }
//	      }
//	      if (washVO[i].isVmi()) {
//	        htAccumWashNum.put(strVmiBid, new UFDouble[] {
//	          ufdAccumWashNum
//	        });
//	      }
//	      else {
//	        htAccumWashNum.put(strGeneralBid, new UFDouble[] {
//	          ufdAccumWashNum
//	        });
//	      }
//	      // 是否最后一次冲减
//	      if (ufdInNum.doubleValue() == ufdAccumWashNum.doubleValue()) {
//	        ufbLast[i] = UFBoolean.TRUE;
//	      }
//	      else {
//	        ufbLast[i] = UFBoolean.FALSE;
//	      }

	      // 根据发票体id查询发票头id
	      objTemp = htHeadId.get(washVO[i].getCinvoice_bid());
	      if (objTemp != null && objTemp.toString().trim().length() > 0) {
	        strInvoiceHid = objTemp.toString();
	      }
	      //
	      washVO[i].setCinvoiceid(strInvoiceHid);

	      // 根据发票头id得到审批人和审批日期
	      objTemp = htAuditPsnId.get(strInvoiceHid);
	      if (objTemp != null && objTemp.toString().trim().length() > 0) {
	        strAuditPsnId = objTemp.toString();
	      }

	      objTemp = htAuditDate.get(strInvoiceHid);
	      if (objTemp != null && objTemp.toString().trim().length() > 0) {
	        ufdatAuditDate = new UFDate(objTemp.toString());
	      }
	      //
	      if (washVO[i].isVmi()) {
	        listIdVmi.add(washVO[i].getDdhh());
	        listNumVmi.add(washVO[i].getShl());
	      }
	      else {
	        listIdBB3.add(washVO[i].getDdhh());
	        listNumBB3.add(washVO[i].getShl());
	      }

//	      washVO[i].setIsdone(ufbLast[i]);
	      washVO[i].setIsdone(UFBoolean.TRUE);
	    }
	    //
	    String strClbh = invoiceDMO.updateClbh(washVO, unitCode, null, false);
	    /*
	     * 调用应付提供的保存+冲减方法冲减暂估应付 后两个参数: lylx (来源类型 0 订单行ID 1 出库单行ID 2 发票行ID ly: 0 销售
	     * 1 采购
	     */
	    
	    //add by ouyangzhb 2011-05-09 把lylx和ly 设为3，后面的程序会为这两个值设置相应的处理代码
	    iArap.Adjuest(washVO, strClbh, strAuditPsnId, ufdatAuditDate.toString(), unitCode, 3, 3);
	    //
	    // 回写ic_general_bb3上的暂估应付累计回冲数量
//	    String[] saDdhhBB3 = null;
//	    UFDouble[] uaNumBB3 = null;
//	    if (listIdBB3.size() > 0) {
//	      saDdhhBB3 = listIdBB3.toArray(new String[listIdBB3.size()]);
//	      uaNumBB3 = listNumBB3.toArray(new UFDouble[listNumBB3.size()]);
//	      invoiceDMO.updateAccumWashNumForIC(saDdhhBB3, uaNumBB3, true);
//	    }
//	    // 回写ic_vmi_sum上的暂估应付累计回冲数量
//	    String[] saDdhhVmi = null;
//	    UFDouble[] uaNumVmi = null;
//	    if (listIdVmi.size() > 0) {
//	      saDdhhVmi = listIdVmi.toArray(new String[listIdVmi.size()]);
//	      uaNumVmi = listNumVmi.toArray(new UFDouble[listNumVmi.size()]);
//	      invoiceDMO.updateAccumWashNumForVmi(saDdhhVmi, uaNumVmi, true);
//	    }
	  }
	  
	  /**
	   * add by ouyangzhb 2011-07-07
	   *手工结算的时候，组织暂估应付冲减VO, 调用应付的调差接口, 冲减暂估应付
	   */
	  public void adjustForSettle(InvoiceVO[] voaInv,SettlebillVO settleVO) throws BusinessException {

	    try {
	      // 参数正确性检查
	      if (voaInv == null || voaInv.length == 0) {
	        return;
	      }
	      for (int i = 0; i < voaInv.length; i++) {
	        if (voaInv[i] == null)
	          return;
	      }
	      
	      HashMap clbhmap=new HashMap();
	      for (int i = 0; i < voaInv.length; i++) {
		        String clbh = voaInv[i].getHeadVO().getClbh();
		        String hinvoiceid = voaInv[i].getHeadVO().getCinvoiceid();
		        clbhmap.put(hinvoiceid, clbh);
		        
		      }
	      

	      // 得到每个发票体id对应的发票头id,发票头id对应的审批日期和审批人
	      Hashtable htHeadId = new Hashtable();
	      Hashtable htAuditPsnId = new Hashtable();
	      Hashtable htAuditDate = new Hashtable();
	      InvoiceItemVO[] aInvoiceItemVOs = null;
	      InvoiceHeaderVO aInvoiceHeaderVO = null;
	      for (int i = 0; i < voaInv.length; i++) {

	        aInvoiceHeaderVO = (InvoiceHeaderVO) voaInv[i].getParentVO();
	        //add by ouyangzhb 2011-07-07 手工结算时，对应的发票必须是已审核的
	        if(aInvoiceHeaderVO.getCauditpsn()==null||aInvoiceHeaderVO.getCauditpsn().equals(" ")){
	        	throw new BusinessException("发票未审核，不能结算！"); 
	        }
	        //add end 

	        htAuditPsnId.put(aInvoiceHeaderVO.getCinvoiceid(), aInvoiceHeaderVO.getCauditpsn());
	        htAuditDate.put(aInvoiceHeaderVO.getCinvoiceid(), aInvoiceHeaderVO.getDauditdate());

	        aInvoiceItemVOs = (InvoiceItemVO[]) voaInv[i].getChildrenVO();
	        if (aInvoiceItemVOs == null || aInvoiceItemVOs.length == 0) {
	          continue;
	        }

	        for (int j = 0; j < aInvoiceItemVOs.length; j++) {
	          htHeadId.put(aInvoiceItemVOs[j].getCinvoice_bid(), aInvoiceItemVOs[j].getCinvoiceid());
	        }

	      }

	      // 判断应付是否启用
	      ICreateCorpQueryService myService0 = null;
	      myService0 = (ICreateCorpQueryService) nc.bs.framework.common.NCLocator.getInstance().lookup(
	          ICreateCorpQueryService.class.getName());
	      String unitCode = ((InvoiceHeaderVO) voaInv[0].getParentVO()).getPk_corp();
	      boolean bAPStartUp = myService0.isEnabled(unitCode, "AP");
	      if (!bAPStartUp) {
	        return;
	      }

	      // 获取暂估应付冲减VO
	      IAdjuestVO washVO[] = new InvoiceDMO().washDataForSettle(voaInv,settleVO);

	      if (washVO != null && washVO.length > 0) {
	        /*
	         * 生成并回写发票的处理编号, since v502 since v53, 修改，解决如下问题：
	         * 如果是来源于同一行入库单时，要拆分成多个处理编号处理，否则发票弃审时按处理编号+入库单行删除红冲单时会多删除单据!
	         */
	        ArrayList<ArrayList<IAdjuestVO>> listRepeatVos = getVos(washVO);
	        // 按分好组的多组数据回冲
	        if (listRepeatVos.size() > 0) {
	          PubDMO dmo = new PubDMO();
	          for (int i = 0; i < listRepeatVos.size(); i++) {
	            washVO = listRepeatVos.get(i).toArray(new IAdjuestVO[listRepeatVos.get(i).size()]);
	            adjustForSettleOneByOne(washVO, unitCode, htHeadId, htAuditPsnId, htAuditDate, dmo, clbhmap);
	          }
	        }
	      }
	    }
	    catch (Exception e) {
	      /* 调用采购公用方法按规范抛出异常 */
	      nc.bs.pu.pub.PubDMO.throwBusinessException(e);
	    }
	  }
	  
	  /**
	   * add by ouyangzhb 2011-07-07
	   *结算单删除，组织暂估应付冲减VO, 调用应付的调差接口, 冲减暂估应付
	   */
	  public void unAdjustForSettle(InvoiceVO[] voaInv,SettlebillVO settleVO) throws BusinessException {

	    try {
	      // 参数正确性检查
	      if (voaInv == null || voaInv.length == 0) {
	    	  
	        return;
	      }

	      // 得到每个发票体id对应的发票头id
	      Hashtable htHeadId = new Hashtable();

	      InvoiceItemVO[] aInvoiceItemVOs = null;
	      for (int i = 0; i < voaInv.length; i++) {
	        aInvoiceItemVOs = (InvoiceItemVO[]) voaInv[i].getChildrenVO();
	        if (aInvoiceItemVOs == null || aInvoiceItemVOs.length == 0) {
	          continue;
	        }

	        for (int j = 0; j < aInvoiceItemVOs.length; j++) {
	          htHeadId.put(aInvoiceItemVOs[j].getCinvoice_bid(), aInvoiceItemVOs[j].getCinvoiceid());
	        }

	      }

	      // 判断应付是否启用
	      ICreateCorpQueryService myService0 = null;
	      myService0 = (ICreateCorpQueryService) nc.bs.framework.common.NCLocator.getInstance().lookup(
	          ICreateCorpQueryService.class.getName());
	      String unitCode = ((InvoiceHeaderVO) voaInv[0].getParentVO()).getPk_corp();
	      boolean bAPStartUp = myService0.isEnabled(unitCode, "AP");
	      if (!bAPStartUp) {
	        return;
	      }

	      // 获取暂估应付冲减VO
	      IAdjuestVO[] washVO = new InvoiceDMO().antiWashDataForSettle(voaInv,settleVO);

	      if (washVO != null && washVO.length > 0) {

	        // 通过washVO[]组织入库单行id[]
	        String[] saGeneralBid = new String[washVO.length];
	        for (int i = 0; i < washVO.length; i++) {
	          saGeneralBid[i] = washVO[i].getDdhh();
	        }

	        String strInvoiceHid = null;
	        Object objTemp = null;

	        InvoiceDMO invoiceDMO = new InvoiceDMO();
	        //
	        ArrayList<IAdjuestVO> listAdjuestVO = new ArrayList<IAdjuestVO>();
	        ArrayList<String> listInvoiceHid = new ArrayList<String>();
	        for (int i = 0; i < washVO.length; i++) {

	          // 根据发票体id查询发票头id
	          objTemp = htHeadId.get(washVO[i].getCinvoice_bid());
	          if (objTemp == null || objTemp.toString().trim().length() == 0) {
	            continue;
	          }
	          strInvoiceHid = objTemp.toString();
	          //
	          if (!listInvoiceHid.contains(strInvoiceHid)) {
	            listInvoiceHid.add(strInvoiceHid);
	          }
	          //
	          washVO[i].setCinvoiceid(strInvoiceHid);
	          listAdjuestVO.add(washVO[i]);

	          // 调用应付提供的保存+冲减方法冲减暂估应付
	          // iArap.unAdjuest(strInvoiceHid,unitCode);

	          // 回写ic_general_bb3上的暂估应付累计回冲数量
	          if (washVO[i].isVmi()) {
	            invoiceDMO.updateAccumWashNumForVmi(new String[] {
	              washVO[i].getDdhh()
	            }, new UFDouble[] {
	              washVO[i].getShl()
	            }, false);
	          }
	          else {
	            invoiceDMO.updateAccumWashNumForIC(new String[] {
	              washVO[i].getDdhh()
	            }, new UFDouble[] {
	              washVO[i].getShl()
	            }, false);
	          }
	        }
	        // 调用应付提供的保存+冲减方法冲减暂估应付
	        if (listAdjuestVO.size() > 0) {
	          Hashtable hashHidClbh = new PubDMO().queryHtResultFromAnyTable("po_invoice", "cinvoiceid", new String[] {
	            "clbh"
	          }, " cinvoiceid in " + new TempTableUtil().getSubSql(listInvoiceHid));
	          if (hashHidClbh != null && hashHidClbh.size() > 0) {
	            Map<String, Map<String, String>> clbhs = new HashMap<String, Map<String, String>>();
	            Map<String, String> mapDdhh = null;
	            String strClbh = null;
	            Vector vClbh = null;
	            IAdjuestVO voAdjust = null;
	            String strLylx = "1";
	            ArrayList<IAdjuestVO> listAdjuestVos = new ArrayList<IAdjuestVO>();
	            for (int i = 0; i < listAdjuestVO.size(); i++) {
	              voAdjust = (IAdjuestVO) listAdjuestVO.get(i);
	              strInvoiceHid = voAdjust.getCinvoiceid();
	              vClbh = (Vector) hashHidClbh.get(strInvoiceHid);
	              if (vClbh == null || vClbh.size() == 0) {
	                continue;
	              }
	              strClbh = (String) ((Object[]) vClbh.get(0))[0];
	              if (PuPubVO.getString_TrimZeroLenAsNull(strClbh) == null) {
	                continue;
	              }
	              listAdjuestVos.add(voAdjust);
	              mapDdhh = clbhs.get(strClbh);
	              if (mapDdhh == null) {
	                mapDdhh = new HashMap<String, String>();
	              }
	              mapDdhh.put(voAdjust.getDdhh(), strLylx);
	              clbhs.put(strClbh, mapDdhh);
	            }
	            //
	            if (clbhs.size() > 0) {
	              IArapForGYLPublic iArap = (IArapForGYLPublic) NCLocator.getInstance().lookup(
	                  IArapForGYLPublic.class.getName());
	              iArap.unAdjuestForGC(clbhs, unitCode);
	            }
	           

//	            // 更新处理编号
//	            if (listAdjuestVos.size() > 0) {
//	              invoiceDMO.updateClbh(listAdjuestVO.toArray(new IAdjuestVO[listAdjuestVO.size()]), null, null, true);
//	            }
	          }
	        }
	      }
	    }
	    catch (Exception e) {
	      PubDMO.throwBusinessException(e);
	    }
	  }

	  /*
	   * 设置是否最后一次回冲并保存暂估应付红冲单据,since v53
	   */
	  private void adjustForSettleOneByOne(IAdjuestVO[] washVO, String unitCode, Hashtable htHeadId, Hashtable htAuditPsnId,
	      Hashtable htAuditDate, PubDMO dmo,HashMap clbhmap) throws Exception {
	    // 通过washVO[]组织入库单行id[]及消耗汇总ID[]
	    ArrayList<String> listGeneralBid = new ArrayList<String>();
	    ArrayList<String> listVmiHid = new ArrayList<String>();
	    for (int i = 0; i < washVO.length; i++) {
	      if (washVO[i].isVmi()) {
	        listVmiHid.add(washVO[i].getDdhh());
	      }
	      else {
	        listGeneralBid.add(washVO[i].getDdhh());
	      }
	    }
	    String[] saGeneralBid = new String[listGeneralBid.size()];
	    listGeneralBid.toArray(saGeneralBid);
	    String[] saVmiHid = new String[listVmiHid.size()];
	    listVmiHid.toArray(saVmiHid);

	    // 根据入库单行id[]去查询入库单表体上的暂估数量(实收数量)
	    HashMap htInNum = new HashMap();
	    if (saGeneralBid != null && saGeneralBid.length > 0) {
	      htInNum = dmo.queryArrayValues("ic_general_b", "cgeneralbid", new String[] {
	        "ninnum"
	      }, saGeneralBid, "dr=0");
	    }
	    // 根据VMI头id[]去查询暂估数量(出库数量-出库退回数量)
	    // For V56 适应库存VMI调整做相应修改 by zhaoyha
	    HashMap htInNumVmi = new HashMap();
	    if (saVmiHid != null && saVmiHid.length > 0) {
	      htInNumVmi = dmo.queryArrayValues("ic_vmi_sum", "cvmihid", new String[] {
	        "coalesce(nrsvnum1,0)"
	      }, saVmiHid, "dr=0");
	    }
	    // 根据入库单行id[]去查询ic_general_bb3上的暂估应付累计回冲(结算)数量
	    HashMap htAccumWashNum = new HashMap();
	    if (saGeneralBid != null && saGeneralBid.length > 0) {
	      htAccumWashNum = dmo.queryArrayValues("ic_general_bb3", "cgeneralbid", new String[] {
	        "naccumwashnum"
	      }, saGeneralBid, "dr=0");
	    }
	    // 根据VMI头id[]去查询累计回冲(结算)数量
	    HashMap htAccumWashNumVmi = new HashMap();
	    if (saVmiHid != null && saVmiHid.length > 0) {
	      htAccumWashNumVmi = dmo.queryArrayValues("ic_vmi_sum", "cvmihid", new String[] {
	        "naccumwashnum"
	      }, saVmiHid, "dr=0");
	    }
	    // 根据 实收数量 ==? （累计回冲数量 + 本次回冲数量）来组织 是否最后一次冲减
	    String strGeneralBid = null;
	    String strInvoiceHid = null;
	    String strAuditPsnId = null;
	    UFDate ufdatAuditDate = null;
	    String strVmiBid = null;

	    Object objTemp = null;
	    Object[] oaTemp = null;
	    UFDouble ufdInNum = new UFDouble(0);
	    UFDouble ufdAccumWashNum = new UFDouble(0);
	    UFBoolean ufbLast[] = new UFBoolean[washVO.length];

	    IArapForGYLPublic iArap = (IArapForGYLPublic) NCLocator.getInstance().lookup(IArapForGYLPublic.class.getName());
	    InvoiceDMO invoiceDMO = new InvoiceDMO();
	    //
	    ArrayList<String> listIdBB3 = new ArrayList<String>();
	    ArrayList<String> listIdVmi = new ArrayList<String>();
	    ArrayList<UFDouble> listNumBB3 = new ArrayList<UFDouble>();
	    ArrayList<UFDouble> listNumVmi = new ArrayList<UFDouble>();
	    for (int i = 0; i < washVO.length; i++) {
	      strVmiBid = null;
	      strGeneralBid = null;
	      if (washVO[i].isVmi()) {
	        strVmiBid = washVO[i].getDdhh();
	      }
	      else {
	        strGeneralBid = washVO[i].getDdhh();
	      }
	      if ((strGeneralBid == null || strGeneralBid.trim().length() == 0)
	          && (strVmiBid == null || strVmiBid.trim().length() == 0)) {
	        continue;
	      }
	      // 实收数量
	      if (washVO[i].isVmi()) {
	        objTemp = htInNumVmi.get(strVmiBid);
	      }
	      else {
	        objTemp = htInNum.get(strGeneralBid);
	      }
	      if (objTemp != null) {
	        oaTemp = (Object[]) objTemp;
	        if (oaTemp.length > 0 && oaTemp[0] != null) {
	          ufdInNum = new UFDouble(oaTemp[0].toString());
	        }
	      }
	      // 累计回冲数量
	      ufdAccumWashNum = washVO[i].getShl();
	      if (washVO[i].isVmi()) {
	        objTemp = htAccumWashNumVmi.get(strVmiBid);
	      }
	      else {
	        objTemp = htAccumWashNum.get(strGeneralBid);
	      }
	      if (objTemp != null) {
	        oaTemp = (Object[]) objTemp;
	        if (oaTemp.length > 0 && oaTemp[0] != null) {
	          ufdAccumWashNum = (new UFDouble(oaTemp[0].toString())).add(ufdAccumWashNum);
	        }
	      }
	      if (washVO[i].isVmi()) {
	        htAccumWashNum.put(strVmiBid, new UFDouble[] {
	          ufdAccumWashNum
	        });
	      }
	      else {
	        htAccumWashNum.put(strGeneralBid, new UFDouble[] {
	          ufdAccumWashNum
	        });
	      }
	      // 是否最后一次冲减
	      if (ufdInNum.doubleValue() == ufdAccumWashNum.doubleValue()) {
	        ufbLast[i] = UFBoolean.TRUE;
	      }
	      else {
	        ufbLast[i] = UFBoolean.FALSE;
	      }

	      // 根据发票体id查询发票头id
	      objTemp = htHeadId.get(washVO[i].getCinvoice_bid());
	      if (objTemp != null && objTemp.toString().trim().length() > 0) {
	        strInvoiceHid = objTemp.toString();
	      }
	      //
	      washVO[i].setCinvoiceid(strInvoiceHid);

	      // 根据发票头id得到审批人和审批日期
	      objTemp = htAuditPsnId.get(strInvoiceHid);
	      if (objTemp != null && objTemp.toString().trim().length() > 0) {
	        strAuditPsnId = objTemp.toString();
	      }

	      objTemp = htAuditDate.get(strInvoiceHid);
	      if (objTemp != null && objTemp.toString().trim().length() > 0) {
	        ufdatAuditDate = new UFDate(objTemp.toString());
	      }
	      //
	      if (washVO[i].isVmi()) {
	        listIdVmi.add(washVO[i].getDdhh());
	        listNumVmi.add(washVO[i].getShl());
	      }
	      else {
	        listIdBB3.add(washVO[i].getDdhh());
	        listNumBB3.add(washVO[i].getShl());
	      }

	      washVO[i].setIsdone(ufbLast[i]);
	    }
	    
	    
	    //获取处理编号，只取第一个
	    String clbh = null;
	    for(int i=0;i<washVO.length;i++){
	    	clbh = (String) clbhmap.get(washVO[i].getCinvoiceid());
	    	if(clbh!=null&&!clbh.equals(""))
	    		break;
	    	
	    }
	    
	    //当存在发票已经做过部分结算时，可以处理编号设置为之前的编号，已处理多次结算时无法删除冲减的应付单
	    String strClbh =null;
	    if(clbh!=null&&!clbh.equals("")){
	    	strClbh = invoiceDMO.updateClbh(washVO, unitCode, clbh, false);
	    }else{
	    	strClbh = invoiceDMO.updateClbh(washVO, unitCode, null, false);
	    }
	   
	    /*
	     * 调用应付提供的保存+冲减方法冲减暂估应付 后两个参数: lylx (来源类型 0 订单行ID 1 出库单行ID 2 发票行ID ly: 0 销售
	     * 1 采购
	     */
	    iArap.Adjuest(washVO, strClbh, strAuditPsnId, ufdatAuditDate.toString(), unitCode, 1, 1);
	    //
	    // 回写ic_general_bb3上的暂估应付累计回冲数量
	    String[] saDdhhBB3 = null;
	    UFDouble[] uaNumBB3 = null;
	    if (listIdBB3.size() > 0) {
	      saDdhhBB3 = listIdBB3.toArray(new String[listIdBB3.size()]);
	      uaNumBB3 = listNumBB3.toArray(new UFDouble[listNumBB3.size()]);
	      invoiceDMO.updateAccumWashNumForIC(saDdhhBB3, uaNumBB3, true);
	    }
	    // 回写ic_vmi_sum上的暂估应付累计回冲数量
	    String[] saDdhhVmi = null;
	    UFDouble[] uaNumVmi = null;
	    if (listIdVmi.size() > 0) {
	      saDdhhVmi = listIdVmi.toArray(new String[listIdVmi.size()]);
	      uaNumVmi = listNumVmi.toArray(new UFDouble[listNumVmi.size()]);
	      invoiceDMO.updateAccumWashNumForVmi(saDdhhVmi, uaNumVmi, true);
	    }
	  }

	  /**
	 * add by ouyangzhb 2013-10-14 回写累计开票数量（保存）
	 * 
	 * @param vos
	 * @param isdel
	 * @throws BusinessException
	 */
	public void reWriteInvoicenumByAdd(InvoiceVO invvo)
			throws BusinessException {
		BaseDAO dao = new BaseDAO();
		if (invvo == null) {
			return;
		}
		InvoiceItemVO[] itemvo = (InvoiceItemVO[]) invvo.getChildrenVO();
		for (int j = 0; j < itemvo.length; j++) {
			String updatesql = "";
			String querysql = "";
			String invoice_bid = itemvo[j].getCinvoice_bid();
			String sourcebillrowid = itemvo[j].getCupsourcebillrowid();
			if (invoice_bid != null) {

				// 查询累计开票数量是否超出原有数量
				querysql = "select (abs(nvl(fb.dfshl,0)) - abs(isnull(fb.ntotalinvoicenumber,0) + '"
						+ itemvo[j].getNinvoicenum()
						+ "'-(select isnull(ninvoicenum,0) from po_invoice_b b where b.cinvoice_bid='"
						+ invoice_bid
						+ "'))) num from arap_djfb  fb where  fb.fb_oid='"
						+ sourcebillrowid + "' ";

				// ntotalinvoicenumber 后_新增字段
				updatesql = "update arap_djfb  fb set fb.ntotalinvoicenumber = isnull(fb.ntotalinvoicenumber,0) + '"
						+ itemvo[j].getNinvoicenum()
						+ "'-(select isnull(ninvoicenum,0) from po_invoice_b b where b.cinvoice_bid='"
						+ invoice_bid
						+ "') where fb.fb_oid='"
						+ sourcebillrowid + "'";
			} else {

				// 查询语句
				querysql = "select (abs(nvl(fb.dfshl,0)) - abs(isnull(fb.ntotalinvoicenumber,0) + '"
						+ itemvo[j].getNinvoicenum()
						+ "')) num from arap_djfb  fb where  fb.fb_oid='"
						+ sourcebillrowid + "' ";
				// 更新语句
				updatesql = "update arap_djfb  fb set fb.ntotalinvoicenumber = isnull(fb.ntotalinvoicenumber,0) + '"
						+ itemvo[j].getNinvoicenum()
						+ "' where fb.fb_oid='"
						+ sourcebillrowid + "'";
			}
			HashMap<String, UFDouble> nummap = (HashMap<String, UFDouble>) dao
					.executeQuery(querysql, new MapProcessor());
			if (nummap != null && nummap.size() > 0) {
				Object numtem = nummap.get("num");

				if (numtem != null
						&& new UFDouble(numtem.toString()).toDouble() < 0) {
					throw new BusinessException("第" + itemvo[j].getCrowno()
							+ "行的累计开单数量已超出可开单数量:"+new UFDouble(numtem.toString())+"，不能保存，请检查！");
				}
			}

			dao.executeUpdate(updatesql);

			String updatezyx17 = "update arap_djfb  fb set fb.zyx17 = TO_CHAR(isnull(fb.ntotalinvoicenumber,0))  where fb.fb_oid='"
					+ sourcebillrowid + "'";// fb.zyx17

			dao.executeUpdate(updatezyx17);
		}
	}
			
  
		
		
		 /**
		 * add by ouyangzhb 2013-10-14 回写累计开票数量(h除)
		 * @param vos
		 * @param isdel
		 * @throws DAOException
		 */
		public void reWriteInvoicenumByDel(InvoiceVO[] invvos)
			throws DAOException {
		BaseDAO dao = new BaseDAO();
		if (invvos == null || invvos.length == 0) {
			return;
		}
		int len = invvos.length;
		for (int i = 0; i < len; i++) {
			InvoiceItemVO[] itemvo = (InvoiceItemVO[]) invvos[i]
					.getChildrenVO();
			for (int j = 0; j < itemvo.length; j++) {
				String updatesql = "";
				String invoice_bid = itemvo[j].getCinvoice_bid();
				String sourcebillrowid = itemvo[j].getCupsourcebillrowid();
				updatesql = "update arap_djfb  fb set fb.ntotalinvoicenumber = isnull(fb.ntotalinvoicenumber,0) - '"
						+ itemvo[j].getNinvoicenum()
						+ "' where fb.fb_oid='"
						+ sourcebillrowid + "'";

				dao.executeUpdate(updatesql);
				
				String updatezyx17 = "update arap_djfb  fb set fb.zyx17 = TO_CHAR(isnull(fb.ntotalinvoicenumber,0))  where fb.fb_oid='"
					+ sourcebillrowid + "'";//fb.zyx17
				
				dao.executeUpdate(updatezyx17);
			}
		}

	}
		
		
		
}